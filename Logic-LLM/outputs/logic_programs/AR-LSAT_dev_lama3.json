[
  {
    "id": "ar_lsat_200006_1-G_1_1",
    "context": "Four boys—Fred, Juan, Marc, and Paul—and three girls—Nita, Rachel, and Trisha—will be assigned to a row of five adjacent lockers, numbered consecutively 1 through 5, arranged along a straight wall. The following conditions govern the assignment of lockers to the seven children: Each locker must be assigned to either one or two children, and each child must be assigned to exactly one locker. Each shared locker must be assigned to one girl and one boy. Juan must share a locker, but Rachel cannot share a locker. Nita's locker cannot be adjacent to Trisha's locker. Fred must be assigned to locker 3.",
    "question": "Which one of the following is a complete and accurate list of the children who must be among those assigned to shared lockers?",
    "answer": "E",
    "options": [
      "A) Fred, Juan",
      "B) Juan, Paul",
      "C) Juan, Marc, Paul",
      "D) Juan, Marc, Trisha",
      "E) Juan, Nita, Trisha"
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each problem:\n\n**Problem 1**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat"
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_1_2",
    "context": "Four boys—Fred, Juan, Marc, and Paul—and three girls—Nita, Rachel, and Trisha—will be assigned to a row of five adjacent lockers, numbered consecutively 1 through 5, arranged along a straight wall. The following conditions govern the assignment of lockers to the seven children: Each locker must be assigned to either one or two children, and each child must be assigned to exactly one locker. Each shared locker must be assigned to one girl and one boy. Juan must share a locker, but Rachel cannot share a locker. Nita's locker cannot be adjacent to Trisha's locker. Fred must be assigned to locker 3.",
    "question": "If Trisha is assigned to locker 3 and Marc alone is assigned to locker 1, then which one of the following must be true?",
    "answer": "B",
    "options": [
      "A) Juan is assigned to locker 4.",
      "B) Juan is assigned to locker 5.",
      "C) Paul is assigned to locker 2.",
      "D) Rachel is assigned to locker 2.",
      "E) Rachel is assigned to locker 5."
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each problem:\n\n**Problem 1: Vladimir and Wendy's meals**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2: Repair facility**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena"
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_1_3",
    "context": "Four boys—Fred, Juan, Marc, and Paul—and three girls—Nita, Rachel, and Trisha—will be assigned to a row of five adjacent lockers, numbered consecutively 1 through 5, arranged along a straight wall. The following conditions govern the assignment of lockers to the seven children: Each locker must be assigned to either one or two children, and each child must be assigned to exactly one locker. Each shared locker must be assigned to one girl and one boy. Juan must share a locker, but Rachel cannot share a locker. Nita's locker cannot be adjacent to Trisha's locker. Fred must be assigned to locker 3.",
    "question": "If the four boys are assigned to consecutively numbered lockers and Juan is assigned to locker 5, then which one of the following is a complete and accurate list of lockers each of which CANNOT be a shared locker?",
    "answer": "D",
    "options": [
      "A) locker 2",
      "B) locker 4",
      "C) locker 1, locker 2",
      "D) locker 1, locker 4",
      "E) locker 2, locker 4"
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each problem:\n\n**Problem 1: Vladimir and Wendy's Meals**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2: Technicians and Machines**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs"
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_1_4",
    "context": "Four boys—Fred, Juan, Marc, and Paul—and three girls—Nita, Rachel, and Trisha—will be assigned to a row of five adjacent lockers, numbered consecutively 1 through 5, arranged along a straight wall. The following conditions govern the assignment of lockers to the seven children: Each locker must be assigned to either one or two children, and each child must be assigned to exactly one locker. Each shared locker must be assigned to one girl and one boy. Juan must share a locker, but Rachel cannot share a locker. Nita's locker cannot be adjacent to Trisha's locker. Fred must be assigned to locker 3.",
    "question": "Once Rachel has been assigned to a locker, what is the maximum number of different lockers each of which could be the locker to which Juan is assigned?",
    "answer": "C",
    "options": [
      "A) one",
      "B) two",
      "C) three",
      "D) four",
      "E) five"
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each problem:\n\n**Problem 1: Vladimir and Wendy's meals**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2: Repair facility technicians**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(X"
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_1_5",
    "context": "Four boys—Fred, Juan, Marc, and Paul—and three girls—Nita, Rachel, and Trisha—will be assigned to a row of five adjacent lockers, numbered consecutively 1 through 5, arranged along a straight wall. The following conditions govern the assignment of lockers to the seven children: Each locker must be assigned to either one or two children, and each child must be assigned to exactly one locker. Each shared locker must be assigned to one girl and one boy. Juan must share a locker, but Rachel cannot share a locker. Nita's locker cannot be adjacent to Trisha's locker. Fred must be assigned to locker 3.",
    "question": "If the first three lockers are assigned to girls, which one of the following must be true?",
    "answer": "A",
    "options": [
      "A) Juan is assigned to locker 1.",
      "B) Nita is assigned to locker 3.",
      "C) Trisha is assigned to locker 1.",
      "D) Juan is assigned to the same locker as Trisha.",
      "E) Paul is assigned to the same locker as Trisha."
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each problem:\n\n**Problem 1:**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2:**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\n"
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_1_6",
    "context": "Four boys—Fred, Juan, Marc, and Paul—and three girls—Nita, Rachel, and Trisha—will be assigned to a row of five adjacent lockers, numbered consecutively 1 through 5, arranged along a straight wall. The following conditions govern the assignment of lockers to the seven children: Each locker must be assigned to either one or two children, and each child must be assigned to exactly one locker. Each shared locker must be assigned to one girl and one boy. Juan must share a locker, but Rachel cannot share a locker. Nita's locker cannot be adjacent to Trisha's locker. Fred must be assigned to locker 3.",
    "question": "If lockers 1 and 2 are each assigned to one boy and are not shared lockers, then locker 4 must be assigned to",
    "answer": "C",
    "options": [
      "A) Juan",
      "B) Paul",
      "C) Rachel",
      "D) Juan and Nita",
      "E) Marc and Trisha"
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each problem:\n\n**Problem 1: Vladimir and Wendy's meals**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2: Technicians and machines**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs"
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_2_7",
    "context": "A music store carries exactly ten types of CDs—both new and used of each of jazz, opera, pop, rap, and soul. The store is having a sale on some of these types of CDs. The following conditions must apply: Used pop is on sale; new opera is not. If both types of pop are on sale, then all soul is. If both types of jazz are on sale, then no rap is. If neither type of jazz is on sale, then new pop is. If either type of rap is on sale, then no soul is.",
    "question": "Which one of the following could be a complete and accurate list of the types of CDs that are on sale?",
    "answer": "E",
    "options": [
      "A) new jazz, used jazz, used opera, used pop, new rap",
      "B) new jazz, used pop, used rap, new soul",
      "C) used opera, used pop, new rap, used rap",
      "D) used opera, new pop, used pop, new soul",
      "E) used jazz, used pop, new soul, used soul"
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each problem:\n\n**Problem 1: Vladimir and Wendy's Meals**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2: Repair Facility**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena"
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_2_8",
    "context": "A music store carries exactly ten types of CDs—both new and used of each of jazz, opera, pop, rap, and soul. The store is having a sale on some of these types of CDs. The following conditions must apply: Used pop is on sale; new opera is not. If both types of pop are on sale, then all soul is. If both types of jazz are on sale, then no rap is. If neither type of jazz is on sale, then new pop is. If either type of rap is on sale, then no soul is.",
    "question": "If new soul is not on sale, then which one of the following must be true?",
    "answer": "E",
    "options": [
      "A) New rap is not on sale.",
      "B) New rap is on sale.",
      "C) Used opera is not on sale.",
      "D) At least one type of jazz is not on sale.",
      "E) At least one type of pop is not on sale."
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each problem:\n\n**Problem 1: Vladimir and Wendy's Meals**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2: Repair Facility**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena"
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_2_9",
    "context": "A music store carries exactly ten types of CDs—both new and used of each of jazz, opera, pop, rap, and soul. The store is having a sale on some of these types of CDs. The following conditions must apply: Used pop is on sale; new opera is not. If both types of pop are on sale, then all soul is. If both types of jazz are on sale, then no rap is. If neither type of jazz is on sale, then new pop is. If either type of rap is on sale, then no soul is.",
    "question": "If both types of jazz are on sale, then which one of the following is the minimum number of types of new CDs that could be included in the sale?",
    "answer": "A",
    "options": [
      "A) one",
      "B) two",
      "C) three",
      "D) four",
      "E) five"
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each of the problems:\n\n**Problem 1: Vladimir and Wendy's meals**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2: Repair facility**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs"
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_2_10",
    "context": "A music store carries exactly ten types of CDs—both new and used of each of jazz, opera, pop, rap, and soul. The store is having a sale on some of these types of CDs. The following conditions must apply: Used pop is on sale; new opera is not. If both types of pop are on sale, then all soul is. If both types of jazz are on sale, then no rap is. If neither type of jazz is on sale, then new pop is. If either type of rap is on sale, then no soul is.",
    "question": "Which one of the following CANNOT be true?",
    "answer": "D",
    "options": [
      "A) Neither type of opera and neither type of rap is on sale.",
      "B) Neither type of jazz and neither type of opera is on sale.",
      "C) Neither type of opera and neither type of soul is on sale.",
      "D) Neither type of jazz and neither type of soul is on sale.",
      "E) Neither type of jazz and neither type of rap is on sale."
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each problem:\n\n**Problem 1: Vladimir and Wendy's meals**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2: Technicians and machines**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs"
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_2_11",
    "context": "A music store carries exactly ten types of CDs—both new and used of each of jazz, opera, pop, rap, and soul. The store is having a sale on some of these types of CDs. The following conditions must apply: Used pop is on sale; new opera is not. If both types of pop are on sale, then all soul is. If both types of jazz are on sale, then no rap is. If neither type of jazz is on sale, then new pop is. If either type of rap is on sale, then no soul is.",
    "question": "If neither type of jazz is on sale, then each of the following must be true EXCEPT:",
    "answer": "A",
    "options": [
      "A) Used opera is on sale.",
      "B) New rap is not on sale.",
      "C) Used rap is not on sale.",
      "D) New soul is on sale.",
      "E) Used soul is on sale."
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each of the problems:\n\n**Problem 1: Vladimir and Wendy's Meals**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2: Technicians and Machines**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m)"
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_2_12",
    "context": "A music store carries exactly ten types of CDs—both new and used of each of jazz, opera, pop, rap, and soul. The store is having a sale on some of these types of CDs. The following conditions must apply: Used pop is on sale; new opera is not. If both types of pop are on sale, then all soul is. If both types of jazz are on sale, then no rap is. If neither type of jazz is on sale, then new pop is. If either type of rap is on sale, then no soul is.",
    "question": "If new soul is the only type of new CD on sale, then which one of the following CANNOT be true?",
    "answer": "A",
    "options": [
      "A) Used jazz is not on sale.",
      "B) Used opera is not on sale.",
      "C) Used rap is not on sale.",
      "D) Used soul is on sale.",
      "E) Used soul is not on sale."
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each problem:\n\n**Problem 1**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat"
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_2_13",
    "context": "A music store carries exactly ten types of CDs—both new and used of each of jazz, opera, pop, rap, and soul. The store is having a sale on some of these types of CDs. The following conditions must apply: Used pop is on sale; new opera is not. If both types of pop are on sale, then all soul is. If both types of jazz are on sale, then no rap is. If neither type of jazz is on sale, then new pop is. If either type of rap is on sale, then no soul is.",
    "question": "If exactly four of the five types of used CDs are the only CDs on sale, then which one of the following could be true?",
    "answer": "C",
    "options": [
      "A) Used jazz is not on sale.",
      "B) Used opera is not on sale.",
      "C) Used rap is not on sale.",
      "D) Neither type of jazz is on sale.",
      "E) Neither type of rap and neither type of soul is on sale."
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each problem:\n\n**Problem 1: Vladimir and Wendy's Meals**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2: Repair Facility**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena"
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_3_14",
    "context": "During a single week, from Monday through Friday, tours will be conducted of a company's three divisions—Operations, Production, and Sales. Exactly five tours will be conducted that week, one each day. The schedule of tours for the week must conform to the following restrictions: Each division is toured at least once. The Operations division is not toured on Monday. The Production division is not toured on Wednesday. The Sales division is toured on two consecutive days, and on no other days. If the Operations division is toured on Thursday, then the Production division is toured on Friday.",
    "question": "Which one of the following CANNOT be true of the week's tour schedule?",
    "answer": "C",
    "options": [
      "A) The division that is toured on Monday is also toured on Tuesday.",
      "B) The division that is toured on Monday is also toured on Friday.",
      "C) The division that is toured on Tuesday is also toured on Thursday.",
      "D) The division that is toured on Wednesday is also toured on Friday.",
      "E) The division that is toured on Thursday is also toured on Friday."
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each problem:\n\n**Problem 1: Vladimir and Wendy's Meals**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2: Repair Facility**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena"
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_3_15",
    "context": "During a single week, from Monday through Friday, tours will be conducted of a company's three divisions—Operations, Production, and Sales. Exactly five tours will be conducted that week, one each day. The schedule of tours for the week must conform to the following restrictions: Each division is toured at least once. The Operations division is not toured on Monday. The Production division is not toured on Wednesday. The Sales division is toured on two consecutive days, and on no other days. If the Operations division is toured on Thursday, then the Production division is toured on Friday.",
    "question": "If in addition to the Sales division one other division is toured on two consecutive days, then it could be true of the week's tour schedule both that the",
    "answer": "B",
    "options": [
      "A) Production division is toured on Monday and that the Operations division is toured on Thursday",
      "B) Production division is toured on Tuesday and that the Sales division is toured on Wednesday",
      "C) Operations division is toured on Tuesday and that the Production division is toured on Friday",
      "D) Sales division is toured on Monday and that the Operations division is toured on Friday",
      "E) Sales division is toured on Wednesday and that the Production division is toured on Friday"
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each problem:\n\n**Problem 1: Vladimir and Wendy's Meals**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2: Technicians and Machines**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs"
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_3_16",
    "context": "During a single week, from Monday through Friday, tours will be conducted of a company's three divisions—Operations, Production, and Sales. Exactly five tours will be conducted that week, one each day. The schedule of tours for the week must conform to the following restrictions: Each division is toured at least once. The Operations division is not toured on Monday. The Production division is not toured on Wednesday. The Sales division is toured on two consecutive days, and on no other days. If the Operations division is toured on Thursday, then the Production division is toured on Friday.",
    "question": "If in the week's tour schedule the division that is toured on Tuesday is also toured on Friday, then for which one of the following days must a tour of the Production division be scheduled?",
    "answer": "A",
    "options": [
      "A) Monday",
      "B) Tuesday",
      "C) Wednesday",
      "D) Thursday",
      "E) Friday"
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each problem:\n\n**Problem 1: Vladimir and Wendy's Meals**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2: Technicians and Machines**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs"
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_3_17",
    "context": "During a single week, from Monday through Friday, tours will be conducted of a company's three divisions—Operations, Production, and Sales. Exactly five tours will be conducted that week, one each day. The schedule of tours for the week must conform to the following restrictions: Each division is toured at least once. The Operations division is not toured on Monday. The Production division is not toured on Wednesday. The Sales division is toured on two consecutive days, and on no other days. If the Operations division is toured on Thursday, then the Production division is toured on Friday.",
    "question": "If in the week's tour schedule the division that is toured on Monday is not the division that is toured on Tuesday, then which one of the following could be true of the week's schedule?",
    "answer": "E",
    "options": [
      "A) A tour of the Sales division is scheduled for some day earlier in the week than is any tour of the Production division.",
      "B) A tour of the Operations division is scheduled for some day earlier in the week than is any tour of the Production division.",
      "C) The Sales division is toured on Monday.",
      "D) The Production division is toured on Tuesday.",
      "E) The Operations division is toured on Wednesday."
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each problem:\n\n**Problem 1: Vladimir and Wendy's Meals**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2: Technicians and Machines**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs"
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_3_18",
    "context": "During a single week, from Monday through Friday, tours will be conducted of a company's three divisions—Operations, Production, and Sales. Exactly five tours will be conducted that week, one each day. The schedule of tours for the week must conform to the following restrictions: Each division is toured at least once. The Operations division is not toured on Monday. The Production division is not toured on Wednesday. The Sales division is toured on two consecutive days, and on no other days. If the Operations division is toured on Thursday, then the Production division is toured on Friday.",
    "question": "If in the week's tour schedule the division that is toured on Tuesday is also toured on Wednesday, then which one of the following must be true of the week's tour schedule?",
    "answer": "A",
    "options": [
      "A) The Production division is toured on Monday.",
      "B) The Operations division is toured on Tuesday.",
      "C) The Sales division is toured on Wednesday.",
      "D) The Sales division is toured on Thursday.",
      "E) The Production division is toured on Friday."
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each problem:\n\n**Problem 1: Vladimir and Wendy's meals**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2: Technicians and machines**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs"
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_4_19",
    "context": "A crew of up to five workers is to install a partition in at most three days. The crew completes five tasks in this order: framing, wallboarding, taping, sanding, priming. The crew is selected from the following list, which specifies exactly the tasks each person can do: George: taping Helena: sanding, priming Inga: framing, priming Kelly: framing, sanding Leanda: wallboarding, taping Maricita: sanding Olaf: wallboarding, priming The following conditions must apply: At least one task is done each day. Taping and priming are done on different days. Each crew member does at least one task during the installation, but no more than one task a day. Each task is done by exactly one worker, completed the day it is started and before the next task begins.",
    "question": "Which one of the following could be a complete and accurate list of the members of the crew?",
    "answer": "B",
    "options": [
      "A) George, Helena, Inga, Kelly",
      "B) George, Helena, Kelly, Leanda",
      "C) Helena, Inga, Kelly, Olaf",
      "D) Helena, Inga, Maricita, Olaf",
      "E) George, Helena, Leanda, Maricita, Olaf"
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each problem:\n\n**Problem 1: Vladimir and Wendy's meals**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2: Technicians and machines**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs"
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_4_20",
    "context": "A crew of up to five workers is to install a partition in at most three days. The crew completes five tasks in this order: framing, wallboarding, taping, sanding, priming. The crew is selected from the following list, which specifies exactly the tasks each person can do: George: taping Helena: sanding, priming Inga: framing, priming Kelly: framing, sanding Leanda: wallboarding, taping Maricita: sanding Olaf: wallboarding, priming The following conditions must apply: At least one task is done each day. Taping and priming are done on different days. Each crew member does at least one task during the installation, but no more than one task a day. Each task is done by exactly one worker, completed the day it is started and before the next task begins.",
    "question": "If the installation takes three days, and if the same two crew members work on the first and third days, then which one of the following could be the pair of crew members who work on those two days?",
    "answer": "D",
    "options": [
      "A) Helena and Inga",
      "B) Inga and Kelly",
      "C) Inga and Leanda",
      "D) Kelly and Olaf",
      "E) Leanda and Olaf"
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each problem:\n\n**Problem 1**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat"
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_4_21",
    "context": "A crew of up to five workers is to install a partition in at most three days. The crew completes five tasks in this order: framing, wallboarding, taping, sanding, priming. The crew is selected from the following list, which specifies exactly the tasks each person can do: George: taping Helena: sanding, priming Inga: framing, priming Kelly: framing, sanding Leanda: wallboarding, taping Maricita: sanding Olaf: wallboarding, priming The following conditions must apply: At least one task is done each day. Taping and priming are done on different days. Each crew member does at least one task during the installation, but no more than one task a day. Each task is done by exactly one worker, completed the day it is started and before the next task begins.",
    "question": "Each of the following could be a complete and accurate list of the members of the crew EXCEPT:",
    "answer": "A",
    "options": [
      "A) Helena, Inga, Kelly, Maricita",
      "B) Inga, Kelly, Leanda, Olaf",
      "C) George, Helena, Inga, Leanda",
      "D) Inga, Leanda, Maricita, Olaf",
      "E) Kelly, Leanda, Maricita, Olaf"
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each problem:\n\n**Problem 1: Vladimir and Wendy's meals**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2: Repair facility**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena"
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_4_22",
    "context": "A crew of up to five workers is to install a partition in at most three days. The crew completes five tasks in this order: framing, wallboarding, taping, sanding, priming. The crew is selected from the following list, which specifies exactly the tasks each person can do: George: taping Helena: sanding, priming Inga: framing, priming Kelly: framing, sanding Leanda: wallboarding, taping Maricita: sanding Olaf: wallboarding, priming The following conditions must apply: At least one task is done each day. Taping and priming are done on different days. Each crew member does at least one task during the installation, but no more than one task a day. Each task is done by exactly one worker, completed the day it is started and before the next task begins.",
    "question": "If the installation takes three days, and if the sanding is done on the third day, then which one of the following could be a list of all the crew members who work on the second day?",
    "answer": "E",
    "options": [
      "A) Inga",
      "B) Kelly",
      "C) Olaf",
      "D) George and Helena",
      "E) Leanda and Olaf"
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each problem:\n\n**Problem 1: Breakfast and Lunch**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2: Repair Facility**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m"
    ]
  },
  {
    "id": "ar_lsat_200006_1-G_4_23",
    "context": "A crew of up to five workers is to install a partition in at most three days. The crew completes five tasks in this order: framing, wallboarding, taping, sanding, priming. The crew is selected from the following list, which specifies exactly the tasks each person can do: George: taping Helena: sanding, priming Inga: framing, priming Kelly: framing, sanding Leanda: wallboarding, taping Maricita: sanding Olaf: wallboarding, priming The following conditions must apply: At least one task is done each day. Taping and priming are done on different days. Each crew member does at least one task during the installation, but no more than one task a day. Each task is done by exactly one worker, completed the day it is started and before the next task begins.",
    "question": "Which one of the following could be a pair of members of the crew both of whom work on the same days as each other and each of whom perform two tasks?",
    "answer": "D",
    "options": [
      "A) George and Maricita",
      "B) Helena and Kelly",
      "C) Inga and Leanda",
      "D) Kelly and Leanda",
      "E) Leanda and Olaf"
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each problem:\n\n**Problem 1: Vladimir and Wendy's meals**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2: Technicians and machines**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs"
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_1_1",
    "context": "A closet contains exactly six hangers—1, 2, 3, 4, 5, and 6—hanging, in that order, from left to right. It also contains exactly six dresses—one gauze, one linen, one polyester, one rayon, one silk, and one wool—a different dress on each of the hangers, in an order satisfying the following conditions: The gauze dress is on a lower-numbered hanger than the polyester dress. The rayon dress is on hanger 1 or hanger 6. Either the wool dress or the silk dress is on hanger 3. The linen dress hangs immediately to the right of the silk dress.",
    "question": "Which one of the following could be an accurate matching of the hangers to the fabrics of the dresses that hang on them?",
    "answer": "A",
    "options": [
      "A) 1: wool; 2: gauze; 3: silk; 4: linen; 5: polyester; 6: rayon",
      "B) 1: rayon; 2: wool; 3: gauze; 4: silk; 5: linen; 6: polyester",
      "C) 1: polyester; 2: gauze; 3: wool; 4: silk; 5: linen; 6: rayon",
      "D) 1: linen; 2: silk; 3: wool; 4: gauze; 5: polyester; 6: rayon",
      "E) 1: gauze; 2: rayon; 3: silk; 4: linen; 5: wool; 6: polyester"
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each of the problems:\n\n**Problem 1: Vladimir and Wendy's meals**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2: Technicians and machines**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m)"
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_1_2",
    "context": "A closet contains exactly six hangers—1, 2, 3, 4, 5, and 6—hanging, in that order, from left to right. It also contains exactly six dresses—one gauze, one linen, one polyester, one rayon, one silk, and one wool—a different dress on each of the hangers, in an order satisfying the following conditions: The gauze dress is on a lower-numbered hanger than the polyester dress. The rayon dress is on hanger 1 or hanger 6. Either the wool dress or the silk dress is on hanger 3. The linen dress hangs immediately to the right of the silk dress.",
    "question": "If both the silk dress and the gauze dress are on odd-numbered hangers, then which one of the following could be true?",
    "answer": "B",
    "options": [
      "A) The polyester dress is on hanger 1.",
      "B) The wool dress is on hanger 2.",
      "C) The polyester dress is on hanger 4.",
      "D) The linen dress is on hanger 5.",
      "E) The wool dress is on hanger 6."
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each problem:\n\n**Problem 1: Vladimir and Wendy's meals**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2: Technicians and machines**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs"
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_1_3",
    "context": "A closet contains exactly six hangers—1, 2, 3, 4, 5, and 6—hanging, in that order, from left to right. It also contains exactly six dresses—one gauze, one linen, one polyester, one rayon, one silk, and one wool—a different dress on each of the hangers, in an order satisfying the following conditions: The gauze dress is on a lower-numbered hanger than the polyester dress. The rayon dress is on hanger 1 or hanger 6. Either the wool dress or the silk dress is on hanger 3. The linen dress hangs immediately to the right of the silk dress.",
    "question": "If the silk dress is on an even-numbered hanger, which one of the following could be on the hanger immediately to its left?",
    "answer": "E",
    "options": [
      "A) the gauze dress",
      "B) the linen dress",
      "C) the polyester dress",
      "D) the rayon dress",
      "E) the wool dress"
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each problem:\n\n**Problem 1: Vladimir and Wendy's meals**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2: Repair facility**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena"
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_1_4",
    "context": "A closet contains exactly six hangers—1, 2, 3, 4, 5, and 6—hanging, in that order, from left to right. It also contains exactly six dresses—one gauze, one linen, one polyester, one rayon, one silk, and one wool—a different dress on each of the hangers, in an order satisfying the following conditions: The gauze dress is on a lower-numbered hanger than the polyester dress. The rayon dress is on hanger 1 or hanger 6. Either the wool dress or the silk dress is on hanger 3. The linen dress hangs immediately to the right of the silk dress.",
    "question": "If the polyester dress is on hanger 2, then which one of the following must be true?",
    "answer": "E",
    "options": [
      "A) The silk dress is on hanger 1.",
      "B) The wool dress is on hanger 3.",
      "C) The linen dress is on hanger 4.",
      "D) The linen dress is on hanger 5.",
      "E) The rayon dress is on hanger 6."
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each problem:\n\n**Problem 1**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat"
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_1_5",
    "context": "A closet contains exactly six hangers—1, 2, 3, 4, 5, and 6—hanging, in that order, from left to right. It also contains exactly six dresses—one gauze, one linen, one polyester, one rayon, one silk, and one wool—a different dress on each of the hangers, in an order satisfying the following conditions: The gauze dress is on a lower-numbered hanger than the polyester dress. The rayon dress is on hanger 1 or hanger 6. Either the wool dress or the silk dress is on hanger 3. The linen dress hangs immediately to the right of the silk dress.",
    "question": "Which one of the following CANNOT be true?",
    "answer": "B",
    "options": [
      "A) The linen dress hangs immediately next to the gauze dress.",
      "B) The polyester dress hangs immediately to the right of the rayon dress.",
      "C) The rayon dress hangs immediately to the left of the wool dress.",
      "D) The silk dress is on a lower-numbered hanger than the gauze dress.",
      "E) The wool dress is on a higher-numbered hanger than the rayon dress."
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each problem:\n\n**Problem 1: Vladimir and Wendy's meals**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2: Repair facility technicians**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(X"
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_1_6",
    "context": "A closet contains exactly six hangers—1, 2, 3, 4, 5, and 6—hanging, in that order, from left to right. It also contains exactly six dresses—one gauze, one linen, one polyester, one rayon, one silk, and one wool—a different dress on each of the hangers, in an order satisfying the following conditions: The gauze dress is on a lower-numbered hanger than the polyester dress. The rayon dress is on hanger 1 or hanger 6. Either the wool dress or the silk dress is on hanger 3. The linen dress hangs immediately to the right of the silk dress.",
    "question": "Which one of the following CANNOT hang immediately next to the rayon dress?",
    "answer": "D",
    "options": [
      "A) the gauze dress",
      "B) the linen dress",
      "C) the polyester dress",
      "D) the silk dress",
      "E) the wool dress"
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each problem:\n\n**Problem 1: Vladimir and Wendy's meals**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2: Repair facility**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena"
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_1_7",
    "context": "A closet contains exactly six hangers—1, 2, 3, 4, 5, and 6—hanging, in that order, from left to right. It also contains exactly six dresses—one gauze, one linen, one polyester, one rayon, one silk, and one wool—a different dress on each of the hangers, in an order satisfying the following conditions: The gauze dress is on a lower-numbered hanger than the polyester dress. The rayon dress is on hanger 1 or hanger 6. Either the wool dress or the silk dress is on hanger 3. The linen dress hangs immediately to the right of the silk dress.",
    "question": "Assume that the original condition that the linen dress hangs immediately to the right of the silk dress is replaced by the condition that the wool dress hangs immediately to the right of the silk dress. If all the other initial conditions remain in effect, which one of the following must be false?",
    "answer": "D",
    "options": [
      "A) The linen dress is on hanger 1.",
      "B) The gauze dress is on hanger 2.",
      "C) The wool dress is on hanger 4.",
      "D) The silk dress is on hanger 5.",
      "E) The polyester dress is on hanger 6."
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each problem:\n\n**Problem 1: Vladimir and Wendy's Meals**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2: Repair Facility**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena"
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_2_8",
    "context": "At a children's festival, exactly four songs are performed, each exactly once: \"Night's All Right,\" \"Question Man,\" \"Rhino Rock,\" and \"Sammy.\" The songs are performed consecutively, each on a different one of exactly four instruments: flute, guitar, harmonica, or keyboard. The songs are performed in accordance with the following: The first song performed is not performed on the flute. If \"Sammy\" is performed on the keyboard, then \"Rhino Rock\" is performed on the harmonica. If \"Question Man\" is performed on the keyboard, then \"Night's All Right\" is performed on the flute. The song performed on the keyboard immediately follows \"Rhino Rock\" and immediately precedes \"Night's All Right.\"",
    "question": "Which one of the following could be an accurate matching of the four songs performed at the festival with the instruments on which they are performed, listed in order from the first song performed to the last?",
    "answer": "B",
    "options": [
      "A) \"Night's All Right\": guitar;\" Question Man\": keyboard; \"Sammy\": guitar;\" Rhino Rock\": flute",
      "B) \"Question Man\": guitar;\" Rhino Rock\": harmonica; \"Sammy\": keyboard;\" Night's All Right\": flute",
      "C) \"Rhino Rock\": flute;\" Question Man\": keyboard; \"Night's All Right\": harmonica;\" Sammy\": guitar",
      "D) \"Sammy\": harmonica;\" Night's All Right\": guitar; \"Question Man\": keyboard;\" Rhino Rock\": flute",
      "E) \"Sammy\": harmonica;\" Rhino Rock\": guitar; \"Question Man\": flute;\" Night's All Right\": keyboard"
    ],
    "raw_logic_programs": [
      "Here are the logic programs for the three problems:\n\n**Problem 1: Vladimir and Wendy's meals**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2: Technicians and machines**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) =="
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_2_9",
    "context": "At a children's festival, exactly four songs are performed, each exactly once: \"Night's All Right,\" \"Question Man,\" \"Rhino Rock,\" and \"Sammy.\" The songs are performed consecutively, each on a different one of exactly four instruments: flute, guitar, harmonica, or keyboard. The songs are performed in accordance with the following: The first song performed is not performed on the flute. If \"Sammy\" is performed on the keyboard, then \"Rhino Rock\" is performed on the harmonica. If \"Question Man\" is performed on the keyboard, then \"Night's All Right\" is performed on the flute. The song performed on the keyboard immediately follows \"Rhino Rock\" and immediately precedes \"Night's All Right.\"",
    "question": "Which one of the following could be true?",
    "answer": "E",
    "options": [
      "A) \"Question Man\" immediately follows the song performed on the keyboard.",
      "B) \"Night's All Right\" immediately precedes the song performed on the keyboard.",
      "C) \"Question Man\" immediately precedes the song performed on the guitar.",
      "D) \"Rhino Rock\" immediately precedes the song performed on the harmonica.",
      "E) \"Sammy\" immediately precedes the song performed on the guitar."
    ],
    "raw_logic_programs": [
      "Here are the logic programs for the three problems:\n\n**Problem 1: Vladimir and Wendy's Meals**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2: Technicians and Machines**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) =="
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_2_10",
    "context": "At a children's festival, exactly four songs are performed, each exactly once: \"Night's All Right,\" \"Question Man,\" \"Rhino Rock,\" and \"Sammy.\" The songs are performed consecutively, each on a different one of exactly four instruments: flute, guitar, harmonica, or keyboard. The songs are performed in accordance with the following: The first song performed is not performed on the flute. If \"Sammy\" is performed on the keyboard, then \"Rhino Rock\" is performed on the harmonica. If \"Question Man\" is performed on the keyboard, then \"Night's All Right\" is performed on the flute. The song performed on the keyboard immediately follows \"Rhino Rock\" and immediately precedes \"Night's All Right.\"",
    "question": "Which one of the following CANNOT be true of the song performed on the flute?",
    "answer": "C",
    "options": [
      "A) It immediately precedes \"Question Man.\"",
      "B) It immediately follows \"Question Man.\"",
      "C) It immediately precedes \"Rhino Rock.\"",
      "D) It immediately follows \"Night's All Right.\"",
      "E) It immediately follows \"Sammy.\""
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each problem:\n\n**Problem 1: Vladimir and Wendy's Meals**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2: Repair Facility**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena"
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_2_11",
    "context": "At a children's festival, exactly four songs are performed, each exactly once: \"Night's All Right,\" \"Question Man,\" \"Rhino Rock,\" and \"Sammy.\" The songs are performed consecutively, each on a different one of exactly four instruments: flute, guitar, harmonica, or keyboard. The songs are performed in accordance with the following: The first song performed is not performed on the flute. If \"Sammy\" is performed on the keyboard, then \"Rhino Rock\" is performed on the harmonica. If \"Question Man\" is performed on the keyboard, then \"Night's All Right\" is performed on the flute. The song performed on the keyboard immediately follows \"Rhino Rock\" and immediately precedes \"Night's All Right.\"",
    "question": "If \"Rhino Rock\" is the second song performed at the festival, then which one of the following could be true?",
    "answer": "E",
    "options": [
      "A) The first song performed is performed on the keyboard.",
      "B) The third song performed is performed on the guitar.",
      "C) The third song performed is performed on the flute.",
      "D) \"Night's All Right\" is performed on the guitar.",
      "E) \"Rhino Rock\" is performed on the guitar."
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each of the problems:\n\n**Problem 1: Vladimir and Wendy's meals**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2: Technicians and machines**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m)"
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_2_12",
    "context": "At a children's festival, exactly four songs are performed, each exactly once: \"Night's All Right,\" \"Question Man,\" \"Rhino Rock,\" and \"Sammy.\" The songs are performed consecutively, each on a different one of exactly four instruments: flute, guitar, harmonica, or keyboard. The songs are performed in accordance with the following: The first song performed is not performed on the flute. If \"Sammy\" is performed on the keyboard, then \"Rhino Rock\" is performed on the harmonica. If \"Question Man\" is performed on the keyboard, then \"Night's All Right\" is performed on the flute. The song performed on the keyboard immediately follows \"Rhino Rock\" and immediately precedes \"Night's All Right.\"",
    "question": "If \"Question Man\" is the third song performed at the festival, then each of the following could be true EXCEPT:",
    "answer": "A",
    "options": [
      "A) \"Question Man\" is performed on the guitar.",
      "B) \"Question Man\" is performed on the keyboard.",
      "C) \"Rhino Rock\" is performed on the guitar.",
      "D) \"Sammy\" is performed on the guitar.",
      "E) \"Sammy\" is performed on the harmonica."
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each problem:\n\n**Problem 1**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat"
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_3_13",
    "context": "Each of the seven members of the board of directors—Guzman, Hawking, Lepp, Miyauchi, Upchurch, Wharton, and Zhu—serves on exactly one of two committees—the finance committee or the incentives committee. Only board members serve on these committees. Committee membership is consistent with the following conditions: If Guzman serves on the finance committee, then Hawking serves on the incentives committee. If Lepp serves on the finance committee, then Miyauchi and Upchurch both serve on the incentives committee. Wharton serves on a different committee from the one on which Zhu serves. Upchurch serves on a different committee from the one on which Guzman serves. If Zhu serves on the finance committee, so does Hawking.",
    "question": "Which one of the following could be a complete and accurate list of the members of the finance committee?",
    "answer": "E",
    "options": [
      "A) Guzman, Hawking, Miyauchi, Wharton",
      "B) Guzman, Lepp, Zhu",
      "C) Hawking, Miyauchi, Zhu",
      "D) Hawking, Upchurch, Wharton, Zhu",
      "E) Miyauchi, Upchurch, Wharton"
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each problem:\n\n**Problem 1: Vladimir and Wendy's meals**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2: Repair facility**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena"
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_3_14",
    "context": "Each of the seven members of the board of directors—Guzman, Hawking, Lepp, Miyauchi, Upchurch, Wharton, and Zhu—serves on exactly one of two committees—the finance committee or the incentives committee. Only board members serve on these committees. Committee membership is consistent with the following conditions: If Guzman serves on the finance committee, then Hawking serves on the incentives committee. If Lepp serves on the finance committee, then Miyauchi and Upchurch both serve on the incentives committee. Wharton serves on a different committee from the one on which Zhu serves. Upchurch serves on a different committee from the one on which Guzman serves. If Zhu serves on the finance committee, so does Hawking.",
    "question": "Which one of the following pairs of board members CANNOT both serve on the incentives committee?",
    "answer": "C",
    "options": [
      "A) Guzman and Hawking",
      "B) Guzman and Wharton",
      "C) Hawking and Wharton",
      "D) Miyauchi and Upchurch",
      "E) Miyauchi and Wharton"
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each of the problems:\n\n**Problem 1: Vladimir and Wendy's meals**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2: Technicians and machines**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m)"
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_3_15",
    "context": "Each of the seven members of the board of directors—Guzman, Hawking, Lepp, Miyauchi, Upchurch, Wharton, and Zhu—serves on exactly one of two committees—the finance committee or the incentives committee. Only board members serve on these committees. Committee membership is consistent with the following conditions: If Guzman serves on the finance committee, then Hawking serves on the incentives committee. If Lepp serves on the finance committee, then Miyauchi and Upchurch both serve on the incentives committee. Wharton serves on a different committee from the one on which Zhu serves. Upchurch serves on a different committee from the one on which Guzman serves. If Zhu serves on the finance committee, so does Hawking.",
    "question": "What is the maximum number of members on the finance committee?",
    "answer": "C",
    "options": [
      "A) two",
      "B) three",
      "C) four",
      "D) five",
      "E) six"
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each problem:\n\n**Problem 1**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\nis_sat"
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_3_16",
    "context": "Each of the seven members of the board of directors—Guzman, Hawking, Lepp, Miyauchi, Upchurch, Wharton, and Zhu—serves on exactly one of two committees—the finance committee or the incentives committee. Only board members serve on these committees. Committee membership is consistent with the following conditions: If Guzman serves on the finance committee, then Hawking serves on the incentives committee. If Lepp serves on the finance committee, then Miyauchi and Upchurch both serve on the incentives committee. Wharton serves on a different committee from the one on which Zhu serves. Upchurch serves on a different committee from the one on which Guzman serves. If Zhu serves on the finance committee, so does Hawking.",
    "question": "If Miyauchi and Wharton both serve on the finance committee, then which one of the following could be true?",
    "answer": "D",
    "options": [
      "A) Guzman and Lepp both serve on the finance committee.",
      "B) Guzman and Upchurch both serve on the incentives committee.",
      "C) Hawking and Zhu both serve on the finance committee.",
      "D) Lepp and Upchurch both serve on the incentives committee.",
      "E) Zhu and Upchurch both serve on the finance committee."
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each problem:\n\n**Problem 1: Breakfast and Lunch**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2: Repair Facility**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m"
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_3_17",
    "context": "Each of the seven members of the board of directors—Guzman, Hawking, Lepp, Miyauchi, Upchurch, Wharton, and Zhu—serves on exactly one of two committees—the finance committee or the incentives committee. Only board members serve on these committees. Committee membership is consistent with the following conditions: If Guzman serves on the finance committee, then Hawking serves on the incentives committee. If Lepp serves on the finance committee, then Miyauchi and Upchurch both serve on the incentives committee. Wharton serves on a different committee from the one on which Zhu serves. Upchurch serves on a different committee from the one on which Guzman serves. If Zhu serves on the finance committee, so does Hawking.",
    "question": "If Guzman serves on the incentives committee, then which one of the following must be true?",
    "answer": "B",
    "options": [
      "A) Hawking serves on the finance committee.",
      "B) Lepp serves on the incentives committee.",
      "C) Miyauchi serves on the finance committee.",
      "D) Wharton serves on the incentives committee.",
      "E) Zhu serves on the finance committee."
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each of the problems:\n\n**Problem 1: Vladimir and Wendy's meals**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2: Repair facility**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs"
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_4_18",
    "context": "Eight people—Fiona, George, Harriet, Ingrid, Karl, Manuel, Olivia, and Peter—are sitting, evenly spaced, around a circular picnic table. Any two of them are said to be sitting directly across from one another if and only if there are exactly three other people sitting between them, counting in either direction around the table. The following conditions apply: Fiona sits directly across from George. Harriet sits immediately next to neither Fiona nor Karl. Ingrid sits immediately next to, and immediately clockwise from, Olivia.",
    "question": "Which one of the following could be the order in which four of the people are seated, with no one else seated between them, counting clockwise around the table?",
    "answer": "C",
    "options": [
      "A) George, Peter, Karl, Fiona",
      "B) Harriet, Olivia, Ingrid, Karl",
      "C) Ingrid, Fiona, Peter, Manuel",
      "D) Olivia, Manuel, Karl, George",
      "E) Peter, Harriet, Karl, Fiona"
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each of the problems:\n\n**Problem 1: Vladimir and Wendy's meals**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2: Technicians and machines**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m)"
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_4_19",
    "context": "Eight people—Fiona, George, Harriet, Ingrid, Karl, Manuel, Olivia, and Peter—are sitting, evenly spaced, around a circular picnic table. Any two of them are said to be sitting directly across from one another if and only if there are exactly three other people sitting between them, counting in either direction around the table. The following conditions apply: Fiona sits directly across from George. Harriet sits immediately next to neither Fiona nor Karl. Ingrid sits immediately next to, and immediately clockwise from, Olivia.",
    "question": "If Harriet and Olivia each sits immediately next to George, then which one of the following could be the two people each of whom sits immediately next to Peter?",
    "answer": "D",
    "options": [
      "A) Fiona and Karl",
      "B) Fiona and Olivia",
      "C) Harriet and Ingrid",
      "D) Harriet and Karl",
      "E) Karl and Manuel"
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each problem:\n\n**Problem 1: Vladimir and Wendy's meals**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2: Repair facility**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena"
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_4_20",
    "context": "Eight people—Fiona, George, Harriet, Ingrid, Karl, Manuel, Olivia, and Peter—are sitting, evenly spaced, around a circular picnic table. Any two of them are said to be sitting directly across from one another if and only if there are exactly three other people sitting between them, counting in either direction around the table. The following conditions apply: Fiona sits directly across from George. Harriet sits immediately next to neither Fiona nor Karl. Ingrid sits immediately next to, and immediately clockwise from, Olivia.",
    "question": "If George does not sit immediately next to Harriet, then which one of the following could be the two people each of whom sits immediately next to Manuel?",
    "answer": "A",
    "options": [
      "A) Fiona and Harriet",
      "B) Fiona and Peter",
      "C) George and Karl",
      "D) George and Peter",
      "E) Harriet and Peter"
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each problem:\n\n**Problem 1: Vladimir and Wendy's Meals**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2: Repair Facility**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena"
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_4_21",
    "context": "Eight people—Fiona, George, Harriet, Ingrid, Karl, Manuel, Olivia, and Peter—are sitting, evenly spaced, around a circular picnic table. Any two of them are said to be sitting directly across from one another if and only if there are exactly three other people sitting between them, counting in either direction around the table. The following conditions apply: Fiona sits directly across from George. Harriet sits immediately next to neither Fiona nor Karl. Ingrid sits immediately next to, and immediately clockwise from, Olivia.",
    "question": "If Manuel sits immediately next to Olivia, then which one of the following people must sit immediately next to Fiona?",
    "answer": "C",
    "options": [
      "A) Harriet",
      "B) Ingrid",
      "C) Karl",
      "D) Manuel",
      "E) Peter"
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each of the problems:\n\n**Problem 1**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) ::: (C)\n"
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_4_22",
    "context": "Eight people—Fiona, George, Harriet, Ingrid, Karl, Manuel, Olivia, and Peter—are sitting, evenly spaced, around a circular picnic table. Any two of them are said to be sitting directly across from one another if and only if there are exactly three other people sitting between them, counting in either direction around the table. The following conditions apply: Fiona sits directly across from George. Harriet sits immediately next to neither Fiona nor Karl. Ingrid sits immediately next to, and immediately clockwise from, Olivia.",
    "question": "What is the minimum possible number of people sitting between Ingrid and Manuel, counting clockwise from Ingrid around the table?",
    "answer": "A",
    "options": [
      "A) zero",
      "B) one",
      "C) two",
      "D) three",
      "E) four"
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each of the problems:\n\n**Problem 1: Vladimir and Wendy's Meals**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2: Technicians and Machines**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m)"
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_4_23",
    "context": "Eight people—Fiona, George, Harriet, Ingrid, Karl, Manuel, Olivia, and Peter—are sitting, evenly spaced, around a circular picnic table. Any two of them are said to be sitting directly across from one another if and only if there are exactly three other people sitting between them, counting in either direction around the table. The following conditions apply: Fiona sits directly across from George. Harriet sits immediately next to neither Fiona nor Karl. Ingrid sits immediately next to, and immediately clockwise from, Olivia.",
    "question": "If Karl sits directly across from Ingrid, then each of the following people could sit immediately next to Olivia EXCEPT:",
    "answer": "B",
    "options": [
      "A) Fiona",
      "B) George",
      "C) Harriet",
      "D) Manuel",
      "E) Peter"
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each of the given problems:\n\n**Problem 1:**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2:**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena, m))) :::"
    ]
  },
  {
    "id": "ar_lsat_200310_2-G_4_24",
    "context": "Eight people—Fiona, George, Harriet, Ingrid, Karl, Manuel, Olivia, and Peter—are sitting, evenly spaced, around a circular picnic table. Any two of them are said to be sitting directly across from one another if and only if there are exactly three other people sitting between them, counting in either direction around the table. The following conditions apply: Fiona sits directly across from George. Harriet sits immediately next to neither Fiona nor Karl. Ingrid sits immediately next to, and immediately clockwise from, Olivia.",
    "question": "If Karl sits directly across from Harriet, then what is the minimum possible number of people sitting between George and Karl, counting clockwise from George to Karl?",
    "answer": "C",
    "options": [
      "A) zero",
      "B) one",
      "C) two",
      "D) three",
      "E) four"
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each problem:\n\n**Problem 1: Vladimir and Wendy's meals**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2: Repair facility**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Xena"
    ]
  },
  {
    "id": "ar_lsat_201106_2-G_1_1",
    "context": "Each of seven candidates for the position of judge—Hamadi, Jefferson, Kurtz, Li, McDonnell, Ortiz, and Perkins—will be appointed to an open position on one of two courts—the appellate court or the trial court. There are three open positions on the appellate court and six open positions on the trial court, but not all of them will be filled at this time. The judicial appointments will conform to the following conditions: Li must be appointed to the appellate court. Kurtz must be appointed to the trial court. Hamadi cannot be appointed to the same court as Perkins.",
    "question": "Which one of the following is an acceptable set of appointments of candidates to courts?",
    "answer": "E",
    "options": [
      "A) appellate: Hamadi, Ortiz trial: Jefferson, Kurtz, Li, McDonnell, Perkins",
      "B) appellate: Hamadi, Li, Perkins trial: Jefferson, Kurtz, McDonnell, Ortiz",
      "C) appellate: Kurtz, Li, Perkins trial: Hamadi, Jefferson, McDonnell, Ortiz",
      "D) appellate: Li, McDonnell, Ortiz trial: Hamadi, Jefferson, Kurtz, Perkins",
      "E) appellate: Li, Perkins trial: Hamadi, Jefferson, Kurtz, McDonnell, Ortiz"
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each of the problems:\n\n**Problem 1: Vladimir and Wendy's Meals**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2: Repair Facility**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs"
    ]
  },
  {
    "id": "ar_lsat_201106_2-G_1_2",
    "context": "Each of seven candidates for the position of judge—Hamadi, Jefferson, Kurtz, Li, McDonnell, Ortiz, and Perkins—will be appointed to an open position on one of two courts—the appellate court or the trial court. There are three open positions on the appellate court and six open positions on the trial court, but not all of them will be filled at this time. The judicial appointments will conform to the following conditions: Li must be appointed to the appellate court. Kurtz must be appointed to the trial court. Hamadi cannot be appointed to the same court as Perkins.",
    "question": "Which one of the following CANNOT be true?",
    "answer": "B",
    "options": [
      "A) Hamadi and McDonnell are both appointed to the appellate court.",
      "B) McDonnell and Ortiz are both appointed to the appellate court.",
      "C) Ortiz and Perkins are both appointed to the appellate court.",
      "D) Hamadi and Jefferson are both appointed to the trial court.",
      "E) Ortiz and Perkins are both appointed to the trial court."
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each problem:\n\n**Problem 1: Vladimir and Wendy's meals**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2: Technicians and machines**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs"
    ]
  },
  {
    "id": "ar_lsat_201106_2-G_1_3",
    "context": "Each of seven candidates for the position of judge—Hamadi, Jefferson, Kurtz, Li, McDonnell, Ortiz, and Perkins—will be appointed to an open position on one of two courts—the appellate court or the trial court. There are three open positions on the appellate court and six open positions on the trial court, but not all of them will be filled at this time. The judicial appointments will conform to the following conditions: Li must be appointed to the appellate court. Kurtz must be appointed to the trial court. Hamadi cannot be appointed to the same court as Perkins.",
    "question": "Which one of the following CANNOT be true?",
    "answer": "A",
    "options": [
      "A) Jefferson and McDonnell are both appointed to the appellate court.",
      "B) Jefferson and McDonnell are both appointed to the trial court.",
      "C) McDonnell and Ortiz are both appointed to the trial court.",
      "D) McDonnell and Perkins are both appointed to the appellate court.",
      "E) McDonnell and Perkins are both appointed to the trial court."
    ],
    "raw_logic_programs": [
      "Here are the logic programs for each problem:\n\n**Problem 1: Vladimir and Wendy's Meals**\n\n# Declarations\npeople = EnumSort([Vladimir, Wendy])\nmeals = EnumSort([breakfast, lunch, dinner, snack])\nfoods = EnumSort([fish, hot_cakes, macaroni, omelet, poached_eggs])\neats = Function([people, meals] -> [foods])\n\n# Constraints\nForAll([m:meals], eats(Vladimir, m)!= eats(Wendy, m)) ::: At no meal does Vladimir eat the same kind of food as Wendy\nForAll([p:people, f:foods], Count([m:meals], eats(p, m) == f) <= 1) ::: Neither of them eats the same kind of food more than once during the day\nForAll([p:people], Or(eats(p, breakfast) == hot_cakes, eats(p, breakfast) == poached_eggs, eats(p, breakfast) == omelet)) ::: For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet\nForAll([p:people], Or(eats(p, lunch) == fish, eats(p, lunch) == hot_cakes, eats(p, lunch) == macaroni, eats(p, lunch) == omelet)) ::: For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, dinner) == fish, eats(p, dinner) == hot_cakes, eats(p, dinner) == macaroni, eats(p, dinner) == omelet)) ::: For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet\nForAll([p:people], Or(eats(p, snack) == fish, eats(p, snack) == omelet)) ::: For a snack, each eats exactly one of the following: fish or omelet\neats(Wendy, lunch) == omelet ::: Wendy eats an omelet for lunch\n\n# Options\nQuestion ::: Vladimir must eat which one of the following foods?\nis_valid(Exists([m:meals], eats(Vladimir, m) == fish)) ::: (A)\nis_valid(Exists([m:meals], eats(Vladimir, m) == hot_cakes)) ::: (B)\nis_valid(Exists([m:meals], eats(Vladimir, m) == macaroni)) ::: (C)\nis_valid(Exists([m:meals], eats(Vladimir, m) == omelet)) ::: (D)\nis_valid(Exists([m:meals], eats(Vladimir, m) == poached_eggs)) ::: (E)\n\n**Problem 2: Technicians and Machines**\n\n# Declarations\ntechnicians = EnumSort([Stacy, Urma, Wim, Xena, Yolanda, Zane])\nmachines = EnumSort([radios, televisions, VCRs])\nrepairs = Function([technicians, machines] -> [bool])\n\n# Constraints\nForAll([t:technicians], Count([m:machines], repairs(t, m)) >= 1) ::: each technician repairs machines of at least one of the following three types\nAnd(repairs(Xena, radios), Count([t:technicians], And(t!= Xena, repairs(t, radios))) == 3) ::: Xena and exactly three other technicians repair radios\nAnd(repairs(Yolanda, televisions), repairs(Yolanda, VCRs)) ::: Yolanda repairs both televisions and VCRs\nForAll([m:machines], Implies(repairs(Yolanda, m), Not(repairs(Stacy, m)))) ::: Stacy does not repair any type of machine that Yolanda repairs\nCount([m:machines], repairs(Zane, m)) > Count([m:machines], repairs(Yolanda, m)) ::: Zane repairs more types of machines than Yolanda repairs\nForAll([m:machines], Implies(repairs(Stacy, m), Not(repairs(Wim, m)))) ::: Wim does not repair any type of machine that Stacy repairs\nCount([m:machines], repairs(Urma, m)) == 2 ::: Urma repairs exactly two types of machines\n\n# Options\nQuestion ::: Which one of the following pairs of technicians could repair all and only the same types of machines as each other?\nis_sat(ForAll([m:machines], repairs(Stacy, m) == repairs(Urma, m))) ::: (A)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs(Yolanda, m))) ::: (B)\nis_sat(ForAll([m:machines], repairs(Urma, m) == repairs"
    ]
  }
]