[
  {
    "id": "ar_lsat_200010_3-G_1_1",
    "context": "Of the eight students—George, Helen, Irving, Kyle, Lenore, Nina, Olivia, and Robert—in a seminar, exactly six will give individual oral reports during three consecutive days—Monday, Tuesday, and Wednesday. Exactly two reports will be given each day—one in the morning and one in the afternoon—according to the following conditions: Tuesday is the only day on which George can give a report. Neither Olivia nor Robert can give an afternoon report. If Nina gives a report, then on the next day Helen and Irving must both give reports, unless Nina's report is given on Wednesday.",
    "question": "Which one of the following could be the schedule of the students' reports?",
    "answer": "C",
    "options": [
      "A) Mon. morning: Helen; Mon. afternoon: Robert Tues. morning: Olivia; Tues. afternoon: Irving Wed. morning: Lenore; Wed. afternoon: Kyle",
      "B) Mon. morning: Irving; Mon. afternoon: Olivia Tues. morning: Helen; Tues. afternoon: Kyle Wed. morning: Nina; Wed. afternoon: Lenore",
      "C) Mon. morning: Lenore; Mon. afternoon: Helen Tues. morning: George; Tues. afternoon: Kyle Wed. morning: Robert; Wed. afternoon: Irving",
      "D) Mon. morning: Nina; Mon. afternoon: Helen Tues. morning: Robert; Tues. afternoon: Irving Wed. morning: Olivia; Wed. afternoon: Lenore",
      "E) Mon. morning: Olivia; Mon. afternoon: Nina Tues. morning: Irving; Tues. afternoon: Helen Wed. morning: Kyle; Wed. afternoon: George"
    ],
    "raw_logic_programs": [
      "# Declarations\nstudents = EnumSort([George, Helen, Irving, Kyle, Lenore, Nina, Olivia, Robert])\ndays = EnumSort([Monday, Tuesday, Wednesday])\ntimes = EnumSort([morning, afternoon])\ngives_report = Function([students, days, times] -> [bool])\n\n# Constraints\nCount([s:students, d:days, t:times], gives_report(s, d, t)) == 6 ::: exactly six students will give reports\nForAll([d:days], Count([s:students, t:times], gives_report(s, d, t)) == 2) ::: exactly two reports will be given each day\nForAll([s:students, t:times], Implies(gives_report(s, Tuesday, t), s == George)) ::: Tuesday is the only day on which George can give a report\nForAll([s:students], Not(gives_report(Olivia, s, afternoon))) ::: Olivia cannot give an afternoon report\nForAll([s:students], Not(gives_report(Robert, s, afternoon))) ::: Robert cannot give an afternoon report\nForAll([d:days], Implies(And(gives_report(Nina, d, t), d != Wednesday), And(gives_report(Helen, d + 1, t), gives_report(Irving, d + 1, t)))) ::: If Nina gives a report, then on the next day Helen and Irving must both give reports, unless Nina's report is given on Wednesday\n\n# Options\nQuestion ::: Which one of the following could be the schedule of the students' reports?\nis_sat(And(gives_report(Helen, Monday, morning), gives_report(Robert, Monday, afternoon), gives_report(Olivia, Tuesday, morning), gives_report(Irving, Tuesday, afternoon), gives_report(Lenore, Wednesday, morning), gives_report(Kyle, Wednesday, afternoon))) ::: (A)\nis_sat(And(gives_report(Irving, Monday, morning), gives_report(Olivia, Monday, afternoon), gives_report(Helen, Tuesday, morning), gives_report(Kyle, Tuesday, afternoon), gives_report(Nina, Wednesday, morning), gives_report(Lenore, Wednesday, afternoon))) ::: (B)\nis_sat(And(gives_report(Lenore, Monday, morning), gives_report(Helen, Monday, afternoon), gives_report(George, Tuesday, morning), gives_report(Kyle, Tuesday, afternoon), gives_report(Robert, Wednesday, morning), gives_report(Irving, Wednesday, afternoon))) ::: (C)\nis_sat(And(gives_report(Nina, Monday, morning), gives_report(Helen, Monday, afternoon), gives_report(Robert, Tuesday, morning), gives_report(Irving, Tuesday, afternoon), gives_report(Olivia, Wednesday, morning), gives_report(Lenore, Wednesday, afternoon))) ::: (D)\nis_sat(And(gives_report(Olivia, Monday, morning), gives_report(Nina, Monday, afternoon), gives_report(Irving, Tuesday, morning), gives_report(Helen, Tuesday, afternoon), gives_report(Kyle, Wednesday, morning), gives_report(George, Wednesday, afternoon))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200010_3-G_1_2",
    "context": "Of the eight students—George, Helen, Irving, Kyle, Lenore, Nina, Olivia, and Robert—in a seminar, exactly six will give individual oral reports during three consecutive days—Monday, Tuesday, and Wednesday. Exactly two reports will be given each day—one in the morning and one in the afternoon—according to the following conditions: Tuesday is the only day on which George can give a report. Neither Olivia nor Robert can give an afternoon report. If Nina gives a report, then on the next day Helen and Irving must both give reports, unless Nina's report is given on Wednesday.",
    "question": "If Kyle and Lenore do not give reports, then the morning reports on Monday, Tuesday, and Wednesday, respectively, could be given by",
    "answer": "D",
    "options": [
      "A) Helen, George, and Nina",
      "B) Irving, Robert, and Helen",
      "C) Nina, Helen, and Olivia",
      "D) Olivia, Robert, and Irving",
      "E) Robert, George, and Helen"
    ],
    "raw_logic_programs": [
      "# Declarations\nstudents = EnumSort([George, Helen, Irving, Kyle, Lenore, Nina, Olivia, Robert])\ndays = EnumSort([Monday, Tuesday, Wednesday])\ntimes = EnumSort([morning, afternoon])\ngives_report = Function([students, days, times] -> [bool])\n\n# Constraints\nCount([s:students], Exists([d:days, t:times], gives_report(s, d, t))) == 6 ::: exactly six students will give reports\nForAll([d:days], Count([s:students], Exists([t:times], gives_report(s, d, t))) == 2) ::: exactly two reports will be given each day\nForAll([s:students], Implies(gives_report(s, Tuesday, morning), gives_report(s, Tuesday, afternoon))) ::: Tuesday is the only day on which George can give a report\nForAll([s:students], Implies(Or(s == Olivia, s == Robert), Not(gives_report(s, Monday, afternoon)))) ::: Neither Olivia nor Robert can give an afternoon report\nForAll([d:days], Implies(And(gives_report(Nina, d, morning), d != Wednesday), And(gives_report(Helen, d + 1, morning), gives_report(Irving, d + 1, morning)))) ::: If Nina gives a report, then on the next day Helen and Irving must both give reports, unless Nina's report is given on Wednesday\nNot(gives_report(Kyle, Monday, morning)) ::: Kyle does not give a report on Monday morning\nNot(gives_report(Lenore, Monday, morning)) ::: Lenore does not give a report on Monday morning\n\n# Options\nQuestion ::: If Kyle and Lenore do not give reports, then the morning reports on Monday, Tuesday, and Wednesday, respectively, could be given by\nis_sat(And(gives_report(Helen, Monday, morning), gives_report(George, Tuesday, morning), gives_report(Nina, Wednesday, morning))) ::: (A)\nis_sat(And(gives_report(Irving, Monday, morning), gives_report(Robert, Tuesday, morning), gives_report(Helen, Wednesday, morning))) ::: (B)\nis_sat(And(gives_report(Nina, Monday, morning), gives_report(Helen, Tuesday, morning), gives_report(Olivia, Wednesday, morning))) ::: (C)\nis_sat(And(gives_report(Olivia, Monday, morning), gives_report(Robert, Tuesday, morning), gives_report(Irving, Wednesday, morning))) ::: (D)\nis_sat(And(gives_report(Robert, Monday, morning), gives_report(George, Tuesday, morning), gives_report(Helen, Wednesday, morning))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200010_3-G_1_3",
    "context": "Of the eight students—George, Helen, Irving, Kyle, Lenore, Nina, Olivia, and Robert—in a seminar, exactly six will give individual oral reports during three consecutive days—Monday, Tuesday, and Wednesday. Exactly two reports will be given each day—one in the morning and one in the afternoon—according to the following conditions: Tuesday is the only day on which George can give a report. Neither Olivia nor Robert can give an afternoon report. If Nina gives a report, then on the next day Helen and Irving must both give reports, unless Nina's report is given on Wednesday.",
    "question": "Which one of the following is a pair of students who, if they give reports on the same day as each other, must give reports on Wednesday?",
    "answer": "B",
    "options": [
      "A) George and Lenore",
      "B) Helen and Nina",
      "C) Irving and Robert",
      "D) Kyle and Nina",
      "E) Olivia and Kyle"
    ],
    "raw_logic_programs": [
      "# Declarations\nstudents = EnumSort([George, Helen, Irving, Kyle, Lenore, Nina, Olivia, Robert])\ndays = EnumSort([Monday, Tuesday, Wednesday])\ntimes = EnumSort([morning, afternoon])\ngives_report = Function([students, days, times] -> [bool])\n\n# Constraints\nCount([s:students, d:days, t:times], gives_report(s, d, t)) == 6 ::: exactly six students will give reports\nForAll([d:days], Count([s:students, t:times], gives_report(s, d, t)) == 2) ::: exactly two reports will be given each day\nForAll([t:times], gives_report(George, Tuesday, t)) ::: Tuesday is the only day on which George can give a report\nForAll([t:times], Not(gives_report(Olivia, _, afternoon))) ::: Olivia cannot give an afternoon report\nForAll([t:times], Not(gives_report(Robert, _, afternoon))) ::: Robert cannot give an afternoon report\nForAll([d:days, t:times], Implies(gives_report(Nina, d, t), And(Implies(d != Wednesday, And(gives_report(Helen, d + 1, t), gives_report(Irving, d + 1, t))), True))) ::: If Nina gives a report, then on the next day Helen and Irving must both give reports, unless Nina's report is given on Wednesday\n\n# Options\nQuestion ::: Which one of the following is a pair of students who, if they give reports on the same day as each other, must give reports on Wednesday?\nis_sat(And(Exists([t:times], gives_report(George, Wednesday, t)), Exists([t:times], gives_report(Lenore, Wednesday, t)))) ::: (A)\nis_sat(And(Exists([t:times], gives_report(Helen, Wednesday, t)), Exists([t:times], gives_report(Nina, Wednesday, t)))) ::: (B)\nis_sat(And(Exists([t:times], gives_report(Irving, Wednesday, t)), Exists([t:times], gives_report(Robert, Wednesday, t)))) ::: (C)\nis_sat(And(Exists([t:times], gives_report(Kyle, Wednesday, t)), Exists([t:times], gives_report(Nina, Wednesday, t)))) ::: (D)\nis_sat(And(Exists([t:times], gives_report(Olivia, Wednesday, t)), Exists([t:times], gives_report(Kyle, Wednesday, t)))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200010_3-G_1_4",
    "context": "Of the eight students—George, Helen, Irving, Kyle, Lenore, Nina, Olivia, and Robert—in a seminar, exactly six will give individual oral reports during three consecutive days—Monday, Tuesday, and Wednesday. Exactly two reports will be given each day—one in the morning and one in the afternoon—according to the following conditions: Tuesday is the only day on which George can give a report. Neither Olivia nor Robert can give an afternoon report. If Nina gives a report, then on the next day Helen and Irving must both give reports, unless Nina's report is given on Wednesday.",
    "question": "If George, Nina, and Robert give reports and they do so on different days from one another, which one of the following could be true?",
    "answer": "A",
    "options": [
      "A) Helen gives a report on Wednesday.",
      "B) Nina gives a report on Monday.",
      "C) Nina gives a report on Tuesday.",
      "D) Olivia gives a report on Monday.",
      "E) Robert gives a report on Wednesday."
    ],
    "raw_logic_programs": [
      "# Declarations\nstudents = EnumSort([George, Helen, Irving, Kyle, Lenore, Nina, Olivia, Robert])\ndays = EnumSort([Monday, Tuesday, Wednesday])\ntimes = EnumSort([morning, afternoon])\ngives_report = Function([students, days, times] -> [bool])\n\n# Constraints\nCount([s:students, d:days, t:times], gives_report(s, d, t)) == 6 ::: exactly six students will give reports\nForAll([d:days], Count([s:students, t:times], gives_report(s, d, t)) == 2) ::: exactly two reports will be given each day\nForAll([t:times], gives_report(George, Tuesday, t)) ::: Tuesday is the only day on which George can give a report\nForAll([t:times], Not(gives_report(Olivia, _, afternoon))) ::: Olivia cannot give an afternoon report\nForAll([t:times], Not(gives_report(Robert, _, afternoon))) ::: Robert cannot give an afternoon report\nForAll([d:days], Implies(gives_report(Nina, d, _), And(gives_report(Helen, NextDay(d), _), gives_report(Irving, NextDay(d), _)))) ::: If Nina gives a report, then on the next day Helen and Irving must both give reports\nImplies(gives_report(Nina, Wednesday, _), Not(And(gives_report(Helen, Thursday, _), gives_report(Irving, Thursday, _)))) ::: unless Nina's report is given on Wednesday\n\n# Options\nQuestion ::: If George, Nina, and Robert give reports and they do so on different days from one another, which one of the following could be true?\nis_sat(And(gives_report(George, _, _), gives_report(Nina, _, _), gives_report(Robert, _, _), Distinct([d:days], gives_report(George, d, _), gives_report(Nina, d, _), gives_report(Robert, d, _)), gives_report(Helen, Wednesday, _))) ::: (A)\nis_sat(And(gives_report(George, _, _), gives_report(Nina, _, _), gives_report(Robert, _, _), Distinct([d:days], gives_report(George, d, _), gives_report(Nina, d, _), gives_report(Robert, d, _)), gives_report(Nina, Monday, _))) ::: (B)\nis_sat(And(gives_report(George, _, _), gives_report(Nina, _, _), gives_report(Robert, _, _), Distinct([d:days], gives_report(George, d, _), gives_report(Nina, d, _), gives_report(Robert, d, _)), gives_report(Nina, Tuesday, _))) ::: (C)\nis_sat(And(gives_report(George, _, _), gives_report(Nina, _, _), gives_report(Robert, _, _), Distinct([d:days], gives_report(George, d, _), gives_report(Nina, d, _), gives_report(Robert, d, _)), gives_report(Olivia, Monday, _))) ::: (D)\nis_sat(And(gives_report(George, _, _), gives_report(Nina, _, _), gives_report(Robert, _, _), Distinct([d:days], gives_report(George, d, _), gives_report(Nina, d, _), gives_report(Robert, d, _)), gives_report(Robert, Wednesday, _))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200010_3-G_1_5",
    "context": "Of the eight students—George, Helen, Irving, Kyle, Lenore, Nina, Olivia, and Robert—in a seminar, exactly six will give individual oral reports during three consecutive days—Monday, Tuesday, and Wednesday. Exactly two reports will be given each day—one in the morning and one in the afternoon—according to the following conditions: Tuesday is the only day on which George can give a report. Neither Olivia nor Robert can give an afternoon report. If Nina gives a report, then on the next day Helen and Irving must both give reports, unless Nina's report is given on Wednesday.",
    "question": "If Kyle gives the afternoon report on Tuesday, and Helen gives the afternoon report on Wednesday, which one of the following could be the list of the students who give the morning reports on Monday, Tuesday, and Wednesday, respectively?",
    "answer": "D",
    "options": [
      "A) Irving, Lenore, and Nina",
      "B) Lenore, George, and Irving",
      "C) Nina, Irving, and Lenore",
      "D) Robert, George, and Irving",
      "E) Robert, Irving, and Lenore"
    ],
    "raw_logic_programs": [
      "# Declarations\nstudents = EnumSort([George, Helen, Irving, Kyle, Lenore, Nina, Olivia, Robert])\ndays = EnumSort([Monday, Tuesday, Wednesday])\ntimes = EnumSort([morning, afternoon])\ngives_report = Function([students, days, times] -> [bool])\n\n# Constraints\nCount([s:students], Exists([d:days, t:times], gives_report(s, d, t))) == 6 ::: exactly six students will give reports\nForAll([d:days], Count([s:students], Exists([t:times], gives_report(s, d, t))) == 2) ::: exactly two reports will be given each day\nForAll([s:students], Implies(gives_report(s, Tuesday, _), s == George)) ::: Tuesday is the only day on which George can give a report\nForAll([s:students], Implies(s == Olivia, Not(Exists([d:days], gives_report(s, d, afternoon))))) ::: Neither Olivia nor Robert can give an afternoon report\nForAll([s:students], Implies(s == Robert, Not(Exists([d:days], gives_report(s, d, afternoon)))))\nForAll([d:days], Implies(And(gives_report(Nina, d, _), d != Wednesday), And(gives_report(Helen, d + 1, _), gives_report(Irving, d + 1, _)))) ::: If Nina gives a report, then on the next day Helen and Irving must both give reports, unless Nina's report is given on Wednesday\ngives_report(Kyle, Tuesday, afternoon) ::: Kyle gives the afternoon report on Tuesday\ngives_report(Helen, Wednesday, afternoon) ::: Helen gives the afternoon report on Wednesday\n\n# Options\nQuestion ::: If Kyle gives the afternoon report on Tuesday, and Helen gives the afternoon report on Wednesday, which one of the following could be the list of the students who give the morning reports on Monday, Tuesday, and Wednesday, respectively?\nis_valid(And(gives_report(Irving, Monday, morning), gives_report(Lenore, Tuesday, morning), gives_report(Nina, Wednesday, morning))) ::: (A)\nis_valid(And(gives_report(Lenore, Monday, morning), gives_report(George, Tuesday, morning), gives_report(Irving, Wednesday, morning))) ::: (B)\nis_valid(And(gives_report(Nina, Monday, morning), gives_report(Irving, Tuesday, morning), gives_report(Lenore, Wednesday, morning))) ::: (C)\nis_valid(And(gives_report(Robert, Monday, morning), gives_report(George, Tuesday, morning), gives_report(Irving, Wednesday, morning))) ::: (D)\nis_valid(And(gives_report(Robert, Monday, morning), gives_report(Irving, Tuesday, morning), gives_report(Lenore, Wednesday, morning))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200010_3-G_1_6",
    "context": "Of the eight students—George, Helen, Irving, Kyle, Lenore, Nina, Olivia, and Robert—in a seminar, exactly six will give individual oral reports during three consecutive days—Monday, Tuesday, and Wednesday. Exactly two reports will be given each day—one in the morning and one in the afternoon—according to the following conditions: Tuesday is the only day on which George can give a report. Neither Olivia nor Robert can give an afternoon report. If Nina gives a report, then on the next day Helen and Irving must both give reports, unless Nina's report is given on Wednesday.",
    "question": "If Helen, Kyle, and Lenore, not necessarily in that order, give the three morning reports, which one of the following must be true?",
    "answer": "B",
    "options": [
      "A) Helen gives a report on Monday.",
      "B) Irving gives a report on Monday.",
      "C) Irving gives a report on Wednesday.",
      "D) Kyle gives a report on Tuesday.",
      "E) Kyle gives a report on Wednesday."
    ],
    "raw_logic_programs": [
      "# Declarations\nstudents = EnumSort([George, Helen, Irving, Kyle, Lenore, Nina, Olivia, Robert])\ndays = EnumSort([Monday, Tuesday, Wednesday])\ntimes = EnumSort([morning, afternoon])\ngives_report = Function([students, days, times] -> [bool])\n\n# Constraints\nCount([s:students, d:days, t:times], gives_report(s, d, t)) == 6 ::: exactly six students will give reports\nForAll([d:days], Count([s:students], gives_report(s, d, morning)) == 1) ::: exactly one report is given in the morning each day\nForAll([d:days], Count([s:students], gives_report(s, d, afternoon)) == 1) ::: exactly one report is given in the afternoon each day\nForAll([s:students, t:times], Implies(gives_report(s, Tuesday, t), s == George)) ::: Tuesday is the only day on which George can give a report\nForAll([t:times], Not(gives_report(Olivia, Wednesday, t))) ::: Olivia cannot give an afternoon report\nForAll([t:times], Not(gives_report(Robert, Wednesday, t))) ::: Robert cannot give an afternoon report\nForAll([d:days], Implies(And(gives_report(Nina, d, morning), d != Wednesday), And(gives_report(Helen, d + 1, morning), gives_report(Irving, d + 1, morning)))) ::: If Nina gives a report, then on the next day Helen and Irving must both give reports, unless Nina's report is given on Wednesday\nAnd(gives_report(Helen, Monday, morning), gives_report(Kyle, Tuesday, morning), gives_report(Lenore, Wednesday, morning)) ::: Helen, Kyle, and Lenore give the three morning reports\n\n# Options\nQuestion ::: If Helen, Kyle, and Lenore, not necessarily in that order, give the three morning reports, which one of the following must be true?\nis_valid(gives_report(Helen, Monday, morning)) ::: (A)\nis_valid(gives_report(Irving, Monday, morning)) ::: (B)\nis_valid(gives_report(Irving, Wednesday, morning)) ::: (C)\nis_valid(gives_report(Kyle, Tuesday, morning)) ::: (D)\nis_valid(gives_report(Kyle, Wednesday, morning)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200010_3-G_2_7",
    "context": "The organizer of a reading club will select at least five and at most six works from a group of nine works. The group consists of three French novels, three Russian novels, two French plays, and one Russian play. The organizer's selection of works must conform to the following requirements: No more than four French works are selected. At least three but no more than four novels are selected. At least as many French novels as Russian novels are selected. If both French plays are selected, then the Russian play is not selected.",
    "question": "Which one of the following could be the organizer's selection of works?",
    "answer": "C",
    "options": [
      "A) one French novel, two Russian novels, one French play, one Russian play",
      "B) two French novels, one Russian novel, two French plays, one Russian play",
      "C) two French novels, two Russian novels, two French plays",
      "D) three French novels, one Russian novel, two French plays",
      "E) three French novels, two Russian novels, one Russian play"
    ],
    "raw_logic_programs": [
      "# Declarations\nworks = EnumSort([French_novel1, French_novel2, French_novel3, Russian_novel1, Russian_novel2, Russian_novel3, French_play1, French_play2, Russian_play])\nselected = Function([works] -> [bool])\n\n# Constraints\nAnd(Count([w:works], selected(w)) >= 5, Count([w:works], selected(w)) <= 6) ::: The organizer of a reading club will select at least five and at most six works\nCount([w:works], And(selected(w), Or(w == French_novel1, w == French_novel2, w == French_novel3, w == French_play1, w == French_play2))) <= 4 ::: No more than four French works are selected\nAnd(Count([w:works], And(selected(w), Or(w == French_novel1, w == French_novel2, w == French_novel3, w == Russian_novel1, w == Russian_novel2, w == Russian_novel3))) >= 3, Count([w:works], And(selected(w), Or(w == French_novel1, w == French_novel2, w == French_novel3, w == Russian_novel1, w == Russian_novel2, w == Russian_novel3))) <= 4) ::: At least three but no more than four novels are selected\nCount([w:works], And(selected(w), Or(w == French_novel1, w == French_novel2, w == French_novel3))) >= Count([w:works], And(selected(w), Or(w == Russian_novel1, w == Russian_novel2, w == Russian_novel3))) ::: At least as many French novels as Russian novels are selected\nImplies(And(selected(French_play1), selected(French_play2)), Not(selected(Russian_play))) ::: If both French plays are selected, then the Russian play is not selected\n\n# Options\nQuestion ::: Which one of the following could be the organizer's selection of works?\nis_sat(And(selected(French_novel1), And(selected(Russian_novel1), And(selected(Russian_novel2), And(selected(French_play1), selected(Russian_play)))))) ::: (A)\nis_sat(And(selected(French_novel1), And(selected(French_novel2), And(selected(Russian_novel1), And(selected(French_play1), And(selected(French_play2), selected(Russian_play))))))) ::: (B)\nis_sat(And(selected(French_novel1), And(selected(French_novel2), And(selected(Russian_novel1), And(selected(Russian_novel2), And(selected(French_play1), selected(French_play2))))))) ::: (C)\nis_sat(And(selected(French_novel1), And(selected(French_novel2), And(selected(French_novel3), And(selected(Russian_novel1), And(selected(French_play1), selected(French_play2))))))) ::: (D)\nis_sat(And(selected(French_novel1), And(selected(French_novel2), And(selected(French_novel3), And(selected(Russian_novel1), And(selected(Russian_novel2), selected(Russian_play))))))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200010_3-G_2_8",
    "context": "The organizer of a reading club will select at least five and at most six works from a group of nine works. The group consists of three French novels, three Russian novels, two French plays, and one Russian play. The organizer's selection of works must conform to the following requirements: No more than four French works are selected. At least three but no more than four novels are selected. At least as many French novels as Russian novels are selected. If both French plays are selected, then the Russian play is not selected.",
    "question": "Which one of the following could be true about the organizer's selection of works?",
    "answer": "A",
    "options": [
      "A) No Russian novels are selected.",
      "B) Exactly one French novel is selected.",
      "C) All three plays are selected.",
      "D) All three Russian novels are selected.",
      "E) All five French works are selected."
    ],
    "raw_logic_programs": [
      "# Declarations\nworks = EnumSort([french_novel1, french_novel2, french_novel3, russian_novel1, russian_novel2, russian_novel3, french_play1, french_play2, russian_play])\nselected = Function([works] -> [bool])\n\n# Constraints\nAnd(Count([w:works], selected(w)) >= 5, Count([w:works], selected(w)) <= 6) ::: The organizer of a reading club will select at least five and at most six works\nCount([w:works], And(selected(w), Or(w == french_novel1, w == french_novel2, w == french_novel3, w == french_play1, w == french_play2))) <= 4 ::: No more than four French works are selected\nAnd(Count([w:works], And(selected(w), Or(w == french_novel1, w == french_novel2, w == french_novel3, w == russian_novel1, w == russian_novel2, w == russian_novel3))) >= 3, Count([w:works], And(selected(w), Or(w == french_novel1, w == french_novel2, w == french_novel3, w == russian_novel1, w == russian_novel2, w == russian_novel3))) <= 4) ::: At least three but no more than four novels are selected\nCount([w:works], And(selected(w), Or(w == french_novel1, w == french_novel2, w == french_novel3))) >= Count([w:works], And(selected(w), Or(w == russian_novel1, w == russian_novel2, w == russian_novel3))) ::: At least as many French novels as Russian novels are selected\nImplies(And(selected(french_play1), selected(french_play2)), Not(selected(russian_play))) ::: If both French plays are selected, then the Russian play is not selected\n\n# Options\nQuestion ::: Which one of the following could be true about the organizer's selection of works?\nis_sat(And(Not(selected(russian_novel1)), Not(selected(russian_novel2)), Not(selected(russian_novel3)))) ::: (A)\nis_sat(And(selected(french_novel1), Not(selected(french_novel2)), Not(selected(french_novel3)))) ::: (B)\nis_sat(And(selected(french_play1), selected(french_play2), selected(russian_play))) ::: (C)\nis_sat(And(selected(russian_novel1), selected(russian_novel2), selected(russian_novel3))) ::: (D)\nis_sat(And(selected(french_novel1), selected(french_novel2), selected(french_novel3), selected(french_play1), selected(french_play2))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200010_3-G_2_9",
    "context": "The organizer of a reading club will select at least five and at most six works from a group of nine works. The group consists of three French novels, three Russian novels, two French plays, and one Russian play. The organizer's selection of works must conform to the following requirements: No more than four French works are selected. At least three but no more than four novels are selected. At least as many French novels as Russian novels are selected. If both French plays are selected, then the Russian play is not selected.",
    "question": "If the works selected include three French novels, which one of the following could be a complete and accurate list of the remaining works selected?",
    "answer": "C",
    "options": [
      "A) one Russian novel",
      "B) two French plays",
      "C) one Russian novel, one Russian play",
      "D) one Russian novel, two French plays",
      "E) two Russian novels, one French play"
    ],
    "raw_logic_programs": [
      "# Declarations\nworks = EnumSort([French_novel1, French_novel2, French_novel3, Russian_novel1, Russian_novel2, Russian_novel3, French_play1, French_play2, Russian_play])\nselected = Function([works] -> [bool])\n\n# Constraints\nAnd(5 <= Count([w:works], selected(w)), Count([w:works], selected(w)) <= 6) ::: The organizer of a reading club will select at least five and at most six works\nCount([w:works], And(selected(w), Or(w == French_novel1, w == French_novel2, w == French_novel3, w == French_play1, w == French_play2))) <= 4 ::: No more than four French works are selected\nAnd(3 <= Count([w:works], And(selected(w), Or(w == French_novel1, w == French_novel2, w == French_novel3, w == Russian_novel1, w == Russian_novel2, w == Russian_novel3))), Count([w:works], And(selected(w), Or(w == French_novel1, w == French_novel2, w == French_novel3, w == Russian_novel1, w == Russian_novel2, w == Russian_novel3))) <= 4) ::: At least three but no more than four novels are selected\nCount([w:works], And(selected(w), Or(w == French_novel1, w == French_novel2, w == French_novel3))) >= Count([w:works], And(selected(w), Or(w == Russian_novel1, w == Russian_novel2, w == Russian_novel3))) ::: At least as many French novels as Russian novels are selected\nImplies(And(selected(French_play1), selected(French_play2)), Not(selected(Russian_play))) ::: If both French plays are selected, then the Russian play is not selected\nAnd(selected(French_novel1), selected(French_novel2), selected(French_novel3)) ::: If the works selected include three French novels\n\n# Options\nQuestion ::: If the works selected include three French novels, which one of the following could be a complete and accurate list of the remaining works selected?\nis_accurate_list(And(selected(Russian_novel1), Not(selected(Russian_novel2)), Not(selected(Russian_novel3)), Not(selected(French_play1)), Not(selected(French_play2)), Not(selected(Russian_play)))) ::: (A)\nis_accurate_list(And(Not(selected(Russian_novel1)), Not(selected(Russian_novel2)), Not(selected(Russian_novel3)), selected(French_play1), selected(French_play2), Not(selected(Russian_play)))) ::: (B)\nis_accurate_list(And(selected(Russian_novel1), Not(selected(Russian_novel2)), Not(selected(Russian_novel3)), Not(selected(French_play1)), Not(selected(French_play2)), selected(Russian_play))) ::: (C)\nis_accurate_list(And(selected(Russian_novel1), Not(selected(Russian_novel2)), Not(selected(Russian_novel3)), selected(French_play1), selected(French_play2), Not(selected(Russian_play)))) ::: (D)\nis_accurate_list(And(selected(Russian_novel1), selected(Russian_novel2), Not(selected(Russian_novel3)), Not(selected(French_play1)), Not(selected(French_play2)), selected(French_play1))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200010_3-G_2_10",
    "context": "The organizer of a reading club will select at least five and at most six works from a group of nine works. The group consists of three French novels, three Russian novels, two French plays, and one Russian play. The organizer's selection of works must conform to the following requirements: No more than four French works are selected. At least three but no more than four novels are selected. At least as many French novels as Russian novels are selected. If both French plays are selected, then the Russian play is not selected.",
    "question": "The organizer must at least select",
    "answer": "D",
    "options": [
      "A) one French novel and one French play",
      "B) one French novel and one Russian play",
      "C) one Russian novel and one French play",
      "D) two French novels",
      "E) two Russian novels"
    ],
    "raw_logic_programs": [
      "# Declarations\nworks = EnumSort([French_novel1, French_novel2, French_novel3, Russian_novel1, Russian_novel2, Russian_novel3, French_play1, French_play2, Russian_play])\nselected = Function([works] -> [bool])\n\n# Constraints\nAnd(5 <= Count([w:works], selected(w)), Count([w:works], selected(w)) <= 6) ::: The organizer of a reading club will select at least five and at most six works\nCount([w:works], And(selected(w), Or(w == French_novel1, w == French_novel2, w == French_novel3, w == French_play1, w == French_play2))) <= 4 ::: No more than four French works are selected\nAnd(3 <= Count([w:works], And(selected(w), Or(w == French_novel1, w == French_novel2, w == French_novel3, w == Russian_novel1, w == Russian_novel2, w == Russian_novel3))), Count([w:works], And(selected(w), Or(w == French_novel1, w == French_novel2, w == French_novel3, w == Russian_novel1, w == Russian_novel2, w == Russian_novel3))) <= 4) ::: At least three but no more than four novels are selected\nCount([w:works], And(selected(w), Or(w == French_novel1, w == French_novel2, w == French_novel3))) >= Count([w:works], And(selected(w), Or(w == Russian_novel1, w == Russian_novel2, w == Russian_novel3))) ::: At least as many French novels as Russian novels are selected\nImplies(And(selected(French_play1), selected(French_play2)), Not(selected(Russian_play))) ::: If both French plays are selected, then the Russian play is not selected\n\n# Options\nQuestion ::: The organizer must at least select\nis_unsat(Not(selected(French_novel1))) ::: (A)\nis_unsat(Not(selected(French_novel1))) ::: (B)\nis_unsat(Not(selected(Russian_novel1))) ::: (C)\nis_unsat(Not(And(selected(French_novel1), selected(French_novel2)))) ::: (D)\nis_unsat(Not(And(selected(Russian_novel1), selected(Russian_novel2)))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200010_3-G_2_11",
    "context": "The organizer of a reading club will select at least five and at most six works from a group of nine works. The group consists of three French novels, three Russian novels, two French plays, and one Russian play. The organizer's selection of works must conform to the following requirements: No more than four French works are selected. At least three but no more than four novels are selected. At least as many French novels as Russian novels are selected. If both French plays are selected, then the Russian play is not selected.",
    "question": "Any one of the following could be true about the organizer's selections of works EXCEPT:",
    "answer": "A",
    "options": [
      "A) No Russian novels and exactly one play are selected.",
      "B) Exactly one Russian novel and both French plays are selected.",
      "C) Exactly two French novels and the Russian play are selected.",
      "D) Exactly two French novels and exactly two plays are selected.",
      "E) Exactly two Russian novels and exactly one play are selected."
    ],
    "raw_logic_programs": [
      "# Declarations\nworks = EnumSort([french_novel1, french_novel2, french_novel3, russian_novel1, russian_novel2, russian_novel3, french_play1, french_play2, russian_play])\nselected = Function([works] -> [bool])\n\n# Constraints\nAnd(Count([w:works], selected(w)) >= 5, Count([w:works], selected(w)) <= 6) ::: The organizer of a reading club will select at least five and at most six works\nCount([w:works], And(selected(w), Or(w == french_novel1, w == french_novel2, w == french_novel3))) <= 4 ::: No more than four French works are selected\nAnd(Count([w:works], And(selected(w), Or(w == french_novel1, w == french_novel2, w == french_novel3, w == russian_novel1, w == russian_novel2, w == russian_novel3))) >= 3, Count([w:works], And(selected(w), Or(w == french_novel1, w == french_novel2, w == french_novel3, w == russian_novel1, w == russian_novel2, w == russian_novel3))) <= 4) ::: At least three but no more than four novels are selected\nCount([w:works], And(selected(w), Or(w == french_novel1, w == french_novel2, w == french_novel3))) >= Count([w:works], And(selected(w), Or(w == russian_novel1, w == russian_novel2, w == russian_novel3))) ::: At least as many French novels as Russian novels are selected\nImplies(And(selected(french_play1), selected(french_play2)), Not(selected(russian_play))) ::: If both French plays are selected, then the Russian play is not selected\n\n# Options\nQuestion ::: Any one of the following could be true about the organizer's selections of works EXCEPT:\nis_exception(And(Count([w:works], And(selected(w), Or(w == russian_novel1, w == russian_novel2, w == russian_novel3))) == 0, Count([w:works], And(selected(w), Or(w == french_play1, w == french_play2))) == 1)) ::: (A)\nis_exception(And(Count([w:works], And(selected(w), Or(w == russian_novel1, w == russian_novel2, w == russian_novel3))) == 1, And(selected(french_play1), selected(french_play2)))) ::: (B)\nis_exception(And(Count([w:works], And(selected(w), Or(w == french_novel1, w == french_novel2, w == french_novel3))) == 2, selected(russian_play))) ::: (C)\nis_exception(And(Count([w:works], And(selected(w), Or(w == french_novel1, w == french_novel2, w == french_novel3))) == 2, Count([w:works], And(selected(w), Or(w == french_play1, w == french_play2))) == 2)) ::: (D)\nis_exception(And(Count([w:works], And(selected(w), Or(w == russian_novel1, w == russian_novel2, w == russian_novel3))) == 2, Count([w:works], And(selected(w), Or(w == french_play1, w == french_play2))) == 1)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200010_3-G_3_12",
    "context": "At a concert, exactly eight compositions—F, H, L, O, P, R, S, and T—are to be performed exactly once each, consecutively and one composition at a time. The order of their performance must satisfy the following conditions: T is performed either immediately before F or immediately after R. At least two compositions are performed either after F and before R, or after R and before F. O is performed either first or fifth. The eighth composition performed is either L or H. P is performed at some time before S. At least one composition is performed either after O and before S, or after S and before O.",
    "question": "Which one of the following lists the compositions in an order in which they could be performed during the concert, from first through eighth?",
    "answer": "A",
    "options": [
      "A) L, P, S, R, O, T, F, H",
      "B) O, T, P, F, S, H, R, L",
      "C) P, T, F, S, L, R, O, H",
      "D) P, T, F, S, O, R, L, H",
      "E) T, F, P, R, O, L, S, H"
    ],
    "raw_logic_programs": [
      "# Declarations\ncompositions = EnumSort([F, H, L, O, P, R, S, T])\nperformed = Function([compositions] -> [int])\nForAll([c:compositions], And(1 <= performed(c), performed(c) <= 8))\n\n# Constraints\nDistinct([c:compositions], performed(c)) ::: each composition is performed exactly once\nOr(performed(T) + 1 == performed(F), performed(T) - 1 == performed(R)) ::: T is performed either immediately before F or immediately after R\nOr(And(performed(F) < performed(R), Count([c:compositions], And(performed(F) < performed(c), performed(c) < performed(R))) >= 2), And(performed(R) < performed(F), Count([c:compositions], And(performed(R) < performed(c), performed(c) < performed(F))) >= 2)) ::: At least two compositions are performed either after F and before R, or after R and before F\nOr(performed(O) == 1, performed(O) == 5) ::: O is performed either first or fifth\nOr(performed(L) == 8, performed(H) == 8) ::: The eighth composition performed is either L or H\nperformed(P) < performed(S) ::: P is performed at some time before S\nOr(And(performed(O) < performed(S), Count([c:compositions], And(performed(O) < performed(c), performed(c) < performed(S))) >= 1), And(performed(S) < performed(O), Count([c:compositions], And(performed(S) < performed(c), performed(c) < performed(O))) >= 1)) ::: At least one composition is performed either after O and before S, or after S and before O\n\n# Options\nQuestion ::: Which one of the following lists the compositions in an order in which they could be performed during the concert, from first through eighth?\nis_sat(And(performed(L) == 1, performed(P) == 2, performed(S) == 3, performed(R) == 4, performed(O) == 5, performed(T) == 6, performed(F) == 7, performed(H) == 8)) ::: (A)\nis_sat(And(performed(O) == 1, performed(T) == 2, performed(P) == 3, performed(F) == 4, performed(S) == 5, performed(H) == 6, performed(R) == 7, performed(L) == 8)) ::: (B)\nis_sat(And(performed(P) == 1, performed(T) == 2, performed(F) == 3, performed(S) == 4, performed(L) == 5, performed(R) == 6, performed(O) == 7, performed(H) == 8)) ::: (C)\nis_sat(And(performed(P) == 1, performed(T) == 2, performed(F) == 3, performed(S) == 4, performed(O) == 5, performed(R) == 6, performed(L) == 7, performed(H) == 8)) ::: (D)\nis_sat(And(performed(T) == 1, performed(F) == 2, performed(P) == 3, performed(R) == 4, performed(O) == 5, performed(L) == 6, performed(S) == 7, performed(H) == 8)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200010_3-G_3_13",
    "context": "At a concert, exactly eight compositions—F, H, L, O, P, R, S, and T—are to be performed exactly once each, consecutively and one composition at a time. The order of their performance must satisfy the following conditions: T is performed either immediately before F or immediately after R. At least two compositions are performed either after F and before R, or after R and before F. O is performed either first or fifth. The eighth composition performed is either L or H. P is performed at some time before S. At least one composition is performed either after O and before S, or after S and before O.",
    "question": "P CANNOT be performed",
    "answer": "E",
    "options": [
      "A) second",
      "B) third",
      "C) fourth",
      "D) sixth",
      "E) seventh"
    ],
    "raw_logic_programs": [
      "# Declarations\ncompositions = EnumSort([F, H, L, O, P, R, S, T])\nperformed = Function([compositions] -> [int])\nForAll([c:compositions], And(1 <= performed(c), performed(c) <= 8))\n\n# Constraints\nOr(And(performed(T) == performed(F) - 1, performed(F) != 1), And(performed(T) == performed(R) + 1, performed(R) != 8)) ::: T is performed either immediately before F or immediately after R\nOr(Count([c:compositions], And(performed(F) < performed(c), performed(c) < performed(R))) >= 2, Count([c:compositions], And(performed(R) < performed(c), performed(c) < performed(F))) >= 2) ::: At least two compositions are performed either after F and before R, or after R and before F\nOr(performed(O) == 1, performed(O) == 5) ::: O is performed either first or fifth\nOr(performed(L) == 8, performed(H) == 8) ::: The eighth composition performed is either L or H\nperformed(P) < performed(S) ::: P is performed at some time before S\nOr(Count([c:compositions], And(performed(O) < performed(c), performed(c) < performed(S))) >= 1, Count([c:compositions], And(performed(S) < performed(c), performed(c) < performed(O))) >= 1) ::: At least one composition is performed either after O and before S, or after S and before O\n\n# Options\nQuestion ::: P CANNOT be performed\nis_unsat(performed(P) == 2) ::: (A)\nis_unsat(performed(P) == 3) ::: (B)\nis_unsat(performed(P) == 4) ::: (C)\nis_unsat(performed(P) == 6) ::: (D)\nis_unsat(performed(P) == 7) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200010_3-G_3_14",
    "context": "At a concert, exactly eight compositions—F, H, L, O, P, R, S, and T—are to be performed exactly once each, consecutively and one composition at a time. The order of their performance must satisfy the following conditions: T is performed either immediately before F or immediately after R. At least two compositions are performed either after F and before R, or after R and before F. O is performed either first or fifth. The eighth composition performed is either L or H. P is performed at some time before S. At least one composition is performed either after O and before S, or after S and before O.",
    "question": "If T is performed fifth and F is performed sixth, then S must be performed either",
    "answer": "A",
    "options": [
      "A) fourth or seventh",
      "B) third or sixth",
      "C) third or fourth",
      "D) second or seventh",
      "E) first or fourth"
    ],
    "raw_logic_programs": [
      "# Declarations\ncompositions = EnumSort([F, H, L, O, P, R, S, T])\nperformed = Function([compositions] -> [int])\nForAll([c:compositions], And(1 <= performed(c), performed(c) <= 8))\n\n# Constraints\nDistinct([c:compositions], performed(c)) ::: exactly eight compositions—F, H, L, O, P, R, S, and T—are to be performed exactly once each, consecutively and one composition at a time\nOr(And(performed(T) == performed(F) - 1, performed(F) < performed(R)), And(performed(T) == performed(R) + 1, performed(R) < performed(F))) ::: T is performed either immediately before F or immediately after R\nOr(And(performed(F) < performed(R), Count([c:compositions], And(performed(F) < performed(c), performed(c) < performed(R))) >= 2), And(performed(R) < performed(F), Count([c:compositions], And(performed(R) < performed(c), performed(c) < performed(F))) >= 2)) ::: At least two compositions are performed either after F and before R, or after R and before F\nOr(performed(O) == 1, performed(O) == 5) ::: O is performed either first or fifth\nOr(performed(L) == 8, performed(H) == 8) ::: The eighth composition performed is either L or H\nperformed(P) < performed(S) ::: P is performed at some time before S\nOr(And(performed(O) < performed(S), Count([c:compositions], And(performed(O) < performed(c), performed(c) < performed(S))) >= 1), And(performed(S) < performed(O), Count([c:compositions], And(performed(S) < performed(c), performed(c) < performed(O))) >= 1)) ::: At least one composition is performed either after O and before S, or after S and before O\nAnd(performed(T) == 5, performed(F) == 6) ::: If T is performed fifth and F is performed sixth\n\n# Options\nQuestion ::: If T is performed fifth and F is performed sixth, then S must be performed either\nis_valid(Or(performed(S) == 4, performed(S) == 7)) ::: (A)\nis_valid(Or(performed(S) == 3, performed(S) == 6)) ::: (B)\nis_valid(Or(performed(S) == 3, performed(S) == 4)) ::: (C)\nis_valid(Or(performed(S) == 2, performed(S) == 7)) ::: (D)\nis_valid(Or(performed(S) == 1, performed(S) == 4)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200010_3-G_3_15",
    "context": "At a concert, exactly eight compositions—F, H, L, O, P, R, S, and T—are to be performed exactly once each, consecutively and one composition at a time. The order of their performance must satisfy the following conditions: T is performed either immediately before F or immediately after R. At least two compositions are performed either after F and before R, or after R and before F. O is performed either first or fifth. The eighth composition performed is either L or H. P is performed at some time before S. At least one composition is performed either after O and before S, or after S and before O.",
    "question": "If O is performed immediately after T, then F must be performed either",
    "answer": "E",
    "options": [
      "A) first or second",
      "B) second or third",
      "C) fourth or sixth",
      "D) fourth or seventh",
      "E) sixth or seventh"
    ],
    "raw_logic_programs": [
      "# Declarations\ncompositions = EnumSort([F, H, L, O, P, R, S, T])\nperformed = Function([compositions] -> [int])\nForAll([c:compositions], And(1 <= performed(c), performed(c) <= 8))\n\n# Constraints\nDistinct([c:compositions], performed(c)) ::: exactly eight compositions—F, H, L, O, P, R, S, and T—are to be performed exactly once each, consecutively and one composition at a time\nOr(performed(T) + 1 == performed(F), performed(T) - 1 == performed(R)) ::: T is performed either immediately before F or immediately after R\nOr(And(performed(F) < performed(R), Count([c:compositions], And(performed(F) < performed(c), performed(c) < performed(R))) >= 2), And(performed(R) < performed(F), Count([c:compositions], And(performed(R) < performed(c), performed(c) < performed(F))) >= 2)) ::: At least two compositions are performed either after F and before R, or after R and before F\nOr(performed(O) == 1, performed(O) == 5) ::: O is performed either first or fifth\nOr(performed(L) == 8, performed(H) == 8) ::: The eighth composition performed is either L or H\nperformed(P) < performed(S) ::: P is performed at some time before S\nOr(And(performed(O) < performed(S), Count([c:compositions], And(performed(O) < performed(c), performed(c) < performed(S))) >= 1), And(performed(S) < performed(O), Count([c:compositions], And(performed(S) < performed(c), performed(c) < performed(O))) >= 1)) ::: At least one composition is performed either after O and before S, or after S and before O\nperformed(O) == performed(T) + 1 ::: If O is performed immediately after T\n\n# Options\nQuestion ::: If O is performed immediately after T, then F must be performed either\nis_valid(Or(performed(F) == 1, performed(F) == 2)) ::: (A)\nis_valid(Or(performed(F) == 2, performed(F) == 3)) ::: (B)\nis_valid(Or(performed(F) == 4, performed(F) == 6)) ::: (C)\nis_valid(Or(performed(F) == 4, performed(F) == 7)) ::: (D)\nis_valid(Or(performed(F) == 6, performed(F) == 7)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200010_3-G_3_16",
    "context": "At a concert, exactly eight compositions—F, H, L, O, P, R, S, and T—are to be performed exactly once each, consecutively and one composition at a time. The order of their performance must satisfy the following conditions: T is performed either immediately before F or immediately after R. At least two compositions are performed either after F and before R, or after R and before F. O is performed either first or fifth. The eighth composition performed is either L or H. P is performed at some time before S. At least one composition is performed either after O and before S, or after S and before O.",
    "question": "If S is performed fourth, which one of the following could be an accurate list of the compositions performed first, second, and third, respectively?",
    "answer": "C",
    "options": [
      "A) F, H, P",
      "B) H, P. L",
      "C) O, P, R",
      "D) O, P, T",
      "E) P, R, T"
    ],
    "raw_logic_programs": [
      "# Declarations\ncompositions = EnumSort([F, H, L, O, P, R, S, T])\nperformed = Function([compositions] -> [int])\nForAll([c:compositions], And(1 <= performed(c), performed(c) <= 8))\n\n# Constraints\nOr(And(performed(T) == performed(F) - 1, performed(F) != 1), And(performed(T) == performed(R) + 1, performed(R) != 8)) ::: T is performed either immediately before F or immediately after R\nOr(And(performed(F) < performed(R), Count([c:compositions], And(performed(F) < performed(c), performed(c) < performed(R))) >= 2), And(performed(R) < performed(F), Count([c:compositions], And(performed(R) < performed(c), performed(c) < performed(F))) >= 2)) ::: At least two compositions are performed either after F and before R, or after R and before F\nOr(performed(O) == 1, performed(O) == 5) ::: O is performed either first or fifth\nOr(performed(L) == 8, performed(H) == 8) ::: The eighth composition performed is either L or H\nperformed(P) < performed(S) ::: P is performed at some time before S\nOr(And(performed(O) < performed(S), Count([c:compositions], And(performed(O) < performed(c), performed(c) < performed(S))) >= 1), And(performed(S) < performed(O), Count([c:compositions], And(performed(S) < performed(c), performed(c) < performed(O))) >= 1)) ::: At least one composition is performed either after O and before S, or after S and before O\nperformed(S) == 4 ::: If S is performed fourth\n\n# Options\nQuestion ::: If S is performed fourth, which one of the following could be an accurate list of the compositions performed first, second, and third, respectively?\nis_accurate_list(And(performed(F) == 1, performed(H) == 2, performed(P) == 3)) ::: (A)\nis_accurate_list(And(performed(H) == 1, performed(P) == 2, performed(L) == 3)) ::: (B)\nis_accurate_list(And(performed(O) == 1, performed(P) == 2, performed(R) == 3)) ::: (C)\nis_accurate_list(And(performed(O) == 1, performed(P) == 2, performed(T) == 3)) ::: (D)\nis_accurate_list(And(performed(P) == 1, performed(R) == 2, performed(T) == 3)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200010_3-G_3_17",
    "context": "At a concert, exactly eight compositions—F, H, L, O, P, R, S, and T—are to be performed exactly once each, consecutively and one composition at a time. The order of their performance must satisfy the following conditions: T is performed either immediately before F or immediately after R. At least two compositions are performed either after F and before R, or after R and before F. O is performed either first or fifth. The eighth composition performed is either L or H. P is performed at some time before S. At least one composition is performed either after O and before S, or after S and before O.",
    "question": "If P is performed third and S is performed sixth, the composition performed fifth must be either",
    "answer": "C",
    "options": [
      "A) F or H",
      "B) F or O",
      "C) F or T",
      "D) H or L",
      "E) O or R"
    ],
    "raw_logic_programs": [
      "# Declarations\ncompositions = EnumSort([F, H, L, O, P, R, S, T])\nperformed = Function([compositions] -> [int])\nForAll([c:compositions], And(1 <= performed(c), performed(c) <= 8))\n\n# Constraints\nDistinct([c:compositions], performed(c)) ::: exactly eight compositions—F, H, L, O, P, R, S, and T—are to be performed exactly once each, consecutively and one composition at a time\nOr(And(performed(T) == performed(F) - 1, performed(F) < performed(R)), And(performed(T) == performed(R) + 1, performed(R) < performed(F))) ::: T is performed either immediately before F or immediately after R\nOr(Count([c:compositions], And(performed(F) < performed(c), performed(c) < performed(R))) >= 2, Count([c:compositions], And(performed(R) < performed(c), performed(c) < performed(F))) >= 2) ::: At least two compositions are performed either after F and before R, or after R and before F\nOr(performed(O) == 1, performed(O) == 5) ::: O is performed either first or fifth\nOr(performed(L) == 8, performed(H) == 8) ::: The eighth composition performed is either L or H\nperformed(P) < performed(S) ::: P is performed at some time before S\nOr(Count([c:compositions], And(performed(O) < performed(c), performed(c) < performed(S))) >= 1, Count([c:compositions], And(performed(S) < performed(c), performed(c) < performed(O))) >= 1) ::: At least one composition is performed either after O and before S, or after S and before O\nAnd(performed(P) == 3, performed(S) == 6) ::: If P is performed third and S is performed sixth\n\n# Options\nQuestion ::: If P is performed third and S is performed sixth, the composition performed fifth must be either\nis_valid(Or(performed(F) == 5, performed(H) == 5)) ::: (A)\nis_valid(Or(performed(F) == 5, performed(O) == 5)) ::: (B)\nis_valid(Or(performed(F) == 5, performed(T) == 5)) ::: (C)\nis_valid(Or(performed(H) == 5, performed(L) == 5)) ::: (D)\nis_valid(Or(performed(O) == 5, performed(R) == 5)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200010_3-G_3_18",
    "context": "At a concert, exactly eight compositions—F, H, L, O, P, R, S, and T—are to be performed exactly once each, consecutively and one composition at a time. The order of their performance must satisfy the following conditions: T is performed either immediately before F or immediately after R. At least two compositions are performed either after F and before R, or after R and before F. O is performed either first or fifth. The eighth composition performed is either L or H. P is performed at some time before S. At least one composition is performed either after O and before S, or after S and before O.",
    "question": "If exactly two compositions are performed after F but before O, then R must be performed",
    "answer": "D",
    "options": [
      "A) first",
      "B) third",
      "C) fourth",
      "D) sixth",
      "E) seventh"
    ],
    "raw_logic_programs": [
      "# Declarations\ncompositions = EnumSort([F, H, L, O, P, R, S, T])\nperformed = Function([compositions] -> [int])\nForAll([c:compositions], And(1 <= performed(c), performed(c) <= 8))\n\n# Constraints\nForAll([c:compositions], Count([c2:compositions], performed(c2) == performed(c)) == 1) ::: each composition is performed exactly once\nOr(performed(T) + 1 == performed(F), performed(T) - 1 == performed(R)) ::: T is performed either immediately before F or immediately after R\nOr(And(performed(F) < performed(R), Count([c:compositions], And(performed(F) < performed(c), performed(c) < performed(R))) >= 2), And(performed(R) < performed(F), Count([c:compositions], And(performed(R) < performed(c), performed(c) < performed(F))) >= 2)) ::: At least two compositions are performed either after F and before R, or after R and before F\nOr(performed(O) == 1, performed(O) == 5) ::: O is performed either first or fifth\nOr(performed(L) == 8, performed(H) == 8) ::: The eighth composition performed is either L or H\nperformed(P) < performed(S) ::: P is performed at some time before S\nOr(And(performed(O) < performed(S), Count([c:compositions], And(performed(O) < performed(c), performed(c) < performed(S))) >= 1), And(performed(S) < performed(O), Count([c:compositions], And(performed(S) < performed(c), performed(c) < performed(O))) >= 1)) ::: At least one composition is performed either after O and before S, or after S and before O\nAnd(Count([c:compositions], And(performed(F) < performed(c), performed(c) < performed(O))) == 2, performed(F) < performed(O)) ::: If exactly two compositions are performed after F but before O\n\n# Options\nQuestion ::: If exactly two compositions are performed after F but before O, then R must be performed\nis_valid(performed(R) == 1) ::: (A)\nis_valid(performed(R) == 3) ::: (B)\nis_valid(performed(R) == 4) ::: (C)\nis_valid(performed(R) == 6) ::: (D)\nis_valid(performed(R) == 7) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200010_3-G_4_19",
    "context": "On each of exactly seven consecutive days (day 1 though day 7), a pet shop features exactly one of three breeds of kitten—Himalayan, Manx, Siamese—and exactly one of three breeds of puppy—Greyhound, Newfoundland, Rottweiler. The following conditions must apply: Greyhounds are featured on day 1. No breed is featured on any two consecutive days. Any breed featured on day 1 is not featured on day 7. Himalayans are featured on exactly three days, but not on day 1. Rottweilers are not featured on day 7, nor on any day that features Himalayans.",
    "question": "Which one of the following could be the order in which the breeds of kitten are featured in the pet shop, from day 1 though day 7?",
    "answer": "E",
    "options": [
      "A) Himalayan, Manx, Siamese, Himalayan, Manx, Himalayan, Siamese",
      "B) Manx, Himalayan, Siamese, Himalayan, Manx Himalayan, Manx",
      "C) Manx, Himalayan, Manx, Himalayan, Siamese, Manx, Siamese",
      "D) Siamese, Himalayan, Manx, Himalayan, Siamese, Siamese, Himalayan",
      "E) Siamese, Himalayan, Siamese, Himalayan, Manx, Siamese, Himalayan"
    ],
    "raw_logic_programs": [
      "# Declarations\ndays = EnumSort([1, 2, 3, 4, 5, 6, 7])\nkitten_breeds = EnumSort([Himalayan, Manx, Siamese])\npuppy_breeds = EnumSort([Greyhound, Newfoundland, Rottweiler])\nfeatures = Function([days] -> [kitten_breeds])\nfeatures_puppy = Function([days] -> [puppy_breeds])\n\n# Constraints\nForAll([d:days], Exists([k:kitten_breeds], features(d) == k)) ::: On each of exactly seven consecutive days (day 1 though day 7), a pet shop features exactly one of three breeds of kitten—Himalayan, Manx, Siamese\nForAll([d:days], Exists([p:puppy_breeds], features_puppy(d) == p)) ::: On each of exactly seven consecutive days (day 1 though day 7), a pet shop features exactly one of three breeds of kitten—Himalayan, Manx, Siamese\nForAll([d:days], Implies(d < 7, features(d) != features(d + 1))) ::: No breed is featured on any two consecutive days\nForAll([d:days], Implies(d < 7, features_puppy(d) != features_puppy(d + 1))) ::: No breed is featured on any two consecutive days\nfeatures_puppy(1) == Greyhound ::: Greyhounds are featured on day 1\nfeatures(1) != features(7) ::: Any breed featured on day 1 is not featured on day 7\nCount([d:days], features(d) == Himalayan) == 3 ::: Himalayans are featured on exactly three days, but not on day 1\nfeatures(1) != Himalayan ::: Himalayans are featured on exactly three days, but not on day 1\nForAll([d:days], Implies(features(d) == Himalayan, features_puppy(d) != Rottweiler)) ::: Rottweilers are not featured on day 7, nor on any day that features Himalayans\nfeatures_puppy(7) != Rottweiler ::: Rottweilers are not featured on day 7, nor on any day that features Himalayans\n\n# Options\nQuestion ::: Which one of the following could be the order in which the breeds of kitten are featured in the pet shop, from day 1 though day 7?\nis_valid(And(features(1) == Himalayan, features(2) == Manx, features(3) == Siamese, features(4) == Himalayan, features(5) == Manx, features(6) == Himalayan, features(7) == Siamese)) ::: (A)\nis_valid(And(features(1) == Manx, features(2) == Himalayan, features(3) == Siamese, features(4) == Himalayan, features(5) == Manx, features(6) == Himalayan, features(7) == Manx)) ::: (B)\nis_valid(And(features(1) == Manx, features(2) == Himalayan, features(3) == Manx, features(4) == Himalayan, features(5) == Siamese, features(6) == Manx, features(7) == Siamese)) ::: (C)\nis_valid(And(features(1) == Siamese, features(2) == Himalayan, features(3) == Manx, features(4) == Himalayan, features(5) == Siamese, features(6) == Siamese, features(7) == Himalayan)) ::: (D)\nis_valid(And(features(1) == Siamese, features(2) == Himalayan, features(3) == Siamese, features(4) == Himalayan, features(5) == Manx, features(6) == Siamese, features(7) == Himalayan)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200010_3-G_4_20",
    "context": "On each of exactly seven consecutive days (day 1 though day 7), a pet shop features exactly one of three breeds of kitten—Himalayan, Manx, Siamese—and exactly one of three breeds of puppy—Greyhound, Newfoundland, Rottweiler. The following conditions must apply: Greyhounds are featured on day 1. No breed is featured on any two consecutive days. Any breed featured on day 1 is not featured on day 7. Himalayans are featured on exactly three days, but not on day 1. Rottweilers are not featured on day 7, nor on any day that features Himalayans.",
    "question": "If Himalayans are not featured on day 2, which one of the following could be true?",
    "answer": "B",
    "options": [
      "A) Manx are featured on day 3.",
      "B) Siamese are featured on day 4.",
      "C) Rottweilers are featured on day 5.",
      "D) Himalayans are featured on day 6.",
      "E) Greyhounds are featured on day 7."
    ],
    "raw_logic_programs": [
      "# Declarations\ndays = EnumSort([1, 2, 3, 4, 5, 6, 7])\nkitten_breeds = EnumSort([Himalayan, Manx, Siamese])\npuppy_breeds = EnumSort([Greyhound, Newfoundland, Rottweiler])\nfeatured = Function([days, kitten_breeds] -> [bool])\nfeatured = Function([days, puppy_breeds] -> [bool])\n\n# Constraints\nForAll([d:days], Count([k:kitten_breeds], featured(d, k)) == 1) ::: exactly one of three breeds of kitten\nForAll([d:days], Count([p:puppy_breeds], featured(d, p)) == 1) ::: exactly one of three breeds of puppy\nForAll([d:days], Implies(d < 7, Not(featured(d, featured(d + 1))))) ::: No breed is featured on any two consecutive days\nForAll([k:kitten_breeds, p:puppy_breeds], Implies(featured(1, k), Not(featured(7, k)))) ::: Any breed featured on day 1 is not featured on day 7\nCount([d:days], featured(d, Himalayan)) == 3 ::: Himalayans are featured on exactly three days\nNot(featured(1, Himalayan)) ::: Himalayans are not featured on day 1\nForAll([d:days], Implies(featured(d, Himalayan), Not(featured(d, Rottweiler)))) ::: Rottweilers are not featured on any day that features Himalayans\nNot(featured(7, Rottweiler)) ::: Rottweilers are not featured on day 7\nfeatured(1, Greyhound) ::: Greyhounds are featured on day 1\nNot(featured(2, Himalayan)) ::: Himalayans are not featured on day 2\n\n# Options\nQuestion ::: If Himalayans are not featured on day 2, which one of the following could be true?\nis_sat(featured(3, Manx)) ::: (A)\nis_sat(featured(4, Siamese)) ::: (B)\nis_sat(featured(5, Rottweiler)) ::: (C)\nis_sat(featured(6, Himalayan)) ::: (D)\nis_sat(featured(7, Greyhound)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200010_3-G_4_21",
    "context": "On each of exactly seven consecutive days (day 1 though day 7), a pet shop features exactly one of three breeds of kitten—Himalayan, Manx, Siamese—and exactly one of three breeds of puppy—Greyhound, Newfoundland, Rottweiler. The following conditions must apply: Greyhounds are featured on day 1. No breed is featured on any two consecutive days. Any breed featured on day 1 is not featured on day 7. Himalayans are featured on exactly three days, but not on day 1. Rottweilers are not featured on day 7, nor on any day that features Himalayans.",
    "question": "Which one of the following could be true?",
    "answer": "D",
    "options": [
      "A) Greyhounds and Siamese are both featured on day 2.",
      "B) Greyhounds and Himalayans are both featured on day 7.",
      "C) Rottweilers and Himalayans are both featured on day 4.",
      "D) Rottweilers and Manx are both featured on day 5.",
      "E) Newfoundlands and Manx are both featured on day 6."
    ],
    "raw_logic_programs": [
      "# Declarations\ndays = EnumSort([1, 2, 3, 4, 5, 6, 7])\nkitten_breeds = EnumSort([Himalayan, Manx, Siamese])\npuppy_breeds = EnumSort([Greyhound, Newfoundland, Rottweiler])\nfeatures = Function([days] -> [kitten_breeds])\nfeatures = Function([days] -> [puppy_breeds])\n\n# Constraints\nForAll([d:days], And(Count([k:kitten_breeds], features(d, k) == k) == 1, Count([p:puppy_breeds], features(d, p) == p) == 1)) ::: On each of exactly seven consecutive days (day 1 though day 7), a pet shop features exactly one of three breeds of kitten—Himalayan, Manx, Siamese—and exactly one of three breeds of puppy—Greyhound, Newfoundland, Rottweiler.\nForAll([d:days], Implies(d < 7, features(d, features(d + 1)) != features(d + 1))) ::: No breed is featured on any two consecutive days.\nForAll([k:kitten_breeds, p:puppy_breeds], Implies(features(1, k) == k, features(7, k) != k)) ::: Any breed featured on day 1 is not featured on day 7.\nAnd(Count([d:days], features(d, Himalayan) == Himalayan) == 3, features(1, Himalayan) != Himalayan) ::: Himalayans are featured on exactly three days, but not on day 1.\nAnd(features(7, Rottweiler) != Rottweiler, ForAll([d:days], Implies(features(d, Himalayan) == Himalayan, features(d, Rottweiler) != Rottweiler))) ::: Rottweilers are not featured on day 7, nor on any day that features Himalayans.\nfeatures(1, Greyhound) == Greyhound ::: Greyhounds are featured on day 1.\n\n# Options\nQuestion ::: Which one of the following could be true?\nis_sat(And(features(2, Greyhound) == Greyhound, features(2, Siamese) == Siamese)) ::: (A)\nis_sat(And(features(7, Greyhound) == Greyhound, features(7, Himalayan) == Himalayan)) ::: (B)\nis_sat(And(features(4, Rottweiler) == Rottweiler, features(4, Himalayan) == Himalayan)) ::: (C)\nis_sat(And(features(5, Rottweiler) == Rottweiler, features(5, Manx) == Manx)) ::: (D)\nis_sat(And(features(6, Newfoundland) == Newfoundland, features(6, Manx) == Manx)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200010_3-G_4_22",
    "context": "On each of exactly seven consecutive days (day 1 though day 7), a pet shop features exactly one of three breeds of kitten—Himalayan, Manx, Siamese—and exactly one of three breeds of puppy—Greyhound, Newfoundland, Rottweiler. The following conditions must apply: Greyhounds are featured on day 1. No breed is featured on any two consecutive days. Any breed featured on day 1 is not featured on day 7. Himalayans are featured on exactly three days, but not on day 1. Rottweilers are not featured on day 7, nor on any day that features Himalayans.",
    "question": "If Himalayans are not featured on day 7, then which one of the following pairs of days CANNOT feature both the same breed of kitten and the same breed of puppy?",
    "answer": "B",
    "options": [
      "A) day 1 and day 3",
      "B) day 2 and day 6",
      "C) day 3 and day 5",
      "D) day 4 and day 6",
      "E) day 5 and day 7"
    ],
    "raw_logic_programs": [
      "# Declarations\ndays = EnumSort([1, 2, 3, 4, 5, 6, 7])\nkitten_breeds = EnumSort([Himalayan, Manx, Siamese])\npuppy_breeds = EnumSort([Greyhound, Newfoundland, Rottweiler])\nfeatures = Function([days, kitten_breeds] -> [bool])\nfeatures = Function([days, puppy_breeds] -> [bool])\n\n# Constraints\nForAll([d:days], Count([k:kitten_breeds], features(d, k)) == 1) ::: exactly one of three breeds of kitten\nForAll([d:days], Count([p:puppy_breeds], features(d, p)) == 1) ::: exactly one of three breeds of puppy\nForAll([d:days], Implies(d < 7, Not(features(d, features(d + 1))))) ::: no breed is featured on any two consecutive days\nForAll([k:kitten_breeds], Implies(features(1, k), Not(features(7, k)))) ::: any breed featured on day 1 is not featured on day 7\nCount([d:days], features(d, Himalayan)) == 3 ::: Himalayans are featured on exactly three days\nNot(features(1, Himalayan)) ::: Himalayans are not featured on day 1\nForAll([d:days], Implies(features(d, Himalayan), Not(features(d, Rottweiler)))) ::: Rottweilers are not featured on any day that features Himalayans\nNot(features(7, Rottweiler)) ::: Rottweilers are not featured on day 7\nNot(features(7, Himalayan)) ::: Himalayans are not featured on day 7\n\n# Options\nQuestion ::: If Himalayans are not featured on day 7, then which one of the following pairs of days CANNOT feature both the same breed of kitten and the same breed of puppy?\nis_unsat(And(features(1, features(3)), features(1, features(3)))) ::: (A)\nis_unsat(And(features(2, features(6)), features(2, features(6)))) ::: (B)\nis_unsat(And(features(3, features(5)), features(3, features(5)))) ::: (C)\nis_unsat(And(features(4, features(6)), features(4, features(6)))) ::: (D)\nis_unsat(And(features(5, features(7)), features(5, features(7)))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200010_3-G_4_23",
    "context": "On each of exactly seven consecutive days (day 1 though day 7), a pet shop features exactly one of three breeds of kitten—Himalayan, Manx, Siamese—and exactly one of three breeds of puppy—Greyhound, Newfoundland, Rottweiler. The following conditions must apply: Greyhounds are featured on day 1. No breed is featured on any two consecutive days. Any breed featured on day 1 is not featured on day 7. Himalayans are featured on exactly three days, but not on day 1. Rottweilers are not featured on day 7, nor on any day that features Himalayans.",
    "question": "Which one of the following could be true?",
    "answer": "A",
    "options": [
      "A) There are exactly four breeds that are each featured on three days.",
      "B) Greyhounds are featured on every day that Himalayans are.",
      "C) Himalayans are featured on every day that Greyhounds are.",
      "D) Himalayans are featured on every day that Rottweilers are not.",
      "E) Rottweilers are featured on every day that Himalayans are not."
    ],
    "raw_logic_programs": [
      "# Declarations\ndays = EnumSort([1, 2, 3, 4, 5, 6, 7])\nkitten_breeds = EnumSort([Himalayan, Manx, Siamese])\npuppy_breeds = EnumSort([Greyhound, Newfoundland, Rottweiler])\nfeatures = Function([days, kitten_breeds] -> [bool])\nfeatures = Function([days, puppy_breeds] -> [bool])\n\n# Constraints\nForAll([d:days], Count([k:kitten_breeds], features(d, k)) == 1) ::: On each of exactly seven consecutive days (day 1 though day 7), a pet shop features exactly one of three breeds of kitten—Himalayan, Manx, Siamese\nForAll([d:days], Count([p:puppy_breeds], features(d, p)) == 1) ::: On each of exactly seven consecutive days (day 1 though day 7), a pet shop features exactly one of three breeds of puppy—Greyhound, Newfoundland, Rottweiler\nForAll([d:days, b:kitten_breeds], Implies(features(d, b), Not(features(d + 1, b)))) ::: No breed is featured on any two consecutive days\nForAll([d:days, b:puppy_breeds], Implies(features(d, b), Not(features(d + 1, b)))) ::: No breed is featured on any two consecutive days\nForAll([b:kitten_breeds], Implies(features(1, b), Not(features(7, b)))) ::: Any breed featured on day 1 is not featured on day 7\nForAll([b:puppy_breeds], Implies(features(1, b), Not(features(7, b)))) ::: Any breed featured on day 1 is not featured on day 7\nCount([d:days], features(d, Himalayan)) == 3 ::: Himalayans are featured on exactly three days, but not on day 1\nNot(features(1, Himalayan)) ::: Himalayans are featured on exactly three days, but not on day 1\nAnd(Not(features(7, Rottweiler)), ForAll([d:days], Implies(features(d, Himalayan), Not(features(d, Rottweiler))))) ::: Rottweilers are not featured on day 7, nor on any day that features Himalayans\nfeatures(1, Greyhound) ::: Greyhounds are featured on day 1\n\n# Options\nQuestion ::: Which one of the following could be true?\nis_sat(And(Count([d:days], features(d, Greyhound)) == 3, Count([d:days], features(d, Himalayan)) == 3, Count([d:days], features(d, Manx)) == 3, Count([d:days], features(d, Newfoundland)) == 3)) ::: (A)\nis_sat(ForAll([d:days], Implies(features(d, Himalayan), features(d, Greyhound)))) ::: (B)\nis_sat(ForAll([d:days], Implies(features(d, Greyhound), features(d, Himalayan)))) ::: (C)\nis_sat(ForAll([d:days], Implies(Not(features(d, Rottweiler)), features(d, Himalayan)))) ::: (D)\nis_sat(ForAll([d:days], Implies(Not(features(d, Himalayan)), features(d, Rottweiler)))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200010_3-G_4_24",
    "context": "On each of exactly seven consecutive days (day 1 though day 7), a pet shop features exactly one of three breeds of kitten—Himalayan, Manx, Siamese—and exactly one of three breeds of puppy—Greyhound, Newfoundland, Rottweiler. The following conditions must apply: Greyhounds are featured on day 1. No breed is featured on any two consecutive days. Any breed featured on day 1 is not featured on day 7. Himalayans are featured on exactly three days, but not on day 1. Rottweilers are not featured on day 7, nor on any day that features Himalayans.",
    "question": "If Himalayans are not featured on day 7, which one of the following could be true?",
    "answer": "D",
    "options": [
      "A) Greyhounds are featured on days 3 and 5.",
      "B) Newfoundlands are featured on day 3.",
      "C) Rottweilers are featured on day 6.",
      "D) Rottweilers are featured only on day 3.",
      "E) Rottweilers are featured on exactly three days."
    ],
    "raw_logic_programs": [
      "# Declarations\ndays = EnumSort([1, 2, 3, 4, 5, 6, 7])\nkitten_breeds = EnumSort([Himalayan, Manx, Siamese])\npuppy_breeds = EnumSort([Greyhound, Newfoundland, Rottweiler])\nfeatures = Function([days] -> [kitten_breeds])\nfeatures_puppy = Function([days] -> [puppy_breeds])\n\n# Constraints\nForAll([d:days], And(1 <= features(d), features(d) <= 3)) ::: exactly one of three breeds of kitten\nForAll([d:days], And(1 <= features_puppy(d), features_puppy(d) <= 3)) ::: exactly one of three breeds of puppy\nForAll([d:days], Implies(d < 7, features(d) != features(d + 1))) ::: No breed is featured on any two consecutive days\nForAll([d:days], Implies(d < 7, features_puppy(d) != features_puppy(d + 1))) ::: No breed is featured on any two consecutive days\nfeatures(1) != features(7) ::: Any breed featured on day 1 is not featured on day 7\nfeatures_puppy(1) != features_puppy(7) ::: Any breed featured on day 1 is not featured on day 7\nCount([d:days], features(d) == Himalayan) == 3 ::: Himalayans are featured on exactly three days\nfeatures(1) != Himalayan ::: Himalayans are not featured on day 1\nfeatures(7) != Himalayan ::: Himalayans are not featured on day 7\nForAll([d:days], Implies(features(d) == Himalayan, features_puppy(d) != Rottweiler)) ::: Rottweilers are not featured on any day that features Himalayans\nfeatures_puppy(7) != Rottweiler ::: Rottweilers are not featured on day 7\n\n# Options\nQuestion ::: If Himalayans are not featured on day 7, which one of the following could be true?\nis_sat(And(features_puppy(3) == Greyhound, features_puppy(5) == Greyhound)) ::: (A)\nis_sat(features_puppy(3) == Newfoundland) ::: (B)\nis_sat(features_puppy(6) == Rottweiler) ::: (C)\nis_sat(And(features_puppy(3) == Rottweiler, Count([d:days], features_puppy(d) == Rottweiler) == 1)) ::: (D)\nis_sat(Count([d:days], features_puppy(d) == Rottweiler) == 3) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200312_1-G_1_1",
    "context": "A panel of five scientists will be formed. The panelists will be selected from among three botanists—F, G, and H—three chemists—K, L, and M—and three zoologists—P, Q, and R. Selection is governed by the following conditions: The panel must include at least one scientist of each of the three types. If more than one botanist is selected, then at most one zoologist is selected. F and K cannot both be selected. K and M cannot both be selected. If M is selected, both P and R must be selected.",
    "question": "Which one of the following is an acceptable selection of scientists for the panel?",
    "answer": "C",
    "options": [
      "A) F, G, K, P, Q",
      "B) G, H, K, L, M",
      "C) G, H, K, L, R",
      "D) H, K, M, P, R",
      "E) H, L, M, P, Q"
    ],
    "raw_logic_programs": [
      "# Declarations\nbotanists = EnumSort([F, G, H])\nchemists = EnumSort([K, L, M])\nzoologists = EnumSort([P, Q, R])\nscientists = EnumSort([F, G, H, K, L, M, P, Q, R])\nselected = Function([scientists] -> [bool])\n\n# Constraints\nAnd(Count([b:botanists], selected(b)) >= 1, Count([c:chemists], selected(c)) >= 1, Count([z:zoologists], selected(z)) >= 1) ::: The panel must include at least one scientist of each of the three types\nImplies(Count([b:botanists], selected(b)) > 1, Count([z:zoologists], selected(z)) <= 1) ::: If more than one botanist is selected, then at most one zoologist is selected\nNot(And(selected(F), selected(K))) ::: F and K cannot both be selected\nNot(And(selected(K), selected(M))) ::: K and M cannot both be selected\nImplies(selected(M), And(selected(P), selected(R))) ::: If M is selected, both P and R must be selected\n\n# Options\nQuestion ::: Which one of the following is an acceptable selection of scientists for the panel?\nis_sat(And(selected(F), selected(G), selected(K), selected(P), selected(Q))) ::: (A)\nis_sat(And(selected(G), selected(H), selected(K), selected(L), selected(M))) ::: (B)\nis_sat(And(selected(G), selected(H), selected(K), selected(L), selected(R))) ::: (C)\nis_sat(And(selected(H), selected(K), selected(M), selected(P), selected(R))) ::: (D)\nis_sat(And(selected(H), selected(L), selected(M), selected(P), selected(Q))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200312_1-G_1_2",
    "context": "A panel of five scientists will be formed. The panelists will be selected from among three botanists—F, G, and H—three chemists—K, L, and M—and three zoologists—P, Q, and R. Selection is governed by the following conditions: The panel must include at least one scientist of each of the three types. If more than one botanist is selected, then at most one zoologist is selected. F and K cannot both be selected. K and M cannot both be selected. If M is selected, both P and R must be selected.",
    "question": "If M is the only chemist selected for the panel, which one of the following must be true?",
    "answer": "E",
    "options": [
      "A) F and G are both selected.",
      "B) G and H are both selected.",
      "C) H and P are both selected.",
      "D) F, G, and H are all selected.",
      "E) P, Q, and R are all selected."
    ],
    "raw_logic_programs": [
      "# Declarations\nbotanists = EnumSort([F, G, H])\nchemists = EnumSort([K, L, M])\nzoologists = EnumSort([P, Q, R])\nscientists = EnumSort([F, G, H, K, L, M, P, Q, R])\nselected = Function([scientists] -> [bool])\n\n# Constraints\nAnd(Exists([b:botanists], selected(b)), Exists([c:chemists], selected(c)), Exists([z:zoologists], selected(z))) ::: The panel must include at least one scientist of each of the three types\nImplies(Count([b:botanists], selected(b)) > 1, Count([z:zoologists], selected(z)) <= 1) ::: If more than one botanist is selected, then at most one zoologist is selected\nNot(And(selected(F), selected(K))) ::: F and K cannot both be selected\nNot(And(selected(K), selected(M))) ::: K and M cannot both be selected\nImplies(selected(M), And(selected(P), selected(R))) ::: If M is selected, both P and R must be selected\nselected(M) ::: M is the only chemist selected for the panel\n\n# Options\nQuestion ::: If M is the only chemist selected for the panel, which one of the following must be true?\nis_valid(And(selected(F), selected(G))) ::: (A)\nis_valid(And(selected(G), selected(H))) ::: (B)\nis_valid(And(selected(H), selected(P))) ::: (C)\nis_valid(And(selected(F), selected(G), selected(H))) ::: (D)\nis_valid(And(selected(P), selected(Q), selected(R))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200312_1-G_1_3",
    "context": "A panel of five scientists will be formed. The panelists will be selected from among three botanists—F, G, and H—three chemists—K, L, and M—and three zoologists—P, Q, and R. Selection is governed by the following conditions: The panel must include at least one scientist of each of the three types. If more than one botanist is selected, then at most one zoologist is selected. F and K cannot both be selected. K and M cannot both be selected. If M is selected, both P and R must be selected.",
    "question": "If four of the scientists selected are F, L, Q, and R, which one of the following must be the fifth scientist selected?",
    "answer": "E",
    "options": [
      "A) G",
      "B) H",
      "C) K",
      "D) M",
      "E) P"
    ],
    "raw_logic_programs": [
      "# Declarations\nbotanists = EnumSort([F, G, H])\nchemists = EnumSort([K, L, M])\nzoologists = EnumSort([P, Q, R])\nscientists = EnumSort([F, G, H, K, L, M, P, Q, R])\nselected = Function([scientists] -> [bool])\n\n# Constraints\nAnd(Exists([b:botanists], selected(b)), Exists([c:chemists], selected(c)), Exists([z:zoologists], selected(z))) ::: The panel must include at least one scientist of each of the three types\nImplies(Count([b:botanists], selected(b)) > 1, Count([z:zoologists], selected(z)) <= 1) ::: If more than one botanist is selected, then at most one zoologist is selected\nNot(And(selected(F), selected(K))) ::: F and K cannot both be selected\nNot(And(selected(K), selected(M))) ::: K and M cannot both be selected\nImplies(selected(M), And(selected(P), selected(R))) ::: If M is selected, both P and R must be selected\nAnd(selected(F), selected(L), selected(Q), selected(R)) ::: If four of the scientists selected are F, L, Q, and R\n\n# Options\nQuestion ::: Which one of the following must be the fifth scientist selected?\nis_valid(selected(G)) ::: (A)\nis_valid(selected(H)) ::: (B)\nis_valid(selected(K)) ::: (C)\nis_valid(selected(M)) ::: (D)\nis_valid(selected(P)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200312_1-G_1_4",
    "context": "A panel of five scientists will be formed. The panelists will be selected from among three botanists—F, G, and H—three chemists—K, L, and M—and three zoologists—P, Q, and R. Selection is governed by the following conditions: The panel must include at least one scientist of each of the three types. If more than one botanist is selected, then at most one zoologist is selected. F and K cannot both be selected. K and M cannot both be selected. If M is selected, both P and R must be selected.",
    "question": "If P is the only zoologist selected, which one of the following must be true?",
    "answer": "D",
    "options": [
      "A) If K is selected, G cannot be selected.",
      "B) If L is selected, F cannot be selected.",
      "C) If exactly one chemist is selected, it must be K.",
      "D) If exactly two chemists are selected, F cannot be selected.",
      "E) If exactly two chemists are selected, G cannot be selected."
    ],
    "raw_logic_programs": [
      "# Declarations\nbotanists = EnumSort([F, G, H])\nchemists = EnumSort([K, L, M])\nzoologists = EnumSort([P, Q, R])\nscientists = UnionSort([botanists, chemists, zoologists])\nselected = Function([scientists] -> [bool])\n\n# Constraints\nAnd(Exists([b:botanists], selected(b)), Exists([c:chemists], selected(c)), Exists([z:zoologists], selected(z))) ::: The panel must include at least one scientist of each of the three types\nImplies(Count([b:botanists], selected(b)) > 1, Count([z:zoologists], selected(z)) <= 1) ::: If more than one botanist is selected, then at most one zoologist is selected\nNot(And(selected(F), selected(K))) ::: F and K cannot both be selected\nNot(And(selected(K), selected(M))) ::: K and M cannot both be selected\nImplies(selected(M), And(selected(P), selected(R))) ::: If M is selected, both P and R must be selected\nselected(P) ::: P is the only zoologist selected\nForAll([z:zoologists], Implies(z != P, Not(selected(z)))) ::: P is the only zoologist selected\n\n# Options\nQuestion ::: If P is the only zoologist selected, which one of the following must be true?\nis_valid(Implies(selected(K), Not(selected(G)))) ::: (A)\nis_valid(Implies(selected(L), Not(selected(F)))) ::: (B)\nis_valid(Implies(Count([c:chemists], selected(c)) == 1, selected(K))) ::: (C)\nis_valid(Implies(Count([c:chemists], selected(c)) == 2, Not(selected(F)))) ::: (D)\nis_valid(Implies(Count([c:chemists], selected(c)) == 2, Not(selected(G)))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200312_1-G_1_5",
    "context": "A panel of five scientists will be formed. The panelists will be selected from among three botanists—F, G, and H—three chemists—K, L, and M—and three zoologists—P, Q, and R. Selection is governed by the following conditions: The panel must include at least one scientist of each of the three types. If more than one botanist is selected, then at most one zoologist is selected. F and K cannot both be selected. K and M cannot both be selected. If M is selected, both P and R must be selected.",
    "question": "If both G and H are among the scientists selected, then the panel must include either",
    "answer": "A",
    "options": [
      "A) F or else K",
      "B) F or else M",
      "C) K or else M",
      "D) M or else Q",
      "E) P or else Q"
    ],
    "raw_logic_programs": [
      "# Declarations\nbotanists = EnumSort([F, G, H])\nchemists = EnumSort([K, L, M])\nzoologists = EnumSort([P, Q, R])\nscientists = EnumSort([F, G, H, K, L, M, P, Q, R])\nselected = Function([scientists] -> [bool])\n\n# Constraints\nAnd(Exists([b:botanists], selected(b)), Exists([c:chemists], selected(c)), Exists([z:zoologists], selected(z))) ::: The panel must include at least one scientist of each of the three types\nImplies(Count([b:botanists], selected(b)) > 1, Count([z:zoologists], selected(z)) <= 1) ::: If more than one botanist is selected, then at most one zoologist is selected\nNot(And(selected(F), selected(K))) ::: F and K cannot both be selected\nNot(And(selected(K), selected(M))) ::: K and M cannot both be selected\nImplies(selected(M), And(selected(P), selected(R))) ::: If M is selected, both P and R must be selected\nAnd(selected(G), selected(H)) ::: If both G and H are among the scientists selected\n\n# Options\nQuestion ::: If both G and H are among the scientists selected, then the panel must include either\nis_valid(Or(selected(F), selected(K))) ::: (A)\nis_valid(Or(selected(F), selected(M))) ::: (B)\nis_valid(Or(selected(K), selected(M))) ::: (C)\nis_valid(Or(selected(M), selected(Q))) ::: (D)\nis_valid(Or(selected(P), selected(Q))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200312_1-G_2_6",
    "context": "A loading dock consists of exactly six bays numbered 1 through 6 consecutively from one side of the dock to the other. Each bay is holding a different one of exactly six types of cargo—fuel, grain, livestock, machinery, produce, or textiles. The following apply: The bay holding grain has a higher number than the bay holding livestock. The bay holding livestock has a higher number than the bay holding textiles. The bay holding produce has a higher number than the bay holding fuel. The bay holding textiles is next to the bay holding produce.",
    "question": "Which one of the following lists could accurately identify the cargo held in each of the loading dock's first three bays, listed in order from bay 1 to bay 3?",
    "answer": "A",
    "options": [
      "A) fuel, machinery, textiles",
      "B) grain, machinery, fuel",
      "C) machinery, livestock, fuel",
      "D) machinery, textiles, fuel",
      "E) machinery, textiles, produce"
    ],
    "raw_logic_programs": [
      "# Declarations\nbays = EnumSort([1, 2, 3, 4, 5, 6])\ncargo = EnumSort([fuel, grain, livestock, machinery, produce, textiles])\nholds = Function([bays] -> [cargo])\n\n# Constraints\nForAll([b:bays], Distinct([c:cargo], holds(b) == c)) ::: Each bay is holding a different one of exactly six types of cargo\nholds(grain) > holds(livestock) ::: The bay holding grain has a higher number than the bay holding livestock\nholds(livestock) > holds(textiles) ::: The bay holding livestock has a higher number than the bay holding textiles\nholds(produce) > holds(fuel) ::: The bay holding produce has a higher number than the bay holding fuel\nExists([b:bays], And(holds(b) == textiles, holds(b + 1) == produce)) ::: The bay holding textiles is next to the bay holding produce\n\n# Options\nQuestion ::: Which one of the following lists could accurately identify the cargo held in each of the loading dock's first three bays, listed in order from bay 1 to bay 3?\nis_sat(And(holds(1) == fuel, holds(2) == machinery, holds(3) == textiles)) ::: (A)\nis_sat(And(holds(1) == grain, holds(2) == machinery, holds(3) == fuel)) ::: (B)\nis_sat(And(holds(1) == machinery, holds(2) == livestock, holds(3) == fuel)) ::: (C)\nis_sat(And(holds(1) == machinery, holds(2) == textiles, holds(3) == fuel)) ::: (D)\nis_sat(And(holds(1) == machinery, holds(2) == textiles, holds(3) == produce)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200312_1-G_2_7",
    "context": "A loading dock consists of exactly six bays numbered 1 through 6 consecutively from one side of the dock to the other. Each bay is holding a different one of exactly six types of cargo—fuel, grain, livestock, machinery, produce, or textiles. The following apply: The bay holding grain has a higher number than the bay holding livestock. The bay holding livestock has a higher number than the bay holding textiles. The bay holding produce has a higher number than the bay holding fuel. The bay holding textiles is next to the bay holding produce.",
    "question": "Which one of the following CANNOT be the type of cargo held in bay 4?",
    "answer": "A",
    "options": [
      "A) grain",
      "B) livestock",
      "C) machinery",
      "D) produce",
      "E) textiles"
    ],
    "raw_logic_programs": [
      "# Declarations\nbays = EnumSort([1, 2, 3, 4, 5, 6])\ncargo = EnumSort([fuel, grain, livestock, machinery, produce, textiles])\nholds = Function([bays] -> [cargo])\n\n# Constraints\nForAll([b:bays], Distinct([c:cargo], holds(b) == c)) ::: Each bay is holding a different one of exactly six types of cargo\nholds(grain) > holds(livestock) ::: The bay holding grain has a higher number than the bay holding livestock\nholds(livestock) > holds(textiles) ::: The bay holding livestock has a higher number than the bay holding textiles\nholds(produce) > holds(fuel) ::: The bay holding produce has a higher number than the bay holding fuel\nExists([b:bays], And(holds(b) == textiles, Or(holds(b + 1) == produce, holds(b - 1) == produce))) ::: The bay holding textiles is next to the bay holding produce\n\n# Options\nQuestion ::: Which one of the following CANNOT be the type of cargo held in bay 4?\nis_unsat(holds(4) == grain) ::: (A)\nis_unsat(holds(4) == livestock) ::: (B)\nis_unsat(holds(4) == machinery) ::: (C)\nis_unsat(holds(4) == produce) ::: (D)\nis_unsat(holds(4) == textiles) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200312_1-G_2_8",
    "context": "A loading dock consists of exactly six bays numbered 1 through 6 consecutively from one side of the dock to the other. Each bay is holding a different one of exactly six types of cargo—fuel, grain, livestock, machinery, produce, or textiles. The following apply: The bay holding grain has a higher number than the bay holding livestock. The bay holding livestock has a higher number than the bay holding textiles. The bay holding produce has a higher number than the bay holding fuel. The bay holding textiles is next to the bay holding produce.",
    "question": "If there is exactly one bay between the bay holding machinery and the bay holding grain, then for exactly how many of the six bays is the type of cargo that bay is holding completely determined?",
    "answer": "C",
    "options": [
      "A) two",
      "B) three",
      "C) four",
      "D) five",
      "E) six"
    ],
    "raw_logic_programs": [
      "# Declarations\nbays = EnumSort([1, 2, 3, 4, 5, 6])\ncargo = EnumSort([fuel, grain, livestock, machinery, produce, textiles])\nholds = Function([bays] -> [cargo])\n\n# Constraints\nForAll([b:bays], Distinct([b2:bays], holds(b) == holds(b2))) ::: Each bay is holding a different one of exactly six types of cargo\nholds(grain) > holds(livestock) ::: The bay holding grain has a higher number than the bay holding livestock\nholds(livestock) > holds(textiles) ::: The bay holding livestock has a higher number than the bay holding textiles\nholds(produce) > holds(fuel) ::: The bay holding produce has a higher number than the bay holding fuel\nExists([b:bays], And(holds(b) == textiles, Or(holds(b + 1) == produce, holds(b - 1) == produce))) ::: The bay holding textiles is next to the bay holding produce\n\n# Options\nQuestion ::: If there is exactly one bay between the bay holding machinery and the bay holding grain, then for exactly how many of the six bays is the type of cargo that bay is holding completely determined?\nis_sat(Exists([b:bays], And(holds(b) == machinery, Or(holds(b + 2) == grain, holds(b - 2) == grain)))) ::: There is exactly one bay between the bay holding machinery and the bay holding grain\nis_determined(Count([b:bays], Not(holds(b) == Unknown))) ::: for exactly how many of the six bays is the type of cargo that bay is holding completely determined?\nis_determined(2) ::: (A)\nis_determined(3) ::: (B)\nis_determined(4) ::: (C)\nis_determined(5) ::: (D)\nis_determined(6) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200312_1-G_2_9",
    "context": "A loading dock consists of exactly six bays numbered 1 through 6 consecutively from one side of the dock to the other. Each bay is holding a different one of exactly six types of cargo—fuel, grain, livestock, machinery, produce, or textiles. The following apply: The bay holding grain has a higher number than the bay holding livestock. The bay holding livestock has a higher number than the bay holding textiles. The bay holding produce has a higher number than the bay holding fuel. The bay holding textiles is next to the bay holding produce.",
    "question": "Which one of the following could be the bay holding livestock?",
    "answer": "D",
    "options": [
      "A) bay 1",
      "B) bay 2",
      "C) bay 3",
      "D) bay 5",
      "E) bay 6"
    ],
    "raw_logic_programs": [
      "# Declarations\nbays = EnumSort([1, 2, 3, 4, 5, 6])\ncargo = EnumSort([fuel, grain, livestock, machinery, produce, textiles])\nholds = Function([bays] -> [cargo])\n\n# Constraints\nForAll([b:bays], Distinct([c:cargo], holds(b) == c)) ::: Each bay is holding a different one of exactly six types of cargo\nholds(grain) > holds(livestock) ::: The bay holding grain has a higher number than the bay holding livestock\nholds(livestock) > holds(textiles) ::: The bay holding livestock has a higher number than the bay holding textiles\nholds(produce) > holds(fuel) ::: The bay holding produce has a higher number than the bay holding fuel\nExists([b:bays], And(holds(b) == textiles, Or(holds(b + 1) == produce, holds(b - 1) == produce))) ::: The bay holding textiles is next to the bay holding produce\n\n# Options\nQuestion ::: Which one of the following could be the bay holding livestock?\nis_sat(holds(1) == livestock) ::: (A)\nis_sat(holds(2) == livestock) ::: (B)\nis_sat(holds(3) == livestock) ::: (C)\nis_sat(holds(5) == livestock) ::: (D)\nis_sat(holds(6) == livestock) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200312_1-G_2_10",
    "context": "A loading dock consists of exactly six bays numbered 1 through 6 consecutively from one side of the dock to the other. Each bay is holding a different one of exactly six types of cargo—fuel, grain, livestock, machinery, produce, or textiles. The following apply: The bay holding grain has a higher number than the bay holding livestock. The bay holding livestock has a higher number than the bay holding textiles. The bay holding produce has a higher number than the bay holding fuel. The bay holding textiles is next to the bay holding produce.",
    "question": "Which one of the following must be false?",
    "answer": "C",
    "options": [
      "A) The bay holding fuel is next to the bay holding machinery.",
      "B) The bay holding grain is next to the bay holding machinery.",
      "C) The bay holding livestock is next to the bay holding fuel.",
      "D) The bay holding produce is next to the bay holding livestock.",
      "E) The bay holding textiles is next to the bay holding fuel."
    ],
    "raw_logic_programs": [
      "# Declarations\nbays = EnumSort([1, 2, 3, 4, 5, 6])\ncargo = EnumSort([fuel, grain, livestock, machinery, produce, textiles])\nholds = Function([bays] -> [cargo])\n\n# Constraints\nForAll([b:bays], Distinct([c:cargo], holds(b) == c)) ::: Each bay is holding a different one of exactly six types of cargo\nholds(grain) > holds(livestock) ::: The bay holding grain has a higher number than the bay holding livestock\nholds(livestock) > holds(textiles) ::: The bay holding livestock has a higher number than the bay holding textiles\nholds(produce) > holds(fuel) ::: The bay holding produce has a higher number than the bay holding fuel\nExists([b:bays], And(holds(b) == textiles, holds(b + 1) == produce)) ::: The bay holding textiles is next to the bay holding produce\n\n# Options\nQuestion ::: Which one of the following must be false?\nis_unsat(Exists([b:bays], And(holds(b) == fuel, holds(b + 1) == machinery))) ::: (A)\nis_unsat(Exists([b:bays], And(holds(b) == grain, holds(b + 1) == machinery))) ::: (B)\nis_unsat(Exists([b:bays], And(holds(b) == livestock, holds(b + 1) == fuel))) ::: (C)\nis_unsat(Exists([b:bays], And(holds(b) == produce, holds(b + 1) == livestock))) ::: (D)\nis_unsat(Exists([b:bays], And(holds(b) == textiles, holds(b + 1) == fuel))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200312_1-G_2_11",
    "context": "A loading dock consists of exactly six bays numbered 1 through 6 consecutively from one side of the dock to the other. Each bay is holding a different one of exactly six types of cargo—fuel, grain, livestock, machinery, produce, or textiles. The following apply: The bay holding grain has a higher number than the bay holding livestock. The bay holding livestock has a higher number than the bay holding textiles. The bay holding produce has a higher number than the bay holding fuel. The bay holding textiles is next to the bay holding produce.",
    "question": "If the bay holding produce is next to the bay holding livestock, then each of the following could be true EXCEPT:",
    "answer": "C",
    "options": [
      "A) Bay 2 is holding fuel.",
      "B) Bay 4 is holding produce.",
      "C) Bay 4 is holding textiles.",
      "D) Bay 5 is holding grain.",
      "E) Bay 5 is holding machinery."
    ],
    "raw_logic_programs": [
      "# Declarations\nbays = EnumSort([1, 2, 3, 4, 5, 6])\ncargo = EnumSort([fuel, grain, livestock, machinery, produce, textiles])\nholds = Function([bays] -> [cargo])\n\n# Constraints\nForAll([b:bays], Distinct([c:cargo], holds(b) == c)) ::: Each bay is holding a different one of exactly six types of cargo\nholds(grain) > holds(livestock) ::: The bay holding grain has a higher number than the bay holding livestock\nholds(livestock) > holds(textiles) ::: The bay holding livestock has a higher number than the bay holding textiles\nholds(produce) > holds(fuel) ::: The bay holding produce has a higher number than the bay holding fuel\nExists([b:bays], And(Abs(b - holds(textiles)) == 1, Abs(b - holds(produce)) == 1)) ::: The bay holding textiles is next to the bay holding produce\nExists([b:bays], And(Abs(b - holds(produce)) == 1, Abs(b - holds(livestock)) == 1)) ::: If the bay holding produce is next to the bay holding livestock\n\n# Options\nQuestion ::: If the bay holding produce is next to the bay holding livestock, then each of the following could be true EXCEPT:\nis_exception(is_sat(holds(2) == fuel)) ::: (A)\nis_exception(is_sat(holds(4) == produce)) ::: (B)\nis_exception(is_sat(holds(4) == textiles)) ::: (C)\nis_exception(is_sat(holds(5) == grain)) ::: (D)\nis_exception(is_sat(holds(5) == machinery)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200312_1-G_2_12",
    "context": "A loading dock consists of exactly six bays numbered 1 through 6 consecutively from one side of the dock to the other. Each bay is holding a different one of exactly six types of cargo—fuel, grain, livestock, machinery, produce, or textiles. The following apply: The bay holding grain has a higher number than the bay holding livestock. The bay holding livestock has a higher number than the bay holding textiles. The bay holding produce has a higher number than the bay holding fuel. The bay holding textiles is next to the bay holding produce.",
    "question": "If bay 4 is holding produce, then for exactly how many of the six bays is the type of cargo that bay is holding completely determined?",
    "answer": "C",
    "options": [
      "A) two",
      "B) three",
      "C) four",
      "D) five",
      "E) six"
    ],
    "raw_logic_programs": [
      "# Declarations\nbays = EnumSort([1, 2, 3, 4, 5, 6])\ncargo = EnumSort([fuel, grain, livestock, machinery, produce, textiles])\nholds = Function([bays] -> [cargo])\n\n# Constraints\nForAll([b:bays], Distinct([c:cargo], holds(b) == c)) ::: Each bay is holding a different one of exactly six types of cargo\nholds(grain) > holds(livestock) ::: The bay holding grain has a higher number than the bay holding livestock\nholds(livestock) > holds(textiles) ::: The bay holding livestock has a higher number than the bay holding textiles\nholds(produce) > holds(fuel) ::: The bay holding produce has a higher number than the bay holding fuel\nExists([b:bays], And(holds(b) == textiles, Or(b + 1 == produce, b - 1 == produce))) ::: The bay holding textiles is next to the bay holding produce\nholds(4) == produce ::: If bay 4 is holding produce\n\n# Options\nQuestion ::: If bay 4 is holding produce, then for exactly how many of the six bays is the type of cargo that bay is holding completely determined?\nis_determined(holds(1) == fuel) ::: 1\nis_determined(holds(2) == livestock) ::: 2\nis_determined(holds(3) == textiles) ::: 3\nis_determined(holds(4) == produce) ::: 4\nis_determined(holds(5) == grain) ::: 5\nis_determined(holds(6) == machinery) ::: 6\nCount([b:bays], is_determined(holds(b))) == 4 ::: (C)\n"
    ]
  },
  {
    "id": "ar_lsat_200312_1-G_3_13",
    "context": "A bakery makes exactly three kinds of cookie—oatmeal, peanut butter, and sugar. Exactly three batches of each kind of cookie are made each week (Monday through Friday) and each batch is made, from start to finish, on a single day. The following conditions apply: No two batches of the same kind of cookie are made on the same day. At least one batch of cookies is made on Monday. The second batch of oatmeal cookies is made on the same day as the first batch of peanut butter cookies. The second batch of sugar cookies is made on Thursday.",
    "question": "Which one of the following could be a complete and accurate list of the days on which the batches of each kind of cookie are made?",
    "answer": "A",
    "options": [
      "A) oatmeal: Monday, Wednesday, Thursday peanut butter: Wednesday, Thursday, Friday sugar: Monday, Thursday, Friday",
      "B) oatmeal: Monday, Tuesday, Thursday peanut butter: Tuesday, Wednesday, Thursday sugar: Monday, Wednesday, Thursday",
      "C) oatmeal: Tuesday, Wednesday, Thursday peanut butter: Wednesday, Thursday, Friday sugar: Tuesday, Thursday, Friday",
      "D) oatmeal: Monday, Tuesday, Thursday peanut butter: Monday, Wednesday, Thursday sugar: Monday, Thursday, Friday",
      "E) oatmeal: Monday, Thursday, Friday peanut butter: Tuesday, Wednesday, Thursday sugar: Monday, Thursday, Friday"
    ],
    "raw_logic_programs": [
      "# Declarations\ncookies = EnumSort([oatmeal, peanut_butter, sugar])\ndays = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday])\nbatches = EnumSort([1, 2, 3])\nmade = Function([cookies, batches] -> [days])\n\n# Constraints\nForAll([c:cookies], Distinct([b:batches], made(c, b))) ::: No two batches of the same kind of cookie are made on the same day\nExists([c:cookies, b:batches], made(c, b) == Monday) ::: At least one batch of cookies is made on Monday\nmade(oatmeal, 2) == made(peanut_butter, 1) ::: The second batch of oatmeal cookies is made on the same day as the first batch of peanut butter cookies\nmade(sugar, 2) == Thursday ::: The second batch of sugar cookies is made on Thursday\n\n# Options\nQuestion ::: Which one of the following could be a complete and accurate list of the days on which the batches of each kind of cookie are made?\nis_accurate_list(And(made(oatmeal, 1) == Monday, made(oatmeal, 2) == Wednesday, made(oatmeal, 3) == Thursday, made(peanut_butter, 1) == Wednesday, made(peanut_butter, 2) == Thursday, made(peanut_butter, 3) == Friday, made(sugar, 1) == Monday, made(sugar, 3) == Friday)) ::: (A)\nis_accurate_list(And(made(oatmeal, 1) == Monday, made(oatmeal, 2) == Tuesday, made(oatmeal, 3) == Thursday, made(peanut_butter, 1) == Tuesday, made(peanut_butter, 2) == Wednesday, made(peanut_butter, 3) == Thursday, made(sugar, 1) == Monday, made(sugar, 3) == Thursday)) ::: (B)\nis_accurate_list(And(made(oatmeal, 1) == Tuesday, made(oatmeal, 2) == Wednesday, made(oatmeal, 3) == Thursday, made(peanut_butter, 1) == Wednesday, made(peanut_butter, 2) == Thursday, made(peanut_butter, 3) == Friday, made(sugar, 1) == Tuesday, made(sugar, 3) == Friday)) ::: (C)\nis_accurate_list(And(made(oatmeal, 1) == Monday, made(oatmeal, 2) == Tuesday, made(oatmeal, 3) == Thursday, made(peanut_butter, 1) == Monday, made(peanut_butter, 2) == Wednesday, made(peanut_butter, 3) == Thursday, made(sugar, 1) == Monday, made(sugar, 3) == Friday)) ::: (D)\nis_accurate_list(And(made(oatmeal, 1) == Monday, made(oatmeal, 2) == Thursday, made(oatmeal, 3) == Friday, made(peanut_butter, 1) == Tuesday, made(peanut_butter, 2) == Wednesday, made(peanut_butter, 3) == Thursday, made(sugar, 1) == Monday, made(sugar, 3) == Friday)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200312_1-G_3_14",
    "context": "A bakery makes exactly three kinds of cookie—oatmeal, peanut butter, and sugar. Exactly three batches of each kind of cookie are made each week (Monday through Friday) and each batch is made, from start to finish, on a single day. The following conditions apply: No two batches of the same kind of cookie are made on the same day. At least one batch of cookies is made on Monday. The second batch of oatmeal cookies is made on the same day as the first batch of peanut butter cookies. The second batch of sugar cookies is made on Thursday.",
    "question": "How many of the days, Monday through Friday, are such that at most two batches of cookies could be made on that day?",
    "answer": "A",
    "options": [
      "A) one",
      "B) two",
      "C) three",
      "D) four",
      "E) five"
    ],
    "raw_logic_programs": [
      "# Declarations\ncookies = EnumSort([oatmeal, peanut_butter, sugar])\ndays = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday])\nbatches = EnumSort([1, 2, 3])\nmade = Function([cookies, batches, days] -> [bool])\n\n# Constraints\nForAll([c:cookies], Count([d:days], Count([b:batches], made(c, b, d)) == 1) == 3) ::: Exactly three batches of each kind of cookie are made each week\nForAll([c:cookies, d:days], Count([b:batches], made(c, b, d)) <= 1) ::: No two batches of the same kind of cookie are made on the same day\nExists([c:cookies, b:batches], made(c, b, Monday)) ::: At least one batch of cookies is made on Monday\nExists([b:batches], And(made(oatmeal, 2, b), made(peanut_butter, 1, b))) ::: The second batch of oatmeal cookies is made on the same day as the first batch of peanut butter cookies\nmade(sugar, 2, Thursday) ::: The second batch of sugar cookies is made on Thursday\n\n# Options\nQuestion ::: How many of the days, Monday through Friday, are such that at most two batches of cookies could be made on that day?\nis_valid(Count([d:days], Count([c:cookies, b:batches], made(c, b, d)) <= 2) == 1) ::: (A)\nis_valid(Count([d:days], Count([c:cookies, b:batches], made(c, b, d)) <= 2) == 2) ::: (B)\nis_valid(Count([d:days], Count([c:cookies, b:batches], made(c, b, d)) <= 2) == 3) ::: (C)\nis_valid(Count([d:days], Count([c:cookies, b:batches], made(c, b, d)) <= 2) == 4) ::: (D)\nis_valid(Count([d:days], Count([c:cookies, b:batches], made(c, b, d)) <= 2) == 5) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200312_1-G_3_15",
    "context": "A bakery makes exactly three kinds of cookie—oatmeal, peanut butter, and sugar. Exactly three batches of each kind of cookie are made each week (Monday through Friday) and each batch is made, from start to finish, on a single day. The following conditions apply: No two batches of the same kind of cookie are made on the same day. At least one batch of cookies is made on Monday. The second batch of oatmeal cookies is made on the same day as the first batch of peanut butter cookies. The second batch of sugar cookies is made on Thursday.",
    "question": "If the first batch of peanut butter cookies is made on Tuesday, then each of the following could be true EXCEPT:",
    "answer": "C",
    "options": [
      "A) Two different kinds of cookie have their first batch made on Monday.",
      "B) Two different kinds of cookie have their first batch made on Tuesday.",
      "C) Two different kinds of cookie have their second batch made on Wednesday.",
      "D) Two different kinds of cookie have their second batch made on Thursday.",
      "E) Two different kinds of cookie have their third batch made on Friday."
    ],
    "raw_logic_programs": [
      "# Declarations\ncookie_types = EnumSort([oatmeal, peanut_butter, sugar])\ndays = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday])\nbatches = EnumSort([1, 2, 3])\nmade = Function([cookie_types, batches, days] -> [bool])\n\n# Constraints\nForAll([t:cookie_types], Count([d:days], made(t, 1, d)) == 1) ::: No two batches of the same kind of cookie are made on the same day\nForAll([t:cookie_types], Count([d:days], made(t, 2, d)) == 1)\nForAll([t:cookie_types], Count([d:days], made(t, 3, d)) == 1)\nExists([t:cookie_types], made(t, 1, Monday)) ::: At least one batch of cookies is made on Monday\nmade(oatmeal, 2, Tuesday) == made(peanut_butter, 1, Tuesday) ::: The second batch of oatmeal cookies is made on the same day as the first batch of peanut butter cookies\nmade(sugar, 2, Thursday) ::: The second batch of sugar cookies is made on Thursday\nmade(peanut_butter, 1, Tuesday) ::: If the first batch of peanut butter cookies is made on Tuesday\n\n# Options\nQuestion ::: If the first batch of peanut butter cookies is made on Tuesday, then each of the following could be true EXCEPT:\nis_exception(And(Exists([t1:cookie_types], made(t1, 1, Monday)), Exists([t2:cookie_types, t2 != t1], made(t2, 1, Monday)))) ::: (A)\nis_exception(And(Exists([t1:cookie_types], made(t1, 1, Tuesday)), Exists([t2:cookie_types, t2 != t1], made(t2, 1, Tuesday)))) ::: (B)\nis_exception(And(Exists([t1:cookie_types], made(t1, 2, Wednesday)), Exists([t2:cookie_types, t2 != t1], made(t2, 2, Wednesday)))) ::: (C)\nis_exception(And(Exists([t1:cookie_types], made(t1, 2, Thursday)), Exists([t2:cookie_types, t2 != t1], made(t2, 2, Thursday)))) ::: (D)\nis_exception(And(Exists([t1:cookie_types], made(t1, 3, Friday)), Exists([t2:cookie_types, t2 != t1], made(t2, 3, Friday)))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200312_1-G_3_16",
    "context": "A bakery makes exactly three kinds of cookie—oatmeal, peanut butter, and sugar. Exactly three batches of each kind of cookie are made each week (Monday through Friday) and each batch is made, from start to finish, on a single day. The following conditions apply: No two batches of the same kind of cookie are made on the same day. At least one batch of cookies is made on Monday. The second batch of oatmeal cookies is made on the same day as the first batch of peanut butter cookies. The second batch of sugar cookies is made on Thursday.",
    "question": "If no batch of cookies is made on Wednesday, then which one of the following must be true?",
    "answer": "D",
    "options": [
      "A) Exactly three batches of cookies are made on Tuesday.",
      "B) Exactly three batches of cookies are made on Friday.",
      "C) At least two batches of cookies are made on Monday.",
      "D) At least two batches of cookies are made on Thursday.",
      "E) Fewer batches of cookies are made on Monday than on Tuesday."
    ],
    "raw_logic_programs": [
      "# Declarations\ncookies = EnumSort([oatmeal, peanut_butter, sugar])\ndays = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday])\nbatches = EnumSort([1, 2, 3])\nmade = Function([cookies, batches, days] -> [bool])\n\n# Constraints\nForAll([c:cookies], Count([d:days], Count([b:batches], made(c, b, d)) == 1) == 3) ::: Exactly three batches of each kind of cookie are made each week\nForAll([c:cookies, d:days], Count([b:batches], made(c, b, d)) <= 1) ::: No two batches of the same kind of cookie are made on the same day\nExists([c:cookies, b:batches], made(c, b, Monday)) ::: At least one batch of cookies is made on Monday\nExists([b:batches], And(made(oatmeal, 2, b), made(peanut_butter, 1, b))) ::: The second batch of oatmeal cookies is made on the same day as the first batch of peanut butter cookies\nmade(sugar, 2, Thursday) ::: The second batch of sugar cookies is made on Thursday\n\n# Options\nQuestion ::: If no batch of cookies is made on Wednesday, then which one of the following must be true?\nis_valid(And(Not(Exists([c:cookies, b:batches], made(c, b, Wednesday))), Count([c:cookies, b:batches], made(c, b, Tuesday)) == 3)) ::: (A)\nis_valid(And(Not(Exists([c:cookies, b:batches], made(c, b, Wednesday))), Count([c:cookies, b:batches], made(c, b, Friday)) == 3)) ::: (B)\nis_valid(And(Not(Exists([c:cookies, b:batches], made(c, b, Wednesday))), Count([c:cookies, b:batches], made(c, b, Monday)) >= 2)) ::: (C)\nis_valid(And(Not(Exists([c:cookies, b:batches], made(c, b, Wednesday))), Count([c:cookies, b:batches], made(c, b, Thursday)) >= 2)) ::: (D)\nis_valid(And(Not(Exists([c:cookies, b:batches], made(c, b, Wednesday))), Count([c:cookies, b:batches], made(c, b, Monday)) < Count([c:cookies, b:batches], made(c, b, Tuesday)))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200312_1-G_3_17",
    "context": "A bakery makes exactly three kinds of cookie—oatmeal, peanut butter, and sugar. Exactly three batches of each kind of cookie are made each week (Monday through Friday) and each batch is made, from start to finish, on a single day. The following conditions apply: No two batches of the same kind of cookie are made on the same day. At least one batch of cookies is made on Monday. The second batch of oatmeal cookies is made on the same day as the first batch of peanut butter cookies. The second batch of sugar cookies is made on Thursday.",
    "question": "If the number of batches made on Friday is exactly one, then which one of the following could be true?",
    "answer": "A",
    "options": [
      "A) The first batch of sugar cookies is made on Monday.",
      "B) The first batch of oatmeal cookies is made on Tuesday.",
      "C) The third batch of oatmeal cookies is made on Friday.",
      "D) The first batch of peanut butter cookies is made on Wednesday.",
      "E) The second batch of peanut butter cookies is made on Tuesday."
    ],
    "raw_logic_programs": [
      "# Declarations\ncookies = EnumSort([oatmeal, peanut_butter, sugar])\ndays = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday])\nbatches = EnumSort([1, 2, 3])\nmade = Function([cookies, batches, days] -> [bool])\n\n# Constraints\nForAll([c:cookies], Count([d:days], made(c, 1, d)) == 1) ::: No two batches of the same kind of cookie are made on the same day\nForAll([c:cookies], Count([d:days], made(c, 2, d)) == 1)\nForAll([c:cookies], Count([d:days], made(c, 3, d)) == 1)\nExists([c:cookies, d:days], made(c, 1, d)) ::: At least one batch of cookies is made on Monday\nExists([d:days], And(made(oatmeal, 2, d), made(peanut_butter, 1, d))) ::: The second batch of oatmeal cookies is made on the same day as the first batch of peanut butter cookies\nmade(sugar, 2, Thursday) ::: The second batch of sugar cookies is made on Thursday\nCount([c:cookies, b:batches], made(c, b, Friday)) == 1 ::: If the number of batches made on Friday is exactly one\n\n# Options\nQuestion ::: If the number of batches made on Friday is exactly one, then which one of the following could be true?\nis_sat(made(sugar, 1, Monday)) ::: (A)\nis_sat(made(oatmeal, 1, Tuesday)) ::: (B)\nis_sat(made(oatmeal, 3, Friday)) ::: (C)\nis_sat(made(peanut_butter, 1, Wednesday)) ::: (D)\nis_sat(made(peanut_butter, 2, Tuesday)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200312_1-G_3_18",
    "context": "A bakery makes exactly three kinds of cookie—oatmeal, peanut butter, and sugar. Exactly three batches of each kind of cookie are made each week (Monday through Friday) and each batch is made, from start to finish, on a single day. The following conditions apply: No two batches of the same kind of cookie are made on the same day. At least one batch of cookies is made on Monday. The second batch of oatmeal cookies is made on the same day as the first batch of peanut butter cookies. The second batch of sugar cookies is made on Thursday.",
    "question": "If one kind of cookie's first batch is made on the same day as another kind of cookie's third batch, then which one of the following could be false?",
    "answer": "E",
    "options": [
      "A) At least one batch of cookies is made on each of the five days.",
      "B) At least two batches of cookies are made on Wednesday.",
      "C) Exactly one batch of cookies is made on Monday.",
      "D) Exactly two batches of cookies are made on Tuesday.",
      "E) Exactly one batch of cookies is made on Friday."
    ],
    "raw_logic_programs": [
      "# Declarations\ncookies = EnumSort([oatmeal, peanut_butter, sugar])\ndays = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday])\nbatches = EnumSort([1, 2, 3])\nmade = Function([cookies, batches, days] -> [bool])\n\n# Constraints\nForAll([c:cookies], Count([d:days], Count([b:batches], made(c, b, d)) == 1) == 3) ::: Exactly three batches of each kind of cookie are made each week\nForAll([c:cookies, d:days], Count([b:batches], made(c, b, d)) <= 1) ::: No two batches of the same kind of cookie are made on the same day\nExists([c:cookies, b:batches], made(c, b, Monday)) ::: At least one batch of cookies is made on Monday\nExists([b:batches], And(made(oatmeal, 2, b), made(peanut_butter, 1, b))) ::: The second batch of oatmeal cookies is made on the same day as the first batch of peanut butter cookies\nmade(sugar, 2, Thursday) ::: The second batch of sugar cookies is made on Thursday\n\n# Options\nQuestion ::: If one kind of cookie's first batch is made on the same day as another kind of cookie's third batch, then which one of the following could be false?\nis_unsat(ForAll([d:days], Exists([c:cookies, b:batches], made(c, b, d)))) ::: (A)\nis_unsat(Count([c:cookies, b:batches], made(c, b, Wednesday)) >= 2) ::: (B)\nis_unsat(Count([c:cookies, b:batches], made(c, b, Monday)) == 1) ::: (C)\nis_unsat(Count([c:cookies, b:batches], made(c, b, Tuesday)) == 2) ::: (D)\nis_unsat(Count([c:cookies, b:batches], made(c, b, Friday)) == 1) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200312_1-G_4_19",
    "context": "For the school paper, five students—Jiang, Kramer, Lopez, Megregian, and O'Neill—each review one or more of exactly three plays: Sunset, Tamerlane, and Undulation, but do not review any other plays. The following conditions must apply: Kramer and Lopez each review fewer of the plays than Megregian. Neither Lopez nor Megregian reviews any play Jiang reviews. Kramer and O'Neill both review Tamerlane. Exactly two of the students review exactly the same play or plays as each other.",
    "question": "Which one of the following could be an accurate and complete list of the students who review only Sunset?",
    "answer": "A",
    "options": [
      "A) Lopez",
      "B) O'Neill",
      "C) Jiang, Lopez",
      "D) Kramer, O'Neill",
      "E) Lopez, Megregian"
    ],
    "raw_logic_programs": [
      "# Declarations\nstudents = EnumSort([Jiang, Kramer, Lopez, Megregian, O'Neill])\nplays = EnumSort([Sunset, Tamerlane, Undulation])\nreviews = Function([students, plays] -> [bool])\n\n# Constraints\nForAll([s:students], Count([p:plays], reviews(s, p)) >= 1) ::: each student reviews one or more of exactly three plays\nAnd(Count([p:plays], reviews(Kramer, p)) < Count([p:plays], reviews(Megregian, p)), Count([p:plays], reviews(Lopez, p)) < Count([p:plays], reviews(Megregian, p))) ::: Kramer and Lopez each review fewer of the plays than Megregian\nForAll([p:plays], Implies(reviews(Jiang, p), Not(reviews(Lopez, p)))) ::: Neither Lopez nor Megregian reviews any play Jiang reviews\nForAll([p:plays], Implies(reviews(Jiang, p), Not(reviews(Megregian, p))))\nAnd(reviews(Kramer, Tamerlane), reviews(O'Neill, Tamerlane)) ::: Kramer and O'Neill both review Tamerlane\nExists([s1:students, s2:students], And(s1 != s2, ForAll([p:plays], reviews(s1, p) == reviews(s2, p)))) ::: Exactly two of the students review exactly the same play or plays as each other\n\n# Options\nQuestion ::: Which one of the following could be an accurate and complete list of the students who review only Sunset?\nis_sat(And(reviews(Lopez, Sunset), Not(reviews(Lopez, Tamerlane)), Not(reviews(Lopez, Undulation)))) ::: (A)\nis_sat(And(reviews(O'Neill, Sunset), Not(reviews(O'Neill, Tamerlane)), Not(reviews(O'Neill, Undulation)))) ::: (B)\nis_sat(And(reviews(Jiang, Sunset), Not(reviews(Jiang, Tamerlane)), Not(reviews(Jiang, Undulation)), reviews(Lopez, Sunset), Not(reviews(Lopez, Tamerlane)), Not(reviews(Lopez, Undulation)))) ::: (C)\nis_sat(And(reviews(Kramer, Sunset), Not(reviews(Kramer, Tamerlane)), Not(reviews(Kramer, Undulation)), reviews(O'Neill, Sunset), Not(reviews(O'Neill, Tamerlane)), Not(reviews(O'Neill, Undulation)))) ::: (D)\nis_sat(And(reviews(Lopez, Sunset), Not(reviews(Lopez, Tamerlane)), Not(reviews(Lopez, Undulation)), reviews(Megregian, Sunset), Not(reviews(Megregian, Tamerlane)), Not(reviews(Megregian, Undulation)))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200312_1-G_4_20",
    "context": "For the school paper, five students—Jiang, Kramer, Lopez, Megregian, and O'Neill—each review one or more of exactly three plays: Sunset, Tamerlane, and Undulation, but do not review any other plays. The following conditions must apply: Kramer and Lopez each review fewer of the plays than Megregian. Neither Lopez nor Megregian reviews any play Jiang reviews. Kramer and O'Neill both review Tamerlane. Exactly two of the students review exactly the same play or plays as each other.",
    "question": "Which one of the following must be true?",
    "answer": "B",
    "options": [
      "A) Jiang reviews more of the plays than Lopez does.",
      "B) Megregian reviews more of the plays than Jiang does.",
      "C) Megregian reviews more of the plays than O'Neill does.",
      "D) O'Neill reviews more of the plays than Jiang does.",
      "E) O'Neill reviews more of the plays than Kramer does."
    ],
    "raw_logic_programs": [
      "# Declarations\nstudents = EnumSort([Jiang, Kramer, Lopez, Megregian, O'Neill])\nplays = EnumSort([Sunset, Tamerlane, Undulation])\nreviews = Function([students, plays] -> [bool])\n\n# Constraints\nForAll([s:students], Count([p:plays], reviews(s, p)) >= 1) ::: each student reviews one or more of exactly three plays\nAnd(Count([p:plays], reviews(Kramer, p)) < Count([p:plays], reviews(Megregian, p)), Count([p:plays], reviews(Lopez, p)) < Count([p:plays], reviews(Megregian, p))) ::: Kramer and Lopez each review fewer of the plays than Megregian\nForAll([p:plays], Implies(reviews(Jiang, p), Not(reviews(Lopez, p)))) ::: Neither Lopez nor Megregian reviews any play Jiang reviews\nForAll([p:plays], Implies(reviews(Jiang, p), Not(reviews(Megregian, p))))\nAnd(reviews(Kramer, Tamerlane), reviews(O'Neill, Tamerlane)) ::: Kramer and O'Neill both review Tamerlane\nExists([s1:students, s2:students], And(s1 != s2, ForAll([p:plays], reviews(s1, p) == reviews(s2, p)))) ::: Exactly two of the students review exactly the same play or plays as each other\n\n# Options\nQuestion ::: Which one of the following must be true?\nis_sat(Count([p:plays], reviews(Jiang, p)) > Count([p:plays], reviews(Lopez, p))) ::: (A)\nis_sat(Count([p:plays], reviews(Megregian, p)) > Count([p:plays], reviews(Jiang, p))) ::: (B)\nis_sat(Count([p:plays], reviews(Megregian, p)) > Count([p:plays], reviews(O'Neill, p))) ::: (C)\nis_sat(Count([p:plays], reviews(O'Neill, p)) > Count([p:plays], reviews(Jiang, p))) ::: (D)\nis_sat(Count([p:plays], reviews(O'Neill, p)) > Count([p:plays], reviews(Kramer, p))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200312_1-G_4_21",
    "context": "For the school paper, five students—Jiang, Kramer, Lopez, Megregian, and O'Neill—each review one or more of exactly three plays: Sunset, Tamerlane, and Undulation, but do not review any other plays. The following conditions must apply: Kramer and Lopez each review fewer of the plays than Megregian. Neither Lopez nor Megregian reviews any play Jiang reviews. Kramer and O'Neill both review Tamerlane. Exactly two of the students review exactly the same play or plays as each other.",
    "question": "If exactly three of the students review Undulation, which one of the following could be true?",
    "answer": "E",
    "options": [
      "A) Megregian does not review Undulation.",
      "B) O'Neill does not review Undulation.",
      "C) Jiang reviews Undulation.",
      "D) Lopez reviews Tamerlane.",
      "E) O'Neill reviews Sunset."
    ],
    "raw_logic_programs": [
      "# Declarations\nstudents = EnumSort([Jiang, Kramer, Lopez, Megregian, O'Neill])\nplays = EnumSort([Sunset, Tamerlane, Undulation])\nreviews = Function([students, plays] -> [bool])\n\n# Constraints\nForAll([s:students], Count([p:plays], reviews(s, p)) >= 1) ::: each student reviews one or more of exactly three plays\nAnd(Count([p:plays], reviews(Kramer, p)) < Count([p:plays], reviews(Megregian, p)), Count([p:plays], reviews(Lopez, p)) < Count([p:plays], reviews(Megregian, p))) ::: Kramer and Lopez each review fewer of the plays than Megregian\nForAll([p:plays], Implies(reviews(Jiang, p), Not(reviews(Lopez, p)))) ::: Neither Lopez nor Megregian reviews any play Jiang reviews\nForAll([p:plays], Implies(reviews(Jiang, p), Not(reviews(Megregian, p))))\nAnd(reviews(Kramer, Tamerlane), reviews(O'Neill, Tamerlane)) ::: Kramer and O'Neill both review Tamerlane\nCount([s1:students, s2:students], And(s1 != s2, ForAll([p:plays], reviews(s1, p) == reviews(s2, p)))) == 2 ::: Exactly two of the students review exactly the same play or plays as each other\nCount([s:students], reviews(s, Undulation)) == 3 ::: exactly three of the students review Undulation\n\n# Options\nQuestion ::: If exactly three of the students review Undulation, which one of the following could be true?\nis_sat(Not(reviews(Megregian, Undulation))) ::: (A)\nis_sat(Not(reviews(O'Neill, Undulation))) ::: (B)\nis_sat(reviews(Jiang, Undulation)) ::: (C)\nis_sat(reviews(Lopez, Tamerlane)) ::: (D)\nis_sat(reviews(O'Neill, Sunset)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200312_1-G_4_22",
    "context": "For the school paper, five students—Jiang, Kramer, Lopez, Megregian, and O'Neill—each review one or more of exactly three plays: Sunset, Tamerlane, and Undulation, but do not review any other plays. The following conditions must apply: Kramer and Lopez each review fewer of the plays than Megregian. Neither Lopez nor Megregian reviews any play Jiang reviews. Kramer and O'Neill both review Tamerlane. Exactly two of the students review exactly the same play or plays as each other.",
    "question": "Which one of the following could be an accurate and complete list of the students who review Tamerlane?",
    "answer": "D",
    "options": [
      "A) Jiang, Kramer",
      "B) Kramer, O'Neill",
      "C) Kramer, Lopez, O'Neill",
      "D) Kramer, Megregian, O'Neill",
      "E) Lopez, Megregian, O'Neill"
    ],
    "raw_logic_programs": [
      "# Declarations\nstudents = EnumSort([Jiang, Kramer, Lopez, Megregian, O'Neill])\nplays = EnumSort([Sunset, Tamerlane, Undulation])\nreviews = Function([students, plays] -> [bool])\n\n# Constraints\nForAll([s:students], Count([p:plays], reviews(s, p)) >= 1) ::: each student reviews one or more of exactly three plays\nAnd(Count([p:plays], reviews(Kramer, p)) < Count([p:plays], reviews(Megregian, p)), Count([p:plays], reviews(Lopez, p)) < Count([p:plays], reviews(Megregian, p))) ::: Kramer and Lopez each review fewer of the plays than Megregian\nForAll([p:plays], Implies(reviews(Jiang, p), Not(reviews(Lopez, p)))) ::: Neither Lopez nor Megregian reviews any play Jiang reviews\nForAll([p:plays], Implies(reviews(Jiang, p), Not(reviews(Megregian, p))))\nAnd(reviews(Kramer, Tamerlane), reviews(O'Neill, Tamerlane)) ::: Kramer and O'Neill both review Tamerlane\nCount([s1:students, s2:students], And(s1 != s2, ForAll([p:plays], reviews(s1, p) == reviews(s2, p)))) == 2 ::: Exactly two of the students review exactly the same play or plays as each other\n\n# Options\nQuestion ::: Which one of the following could be an accurate and complete list of the students who review Tamerlane?\nis_sat(And(reviews(Jiang, Tamerlane), reviews(Kramer, Tamerlane), Not(reviews(Lopez, Tamerlane)), Not(reviews(Megregian, Tamerlane)), Not(reviews(O'Neill, Tamerlane)))) ::: (A)\nis_sat(And(Not(reviews(Jiang, Tamerlane)), reviews(Kramer, Tamerlane), Not(reviews(Lopez, Tamerlane)), Not(reviews(Megregian, Tamerlane)), reviews(O'Neill, Tamerlane))) ::: (B)\nis_sat(And(Not(reviews(Jiang, Tamerlane)), reviews(Kramer, Tamerlane), reviews(Lopez, Tamerlane), Not(reviews(Megregian, Tamerlane)), reviews(O'Neill, Tamerlane))) ::: (C)\nis_sat(And(Not(reviews(Jiang, Tamerlane)), reviews(Kramer, Tamerlane), Not(reviews(Lopez, Tamerlane)), reviews(Megregian, Tamerlane), reviews(O'Neill, Tamerlane))) ::: (D)\nis_sat(And(Not(reviews(Jiang, Tamerlane)), Not(reviews(Kramer, Tamerlane)), reviews(Lopez, Tamerlane), reviews(Megregian, Tamerlane), reviews(O'Neill, Tamerlane))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_200312_1-G_4_23",
    "context": "For the school paper, five students—Jiang, Kramer, Lopez, Megregian, and O'Neill—each review one or more of exactly three plays: Sunset, Tamerlane, and Undulation, but do not review any other plays. The following conditions must apply: Kramer and Lopez each review fewer of the plays than Megregian. Neither Lopez nor Megregian reviews any play Jiang reviews. Kramer and O'Neill both review Tamerlane. Exactly two of the students review exactly the same play or plays as each other.",
    "question": "If Jiang does not review Tamerlane, then which one of the following must be true?",
    "answer": "D",
    "options": [
      "A) Jiang reviews Sunset.",
      "B) Lopez reviews Undulation.",
      "C) Megregian reviews Sunset.",
      "D) Megregian reviews Tamerlane.",
      "E) O'Neill reviews Undulation."
    ],
    "raw_logic_programs": [
      "# Declarations\nstudents = EnumSort([Jiang, Kramer, Lopez, Megregian, O'Neill])\nplays = EnumSort([Sunset, Tamerlane, Undulation])\nreviews = Function([students, plays] -> [bool])\n\n# Constraints\nForAll([s:students], Count([p:plays], reviews(s, p)) >= 1) ::: each student reviews one or more of exactly three plays\nAnd(Count([p:plays], reviews(Kramer, p)) < Count([p:plays], reviews(Megregian, p)), Count([p:plays], reviews(Lopez, p)) < Count([p:plays], reviews(Megregian, p))) ::: Kramer and Lopez each review fewer of the plays than Megregian\nForAll([p:plays], Implies(reviews(Jiang, p), Not(reviews(Lopez, p)))) ::: Neither Lopez nor Megregian reviews any play Jiang reviews\nForAll([p:plays], Implies(reviews(Jiang, p), Not(reviews(Megregian, p))))\nAnd(reviews(Kramer, Tamerlane), reviews(O'Neill, Tamerlane)) ::: Kramer and O'Neill both review Tamerlane\nExists([s1:students, s2:students], And(s1 != s2, ForAll([p:plays], reviews(s1, p) == reviews(s2, p)))) ::: Exactly two of the students review exactly the same play or plays as each other\nNot(reviews(Jiang, Tamerlane)) ::: If Jiang does not review Tamerlane\n\n# Options\nQuestion ::: If Jiang does not review Tamerlane, then which one of the following must be true?\nis_valid(reviews(Jiang, Sunset)) ::: (A)\nis_valid(reviews(Lopez, Undulation)) ::: (B)\nis_valid(reviews(Megregian, Sunset)) ::: (C)\nis_valid(reviews(Megregian, Tamerlane)) ::: (D)\nis_valid(reviews(O'Neill, Undulation)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201110_2-G_1_1",
    "context": "An administrator must assign parking spaces to six new employees: Robertson, Souza, Togowa, Vaughn, Xu, and Young. Each of the six employees must be assigned one of the following parking spaces: #1, #2, #3, #4, #5, or #6. No two employees can be assigned the same parking space. The following rules govern the assignment of parking spaces: Young must be assigned a higher-numbered parking space than Togowa. Xu must be assigned a higher-numbered parking space than Souza. Robertson must be assigned a higher-numbered parking space than Young. Robertson must be assigned parking space #1, #2, #3, or #4.",
    "question": "Which one of the following could be the assignment of parking spaces to the new employees?",
    "answer": "E",
    "options": [
      "A) #1: Young; #2: Souza; #3: Vaughn; #4: Robertson; #5: Togowa; #6: Xu",
      "B) #1: Vaughn; #2: Togowa; #3: Young; #4: Souza; #5: Robertson; #6: Xu",
      "C) #1: Togowa; #2: Young; #3: Xu; #4: Robertson; #5: Souza; #6: Vaughn",
      "D) #1: Togowa; #2: Robertson; #3: Young; #4: Souza; #5: Vaughn; #6: Xu",
      "E) #1: Souza; #2: Togowa; #3: Young; #4: Robertson; #5: Xu; #6: Vaughn"
    ],
    "raw_logic_programs": [
      "# Declarations\nemployees = EnumSort([Robertson, Souza, Togowa, Vaughn, Xu, Young])\nspaces = EnumSort([1, 2, 3, 4, 5, 6])\nassigned = Function([employees] -> [spaces])\n\n# Constraints\nForAll([e:employees], Exists([s:spaces], assigned(e) == s)) ::: Each of the six employees must be assigned one of the following parking spaces\nDistinct([e:employees], assigned(e)) ::: No two employees can be assigned the same parking space\nassigned(Young) > assigned(Togowa) ::: Young must be assigned a higher-numbered parking space than Togowa\nassigned(Xu) > assigned(Souza) ::: Xu must be assigned a higher-numbered parking space than Souza\nassigned(Robertson) > assigned(Young) ::: Robertson must be assigned a higher-numbered parking space than Young\nOr(assigned(Robertson) == 1, assigned(Robertson) == 2, assigned(Robertson) == 3, assigned(Robertson) == 4) ::: Robertson must be assigned parking space #1, #2, #3, or #4\n\n# Options\nQuestion ::: Which one of the following could be the assignment of parking spaces to the new employees?\nis_sat(And(assigned(Young) == 1, assigned(Souza) == 2, assigned(Vaughn) == 3, assigned(Robertson) == 4, assigned(Togowa) == 5, assigned(Xu) == 6)) ::: (A)\nis_sat(And(assigned(Vaughn) == 1, assigned(Togowa) == 2, assigned(Young) == 3, assigned(Souza) == 4, assigned(Robertson) == 5, assigned(Xu) == 6)) ::: (B)\nis_sat(And(assigned(Togowa) == 1, assigned(Young) == 2, assigned(Xu) == 3, assigned(Robertson) == 4, assigned(Souza) == 5, assigned(Vaughn) == 6)) ::: (C)\nis_sat(And(assigned(Togowa) == 1, assigned(Robertson) == 2, assigned(Young) == 3, assigned(Souza) == 4, assigned(Vaughn) == 5, assigned(Xu) == 6)) ::: (D)\nis_sat(And(assigned(Souza) == 1, assigned(Togowa) == 2, assigned(Young) == 3, assigned(Robertson) == 4, assigned(Xu) == 5, assigned(Vaughn) == 6)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201110_2-G_1_2",
    "context": "An administrator must assign parking spaces to six new employees: Robertson, Souza, Togowa, Vaughn, Xu, and Young. Each of the six employees must be assigned one of the following parking spaces: #1, #2, #3, #4, #5, or #6. No two employees can be assigned the same parking space. The following rules govern the assignment of parking spaces: Young must be assigned a higher-numbered parking space than Togowa. Xu must be assigned a higher-numbered parking space than Souza. Robertson must be assigned a higher-numbered parking space than Young. Robertson must be assigned parking space #1, #2, #3, or #4.",
    "question": "If Togowa is assigned a higher-numbered parking space than Souza, then which one of the following could be true?",
    "answer": "B",
    "options": [
      "A) Young is assigned parking space #2.",
      "B) Vaughn is assigned parking space #5.",
      "C) Togowa is assigned parking space #3.",
      "D) Souza is assigned parking space #2.",
      "E) Robertson is assigned parking space #3."
    ],
    "raw_logic_programs": [
      "# Declarations\nemployees = EnumSort([Robertson, Souza, Togowa, Vaughn, Xu, Young])\nspaces = EnumSort([1, 2, 3, 4, 5, 6])\nassigned = Function([employees] -> [spaces])\n\n# Constraints\nForAll([e:employees], Exists([s:spaces], assigned(e) == s)) ::: Each of the six employees must be assigned one of the following parking spaces\nDistinct([e:employees], assigned(e)) ::: No two employees can be assigned the same parking space\nassigned(Young) > assigned(Togowa) ::: Young must be assigned a higher-numbered parking space than Togowa\nassigned(Xu) > assigned(Souza) ::: Xu must be assigned a higher-numbered parking space than Souza\nassigned(Robertson) > assigned(Young) ::: Robertson must be assigned a higher-numbered parking space than Young\nOr(assigned(Robertson) == 1, assigned(Robertson) == 2, assigned(Robertson) == 3, assigned(Robertson) == 4) ::: Robertson must be assigned parking space #1, #2, #3, or #4\n\n# Options\nQuestion ::: If Togowa is assigned a higher-numbered parking space than Souza, then which one of the following could be true?\nis_sat(And(assigned(Togowa) > assigned(Souza), assigned(Young) == 2)) ::: (A)\nis_sat(And(assigned(Togowa) > assigned(Souza), assigned(Vaughn) == 5)) ::: (B)\nis_sat(And(assigned(Togowa) > assigned(Souza), assigned(Togowa) == 3)) ::: (C)\nis_sat(And(assigned(Togowa) > assigned(Souza), assigned(Souza) == 2)) ::: (D)\nis_sat(And(assigned(Togowa) > assigned(Souza), assigned(Robertson) == 3)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201110_2-G_1_3",
    "context": "An administrator must assign parking spaces to six new employees: Robertson, Souza, Togowa, Vaughn, Xu, and Young. Each of the six employees must be assigned one of the following parking spaces: #1, #2, #3, #4, #5, or #6. No two employees can be assigned the same parking space. The following rules govern the assignment of parking spaces: Young must be assigned a higher-numbered parking space than Togowa. Xu must be assigned a higher-numbered parking space than Souza. Robertson must be assigned a higher-numbered parking space than Young. Robertson must be assigned parking space #1, #2, #3, or #4.",
    "question": "The assignment of parking spaces to each of the new employees is fully and uniquely determined if which one of the following is true?",
    "answer": "C",
    "options": [
      "A) Souza is assigned parking space #1.",
      "B) Young is assigned parking space #2.",
      "C) Vaughn is assigned parking space #3.",
      "D) Robertson is assigned parking space #4.",
      "E) Xu is assigned parking space #5."
    ],
    "raw_logic_programs": [
      "# Declarations\nemployees = EnumSort([Robertson, Souza, Togowa, Vaughn, Xu, Young])\nspaces = EnumSort([1, 2, 3, 4, 5, 6])\nassigned = Function([employees] -> [spaces])\n\n# Constraints\nForAll([e:employees], Exists([s:spaces], assigned(e) == s)) ::: Each of the six employees must be assigned one of the following parking spaces\nDistinct([e:employees], assigned(e)) ::: No two employees can be assigned the same parking space\nassigned(Young) > assigned(Togowa) ::: Young must be assigned a higher-numbered parking space than Togowa\nassigned(Xu) > assigned(Souza) ::: Xu must be assigned a higher-numbered parking space than Souza\nassigned(Robertson) > assigned(Young) ::: Robertson must be assigned a higher-numbered parking space than Young\nOr(assigned(Robertson) == 1, assigned(Robertson) == 2, assigned(Robertson) == 3, assigned(Robertson) == 4) ::: Robertson must be assigned parking space #1, #2, #3, or #4\n\n# Options\nQuestion ::: The assignment of parking spaces to each of the new employees is fully and uniquely determined if which one of the following is true?\nis_unique(assigned(Souza) == 1) ::: (A)\nis_unique(assigned(Young) == 2) ::: (B)\nis_unique(assigned(Vaughn) == 3) ::: (C)\nis_unique(assigned(Robertson) == 4) ::: (D)\nis_unique(assigned(Xu) == 5) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201110_2-G_1_4",
    "context": "An administrator must assign parking spaces to six new employees: Robertson, Souza, Togowa, Vaughn, Xu, and Young. Each of the six employees must be assigned one of the following parking spaces: #1, #2, #3, #4, #5, or #6. No two employees can be assigned the same parking space. The following rules govern the assignment of parking spaces: Young must be assigned a higher-numbered parking space than Togowa. Xu must be assigned a higher-numbered parking space than Souza. Robertson must be assigned a higher-numbered parking space than Young. Robertson must be assigned parking space #1, #2, #3, or #4.",
    "question": "For how many of the six new employees is the assignment of a parking space limited to one of only two possible spaces?",
    "answer": "D",
    "options": [
      "A) none",
      "B) two",
      "C) three",
      "D) four",
      "E) five"
    ],
    "raw_logic_programs": [
      "# Declarations\nemployees = EnumSort([Robertson, Souza, Togowa, Vaughn, Xu, Young])\nspaces = EnumSort([1, 2, 3, 4, 5, 6])\nassigned = Function([employees] -> [spaces])\n\n# Constraints\nForAll([e:employees], Exists([s:spaces], assigned(e) == s)) ::: Each of the six employees must be assigned one of the following parking spaces\nDistinct([e:employees], assigned(e)) ::: No two employees can be assigned the same parking space\nassigned(Young) > assigned(Togowa) ::: Young must be assigned a higher-numbered parking space than Togowa\nassigned(Xu) > assigned(Souza) ::: Xu must be assigned a higher-numbered parking space than Souza\nassigned(Robertson) > assigned(Young) ::: Robertson must be assigned a higher-numbered parking space than Young\nOr(assigned(Robertson) == 1, Or(assigned(Robertson) == 2, Or(assigned(Robertson) == 3, assigned(Robertson) == 4))) ::: Robertson must be assigned parking space #1, #2, #3, or #4\n\n# Options\nQuestion ::: For how many of the six new employees is the assignment of a parking space limited to one of only two possible spaces?\nis_valid(Count([e:employees], Count([s:spaces], assigned(e) == s) == 2) == 0) ::: (A)\nis_valid(Count([e:employees], Count([s:spaces], assigned(e) == s) == 2) == 2) ::: (B)\nis_valid(Count([e:employees], Count([s:spaces], assigned(e) == s) == 2) == 3) ::: (C)\nis_valid(Count([e:employees], Count([s:spaces], assigned(e) == s) == 2) == 4) ::: (D)\nis_valid(Count([e:employees], Count([s:spaces], assigned(e) == s) == 2) == 5) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201110_2-G_1_5",
    "context": "An administrator must assign parking spaces to six new employees: Robertson, Souza, Togowa, Vaughn, Xu, and Young. Each of the six employees must be assigned one of the following parking spaces: #1, #2, #3, #4, #5, or #6. No two employees can be assigned the same parking space. The following rules govern the assignment of parking spaces: Young must be assigned a higher-numbered parking space than Togowa. Xu must be assigned a higher-numbered parking space than Souza. Robertson must be assigned a higher-numbered parking space than Young. Robertson must be assigned parking space #1, #2, #3, or #4.",
    "question": "If Young is assigned a higher-numbered parking space than Souza, then which one of the following could be true?",
    "answer": "A",
    "options": [
      "A) Togowa is assigned parking space #1.",
      "B) Young is assigned parking space #2.",
      "C) Robertson is assigned parking space #3.",
      "D) Souza is assigned parking space #3.",
      "E) Vaughn is assigned parking space #4."
    ],
    "raw_logic_programs": [
      "# Declarations\nemployees = EnumSort([Robertson, Souza, Togowa, Vaughn, Xu, Young])\nspaces = EnumSort([1, 2, 3, 4, 5, 6])\nassigned = Function([employees] -> [spaces])\n\n# Constraints\nForAll([e:employees], Exists([s:spaces], assigned(e) == s)) ::: Each of the six employees must be assigned one of the following parking spaces\nDistinct([e:employees], assigned(e)) ::: No two employees can be assigned the same parking space\nassigned(Young) > assigned(Togowa) ::: Young must be assigned a higher-numbered parking space than Togowa\nassigned(Xu) > assigned(Souza) ::: Xu must be assigned a higher-numbered parking space than Souza\nassigned(Robertson) > assigned(Young) ::: Robertson must be assigned a higher-numbered parking space than Young\nOr(assigned(Robertson) == 1, assigned(Robertson) == 2, assigned(Robertson) == 3, assigned(Robertson) == 4) ::: Robertson must be assigned parking space #1, #2, #3, or #4\n\n# Options\nQuestion ::: If Young is assigned a higher-numbered parking space than Souza, then which one of the following could be true?\nis_sat(And(assigned(Young) > assigned(Souza), assigned(Togowa) == 1)) ::: (A)\nis_sat(And(assigned(Young) > assigned(Souza), assigned(Young) == 2)) ::: (B)\nis_sat(And(assigned(Young) > assigned(Souza), assigned(Robertson) == 3)) ::: (C)\nis_sat(And(assigned(Young) > assigned(Souza), assigned(Souza) == 3)) ::: (D)\nis_sat(And(assigned(Young) > assigned(Souza), assigned(Vaughn) == 4)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201110_2-G_1_6",
    "context": "An administrator must assign parking spaces to six new employees: Robertson, Souza, Togowa, Vaughn, Xu, and Young. Each of the six employees must be assigned one of the following parking spaces: #1, #2, #3, #4, #5, or #6. No two employees can be assigned the same parking space. The following rules govern the assignment of parking spaces: Young must be assigned a higher-numbered parking space than Togowa. Xu must be assigned a higher-numbered parking space than Souza. Robertson must be assigned a higher-numbered parking space than Young. Robertson must be assigned parking space #1, #2, #3, or #4.",
    "question": "If Robertson is assigned parking space #3, then which one of the following must be true?",
    "answer": "E",
    "options": [
      "A) Souza is assigned parking space #4.",
      "B) Togowa is assigned parking space #2.",
      "C) Vaughn is assigned parking space #5.",
      "D) Xu is assigned parking space #6.",
      "E) Young is assigned parking space #2."
    ],
    "raw_logic_programs": [
      "# Declarations\nemployees = EnumSort([Robertson, Souza, Togowa, Vaughn, Xu, Young])\nspaces = EnumSort([1, 2, 3, 4, 5, 6])\nassigned = Function([employees] -> [spaces])\n\n# Constraints\nForAll([e:employees], Exists([s:spaces], assigned(e) == s)) ::: Each of the six employees must be assigned one of the following parking spaces\nDistinct([e:employees], assigned(e)) ::: No two employees can be assigned the same parking space\nassigned(Young) > assigned(Togowa) ::: Young must be assigned a higher-numbered parking space than Togowa\nassigned(Xu) > assigned(Souza) ::: Xu must be assigned a higher-numbered parking space than Souza\nassigned(Robertson) > assigned(Young) ::: Robertson must be assigned a higher-numbered parking space than Young\nOr(assigned(Robertson) == 1, assigned(Robertson) == 2, assigned(Robertson) == 3, assigned(Robertson) == 4) ::: Robertson must be assigned parking space #1, #2, #3, or #4\nassigned(Robertson) == 3 ::: If Robertson is assigned parking space #3\n\n# Options\nQuestion ::: If Robertson is assigned parking space #3, then which one of the following must be true?\nis_sat(assigned(Souza) == 4) ::: (A)\nis_sat(assigned(Togowa) == 2) ::: (B)\nis_sat(assigned(Vaughn) == 5) ::: (C)\nis_sat(assigned(Xu) == 6) ::: (D)\nis_sat(assigned(Young) == 2) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201110_2-G_2_7",
    "context": "A government needs to assign new ambassadors to Venezuela, Yemen, and Zambia. The candidates for these ambassadorships are Jaramillo, Kayne, Landon, Novetzke, and Ong. One ambassador will be assigned to each country, and no ambassador will be assigned to more than one country. The assignment of the ambassadors must meet the following constraints: Either Kayne or Novetzke, but not both, is assigned to one of the ambassadorships. If Jaramillo is assigned to one of the ambassadorships, then so is Kayne. If Ong is assigned as ambassador to Venezuela, Kayne is not assigned as ambassador to Yemen. If Landon is assigned to an ambassadorship, it is to Zambia.",
    "question": "Which one of the following could be the assignment of the ambassadors?",
    "answer": "B",
    "options": [
      "A) Venezuela: Jaramillo Yemen: Ong Zambia: Novetzke",
      "B) Venezuela: Kayne Yemen: Jaramillo Zambia: Landon",
      "C) Venezuela: Landon Yemen: Novetzke Zambia: Ong",
      "D) Venezuela: Novetzke Yemen: Jaramillo Zambia: Kayne",
      "E) Venezuela: Ong Yemen: Kayne Zambia: Landon"
    ],
    "raw_logic_programs": [
      "# Declarations\nambassadors = EnumSort([Jaramillo, Kayne, Landon, Novetzke, Ong])\ncountries = EnumSort([Venezuela, Yemen, Zambia])\nassigned = Function([ambassadors] -> [countries])\n\n# Constraints\nForAll([a:ambassadors], Count([c:countries], assigned(a) == c) <= 1) ::: no ambassador will be assigned to more than one country\nXor(assigned(Kayne) == Venezuela, assigned(Kayne) == Yemen, assigned(Kayne) == Zambia, assigned(Novetzke) == Venezuela, assigned(Novetzke) == Yemen, assigned(Novetzke) == Zambia) ::: Either Kayne or Novetzke, but not both, is assigned to one of the ambassadorships\nImplies(assigned(Jaramillo) == Venezuela, assigned(Kayne) == Yemen) ::: If Jaramillo is assigned to one of the ambassadorships, then so is Kayne\nImplies(assigned(Ong) == Venezuela, assigned(Kayne) != Yemen) ::: If Ong is assigned as ambassador to Venezuela, Kayne is not assigned as ambassador to Yemen\nImplies(assigned(Landon) == Venezuela, assigned(Landon) == Zambia) ::: If Landon is assigned to an ambassadorship, it is to Zambia\n\n# Options\nQuestion ::: Which one of the following could be the assignment of the ambassadors?\nis_sat(And(assigned(Jaramillo) == Venezuela, assigned(Ong) == Yemen, assigned(Novetzke) == Zambia)) ::: (A)\nis_sat(And(assigned(Kayne) == Venezuela, assigned(Jaramillo) == Yemen, assigned(Landon) == Zambia)) ::: (B)\nis_sat(And(assigned(Landon) == Venezuela, assigned(Novetzke) == Yemen, assigned(Ong) == Zambia)) ::: (C)\nis_sat(And(assigned(Novetzke) == Venezuela, assigned(Jaramillo) == Yemen, assigned(Kayne) == Zambia)) ::: (D)\nis_sat(And(assigned(Ong) == Venezuela, assigned(Kayne) == Yemen, assigned(Landon) == Zambia)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201110_2-G_2_8",
    "context": "A government needs to assign new ambassadors to Venezuela, Yemen, and Zambia. The candidates for these ambassadorships are Jaramillo, Kayne, Landon, Novetzke, and Ong. One ambassador will be assigned to each country, and no ambassador will be assigned to more than one country. The assignment of the ambassadors must meet the following constraints: Either Kayne or Novetzke, but not both, is assigned to one of the ambassadorships. If Jaramillo is assigned to one of the ambassadorships, then so is Kayne. If Ong is assigned as ambassador to Venezuela, Kayne is not assigned as ambassador to Yemen. If Landon is assigned to an ambassadorship, it is to Zambia.",
    "question": "The pair of candidates who are not assigned to ambassadorships could be",
    "answer": "A",
    "options": [
      "A) Jaramillo and Novetzke",
      "B) Jaramillo and Ong",
      "C) Kayne and Landon",
      "D) Kayne and Novetzke",
      "E) Landon and Ong"
    ],
    "raw_logic_programs": [
      "# Declarations\nambassadors = EnumSort([Jaramillo, Kayne, Landon, Novetzke, Ong])\ncountries = EnumSort([Venezuela, Yemen, Zambia])\nassigned = Function([ambassadors] -> [countries])\n\n# Constraints\nForAll([a:ambassadors], Count([c:countries], assigned(a) == c) <= 1) ::: no ambassador will be assigned to more than one country\nXor(assigned(Kayne) == Venezuela, assigned(Kayne) == Yemen, assigned(Kayne) == Zambia, assigned(Novetzke) == Venezuela, assigned(Novetzke) == Yemen, assigned(Novetzke) == Zambia) ::: Either Kayne or Novetzke, but not both, is assigned to one of the ambassadorships\nImplies(assigned(Jaramillo) == Venezuela, assigned(Kayne) == Yemen) ::: If Jaramillo is assigned to one of the ambassadorships, then so is Kayne\nImplies(assigned(Ong) == Venezuela, assigned(Kayne) != Yemen) ::: If Ong is assigned as ambassador to Venezuela, Kayne is not assigned as ambassador to Yemen\nImplies(assigned(Landon) == Venezuela, assigned(Landon) == Zambia) ::: If Landon is assigned to an ambassadorship, it is to Zambia\n\n# Options\nQuestion ::: The pair of candidates who are not assigned to ambassadorships could be\nis_sat(And(assigned(Jaramillo) != Venezuela, assigned(Jaramillo) != Yemen, assigned(Jaramillo) != Zambia, assigned(Novetzke) != Venezuela, assigned(Novetzke) != Yemen, assigned(Novetzke) != Zambia)) ::: (A)\nis_sat(And(assigned(Jaramillo) != Venezuela, assigned(Jaramillo) != Yemen, assigned(Jaramillo) != Zambia, assigned(Ong) != Venezuela, assigned(Ong) != Yemen, assigned(Ong) != Zambia)) ::: (B)\nis_sat(And(assigned(Kayne) != Venezuela, assigned(Kayne) != Yemen, assigned(Kayne) != Zambia, assigned(Landon) != Venezuela, assigned(Landon) != Yemen, assigned(Landon) != Zambia)) ::: (C)\nis_sat(And(assigned(Kayne) != Venezuela, assigned(Kayne) != Yemen, assigned(Kayne) != Zambia, assigned(Novetzke) != Venezuela, assigned(Novetzke) != Yemen, assigned(Novetzke) != Zambia)) ::: (D)\nis_sat(And(assigned(Landon) != Venezuela, assigned(Landon) != Yemen, assigned(Landon) != Zambia, assigned(Ong) != Venezuela, assigned(Ong) != Yemen, assigned(Ong) != Zambia)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201110_2-G_2_9",
    "context": "A government needs to assign new ambassadors to Venezuela, Yemen, and Zambia. The candidates for these ambassadorships are Jaramillo, Kayne, Landon, Novetzke, and Ong. One ambassador will be assigned to each country, and no ambassador will be assigned to more than one country. The assignment of the ambassadors must meet the following constraints: Either Kayne or Novetzke, but not both, is assigned to one of the ambassadorships. If Jaramillo is assigned to one of the ambassadorships, then so is Kayne. If Ong is assigned as ambassador to Venezuela, Kayne is not assigned as ambassador to Yemen. If Landon is assigned to an ambassadorship, it is to Zambia.",
    "question": "If Ong is assigned as ambassador to Venezuela, then the other two ambassadors assigned could be",
    "answer": "E",
    "options": [
      "A) Jaramillo and Landon",
      "B) Jaramillo and Novetzke",
      "C) Kayne and Landon",
      "D) Kayne and Novetzke",
      "E) Landon and Novetzke"
    ],
    "raw_logic_programs": [
      "# Declarations\nambassadors = EnumSort([Jaramillo, Kayne, Landon, Novetzke, Ong])\ncountries = EnumSort([Venezuela, Yemen, Zambia])\nassigned = Function([ambassadors] -> [countries])\n\n# Constraints\nForAll([a:ambassadors], Count([c:countries], assigned(a) == c) <= 1) ::: no ambassador will be assigned to more than one country\nXor(assigned(Kayne) == Venezuela, assigned(Kayne) == Yemen, assigned(Kayne) == Zambia, assigned(Novetzke) == Venezuela, assigned(Novetzke) == Yemen, assigned(Novetzke) == Zambia) ::: Either Kayne or Novetzke, but not both, is assigned to one of the ambassadorships\nImplies(Exists([c:countries], assigned(Jaramillo) == c), Exists([c:countries], assigned(Kayne) == c)) ::: If Jaramillo is assigned to one of the ambassadorships, then so is Kayne\nImplies(assigned(Ong) == Venezuela, assigned(Kayne) != Yemen) ::: If Ong is assigned as ambassador to Venezuela, Kayne is not assigned as ambassador to Yemen\nImplies(Exists([c:countries], assigned(Landon) == c), assigned(Landon) == Zambia) ::: If Landon is assigned to an ambassadorship, it is to Zambia\n\n# Options\nQuestion ::: If Ong is assigned as ambassador to Venezuela, then the other two ambassadors assigned could be\nis_valid(And(assigned(Ong) == Venezuela, And(assigned(Jaramillo) == Yemen, assigned(Landon) == Zambia))) ::: (A)\nis_valid(And(assigned(Ong) == Venezuela, And(assigned(Jaramillo) == Zambia, assigned(Novetzke) == Yemen))) ::: (B)\nis_valid(And(assigned(Ong) == Venezuela, And(assigned(Kayne) == Yemen, assigned(Landon) == Zambia))) ::: (C)\nis_valid(And(assigned(Ong) == Venezuela, And(assigned(Kayne) == Zambia, assigned(Novetzke) == Yemen))) ::: (D)\nis_valid(And(assigned(Ong) == Venezuela, And(assigned(Landon) == Yemen, assigned(Novetzke) == Zambia))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201110_2-G_2_10",
    "context": "A government needs to assign new ambassadors to Venezuela, Yemen, and Zambia. The candidates for these ambassadorships are Jaramillo, Kayne, Landon, Novetzke, and Ong. One ambassador will be assigned to each country, and no ambassador will be assigned to more than one country. The assignment of the ambassadors must meet the following constraints: Either Kayne or Novetzke, but not both, is assigned to one of the ambassadorships. If Jaramillo is assigned to one of the ambassadorships, then so is Kayne. If Ong is assigned as ambassador to Venezuela, Kayne is not assigned as ambassador to Yemen. If Landon is assigned to an ambassadorship, it is to Zambia.",
    "question": "If Kayne is assigned as ambassador to Yemen, which one of the following must be true?",
    "answer": "A",
    "options": [
      "A) Jaramillo is assigned as ambassador to Venezuela.",
      "B) Landon is assigned as ambassador to Zambia.",
      "C) Ong is assigned as ambassador to Zambia.",
      "D) Jaramillo is not assigned to an ambassadorship.",
      "E) Ong is not assigned to an ambassadorship."
    ],
    "raw_logic_programs": [
      "# Declarations\nambassadors = EnumSort([Jaramillo, Kayne, Landon, Novetzke, Ong])\ncountries = EnumSort([Venezuela, Yemen, Zambia])\nassigned = Function([ambassadors] -> [countries])\n\n# Constraints\nForAll([a:ambassadors], Count([c:countries], assigned(a) == c) <= 1) ::: no ambassador will be assigned to more than one country\nXor(assigned(Kayne) == Venezuela, assigned(Novetzke) == Venezuela) ::: Either Kayne or Novetzke, but not both, is assigned to one of the ambassadorships\nImplies(assigned(Jaramillo) == Venezuela, assigned(Kayne) == Yemen) ::: If Jaramillo is assigned to one of the ambassadorships, then so is Kayne\nImplies(And(assigned(Ong) == Venezuela, assigned(Kayne) == Yemen), False) ::: If Ong is assigned as ambassador to Venezuela, Kayne is not assigned as ambassador to Yemen\nImplies(assigned(Landon) == Venezuela, assigned(Landon) == Zambia) ::: If Landon is assigned to an ambassadorship, it is to Zambia\nassigned(Kayne) == Yemen ::: Kayne is assigned as ambassador to Yemen\n\n# Options\nQuestion ::: If Kayne is assigned as ambassador to Yemen, which one of the following must be true?\nis_valid(assigned(Jaramillo) == Venezuela) ::: (A)\nis_valid(assigned(Landon) == Zambia) ::: (B)\nis_valid(assigned(Ong) == Zambia) ::: (C)\nis_valid(assigned(Jaramillo) == None) ::: (D)\nis_valid(assigned(Ong) == None) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201110_2-G_2_11",
    "context": "A government needs to assign new ambassadors to Venezuela, Yemen, and Zambia. The candidates for these ambassadorships are Jaramillo, Kayne, Landon, Novetzke, and Ong. One ambassador will be assigned to each country, and no ambassador will be assigned to more than one country. The assignment of the ambassadors must meet the following constraints: Either Kayne or Novetzke, but not both, is assigned to one of the ambassadorships. If Jaramillo is assigned to one of the ambassadorships, then so is Kayne. If Ong is assigned as ambassador to Venezuela, Kayne is not assigned as ambassador to Yemen. If Landon is assigned to an ambassadorship, it is to Zambia.",
    "question": "Which one of the following CANNOT be true?",
    "answer": "C",
    "options": [
      "A) Jaramillo is assigned as ambassador to Zambia.",
      "B) Kayne is assigned as ambassador to Zambia.",
      "C) Novetzke is assigned as ambassador to Zambia.",
      "D) Landon is not assigned to an ambassadorship.",
      "E) Ong is not assigned to an ambassadorship."
    ],
    "raw_logic_programs": [
      "# Declarations\nambassadors = EnumSort([Jaramillo, Kayne, Landon, Novetzke, Ong])\ncountries = EnumSort([Venezuela, Yemen, Zambia])\nassigned = Function([ambassadors] -> [countries])\n\n# Constraints\nForAll([a:ambassadors], Count([c:countries], assigned(a) == c) <= 1) ::: no ambassador will be assigned to more than one country\nXor(assigned(Kayne) == Venezuela, assigned(Novetzke) == Venezuela) ::: Either Kayne or Novetzke, but not both, is assigned to one of the ambassadorships\nImplies(assigned(Jaramillo) == Venezuela, assigned(Kayne) == Yemen) ::: If Jaramillo is assigned to one of the ambassadorships, then so is Kayne\nImplies(assigned(Ong) == Venezuela, assigned(Kayne) != Yemen) ::: If Ong is assigned as ambassador to Venezuela, Kayne is not assigned as ambassador to Yemen\nImplies(assigned(Landon) == Venezuela, assigned(Landon) == Zambia) ::: If Landon is assigned to an ambassadorship, it is to Zambia\n\n# Options\nQuestion ::: Which one of the following CANNOT be true?\nis_unsat(assigned(Jaramillo) == Zambia) ::: (A)\nis_unsat(assigned(Kayne) == Zambia) ::: (B)\nis_unsat(assigned(Novetzke) == Zambia) ::: (C)\nis_unsat(assigned(Landon) == Venezuela) ::: (D)\nis_unsat(assigned(Ong) == Venezuela) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201110_2-G_2_12",
    "context": "A government needs to assign new ambassadors to Venezuela, Yemen, and Zambia. The candidates for these ambassadorships are Jaramillo, Kayne, Landon, Novetzke, and Ong. One ambassador will be assigned to each country, and no ambassador will be assigned to more than one country. The assignment of the ambassadors must meet the following constraints: Either Kayne or Novetzke, but not both, is assigned to one of the ambassadorships. If Jaramillo is assigned to one of the ambassadorships, then so is Kayne. If Ong is assigned as ambassador to Venezuela, Kayne is not assigned as ambassador to Yemen. If Landon is assigned to an ambassadorship, it is to Zambia.",
    "question": "Which one of the following, if substituted for the constraint that if Jaramillo is assigned to one of the ambassadorships, then so is Kayne, would have the same effect in determining the assignment of the ambassadors?",
    "answer": "D",
    "options": [
      "A) If Kayne is assigned to an ambassadorship, then so is Jaramillo.",
      "B) If Landon and Ong are both assigned to ambassadorships, then so is Novetzke.",
      "C) If Ong is not assigned to an ambassadorship, then Kayne is assigned to an ambassadorship.",
      "D) Jaramillo and Novetzke are not both assigned to ambassadorships.",
      "E) Novetzke and Ong are not both assigned to ambassadorships."
    ],
    "raw_logic_programs": [
      "# Declarations\nambassadors = EnumSort([Jaramillo, Kayne, Landon, Novetzke, Ong])\ncountries = EnumSort([Venezuela, Yemen, Zambia])\nassigned = Function([ambassadors] -> [countries])\n\n# Constraints\nForAll([a:ambassadors], Count([c:countries], assigned(a) == c) <= 1) ::: no ambassador will be assigned to more than one country\nXor(assigned(Kayne) != None, assigned(Novetzke) != None) ::: Either Kayne or Novetzke, but not both, is assigned to one of the ambassadorships\nImplies(assigned(Jaramillo) != None, assigned(Kayne) != None) ::: If Jaramillo is assigned to one of the ambassadorships, then so is Kayne\nImplies(assigned(Ong) == Venezuela, assigned(Kayne) != Yemen) ::: If Ong is assigned as ambassador to Venezuela, Kayne is not assigned as ambassador to Yemen\nImplies(assigned(Landon) != None, assigned(Landon) == Zambia) ::: If Landon is assigned to an ambassadorship, it is to Zambia\n\n# Options\nQuestion ::: Which one of the following, if substituted for the constraint that if Jaramillo is assigned to one of the ambassadorships, then so is Kayne, would have the same effect in determining the assignment of the ambassadors?\nis_equivalent(Implies(assigned(Kayne) != None, assigned(Jaramillo) != None), Implies(assigned(Kayne) != None, assigned(Jaramillo) != None)) ::: (A)\nis_equivalent(Implies(assigned(Kayne) != None, assigned(Jaramillo) != None), Implies(And(assigned(Landon) != None, assigned(Ong) != None), assigned(Novetzke) != None)) ::: (B)\nis_equivalent(Implies(assigned(Kayne) != None, assigned(Jaramillo) != None), Implies(assigned(Ong) == None, assigned(Kayne) != None)) ::: (C)\nis_equivalent(Implies(assigned(Kayne) != None, assigned(Jaramillo) != None), And(assigned(Jaramillo) == None, assigned(Novetzke) == None)) ::: (D)\nis_equivalent(Implies(assigned(Kayne) != None, assigned(Jaramillo) != None), And(assigned(Novetzke) == None, assigned(Ong) == None)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201110_2-G_3_13",
    "context": "On the first day of a two-day study for a cycling magazine, four riders—Reynaldo, Seamus, Theresa, and Yuki—will each test one of four bicycles—F, G, H, and J. Each rider will then test a different one of the bicycles on the second day. Each rider tests only one bicycle per day, and all four bicycles are tested each day. The assignment of riders to bicycles is subject to the following conditions: Reynaldo cannot test F. Yuki cannot test J. Theresa must be one of the testers for H. The bicycle that Yuki tests on the first day must be tested by Seamus on the second day.",
    "question": "Which one of the following is a possible assignment of riders to bicycles, with the riders for each bicycle listed in the order in which they test the bicycle?",
    "answer": "C",
    "options": [
      "A) F: Seamus, Reynaldo; G: Yuki, Seamus; H: Theresa, Yuki; J: Reynaldo, Theresa",
      "B) F: Seamus, Yuki; G: Reynaldo, Theresa; H: Yuki, Seamus; J: Theresa, Reynaldo",
      "C) F: Yuki, Seamus; G: Seamus, Reynaldo; H: Theresa, Yuki; J: Reynaldo, Theresa",
      "D) F: Yuki, Seamus; G: Theresa, Reynaldo; H: Reynaldo, Theresa; J: Seamus, Yuki",
      "E) F: Yuki, Theresa; G: Seamus, Yuki; H: Theresa, Reynaldo; J: Reynaldo, Seamus"
    ],
    "raw_logic_programs": [
      "# Declarations\nriders = EnumSort([Reynaldo, Seamus, Theresa, Yuki])\nbicycles = EnumSort([F, G, H, J])\ntests = Function([riders, bicycles, int] -> [bool])\n\n# Constraints\nForAll([r:riders, b:bicycles], Implies(tests(r, b, 1), Not(tests(r, b, 2)))) ::: Each rider tests only one bicycle per day\nForAll([b:bicycles], Count([r:riders], tests(r, b, 1)) == 1) ::: all four bicycles are tested each day\nForAll([b:bicycles], Count([r:riders], tests(r, b, 2)) == 1) ::: all four bicycles are tested each day\nNot(tests(Reynaldo, F, 1)) ::: Reynaldo cannot test F\nNot(tests(Yuki, J, 1)) ::: Yuki cannot test J\nExists([b:bicycles], tests(Theresa, b, 1) == H) ::: Theresa must be one of the testers for H\nForAll([b:bicycles], Implies(tests(Yuki, b, 1), tests(Seamus, b, 2))) ::: The bicycle that Yuki tests on the first day must be tested by Seamus on the second day\n\n# Options\nQuestion ::: Which one of the following is a possible assignment of riders to bicycles, with the riders for each bicycle listed in the order in which they test the bicycle?\nis_sat(And(tests(Seamus, F, 1), tests(Reynaldo, F, 2), tests(Yuki, G, 1), tests(Seamus, G, 2), tests(Theresa, H, 1), tests(Yuki, H, 2), tests(Reynaldo, J, 1), tests(Theresa, J, 2))) ::: (A)\nis_sat(And(tests(Seamus, F, 1), tests(Yuki, F, 2), tests(Reynaldo, G, 1), tests(Theresa, G, 2), tests(Yuki, H, 1), tests(Seamus, H, 2), tests(Theresa, J, 1), tests(Reynaldo, J, 2))) ::: (B)\nis_sat(And(tests(Yuki, F, 1), tests(Seamus, F, 2), tests(Seamus, G, 1), tests(Reynaldo, G, 2), tests(Theresa, H, 1), tests(Yuki, H, 2), tests(Reynaldo, J, 1), tests(Theresa, J, 2))) ::: (C)\nis_sat(And(tests(Yuki, F, 1), tests(Seamus, F, 2), tests(Theresa, G, 1), tests(Reynaldo, G, 2), tests(Reynaldo, H, 1), tests(Theresa, H, 2), tests(Seamus, J, 1), tests(Yuki, J, 2))) ::: (D)\nis_sat(And(tests(Yuki, F, 1), tests(Theresa, F, 2), tests(Seamus, G, 1), tests(Yuki, G, 2), tests(Theresa, H, 1), tests(Reynaldo, H, 2), tests(Reynaldo, J, 1), tests(Seamus, J, 2))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201110_2-G_3_14",
    "context": "On the first day of a two-day study for a cycling magazine, four riders—Reynaldo, Seamus, Theresa, and Yuki—will each test one of four bicycles—F, G, H, and J. Each rider will then test a different one of the bicycles on the second day. Each rider tests only one bicycle per day, and all four bicycles are tested each day. The assignment of riders to bicycles is subject to the following conditions: Reynaldo cannot test F. Yuki cannot test J. Theresa must be one of the testers for H. The bicycle that Yuki tests on the first day must be tested by Seamus on the second day.",
    "question": "If Theresa tests G on the second day, then which one of the following must be true?",
    "answer": "E",
    "options": [
      "A) Reynaldo tests H on the first day.",
      "B) Reynaldo tests J on the first day.",
      "C) Theresa tests H on the second day.",
      "D) Theresa tests J on the first day.",
      "E) Yuki tests H on the second day."
    ],
    "raw_logic_programs": [
      "# Declarations\nriders = EnumSort([Reynaldo, Seamus, Theresa, Yuki])\nbicycles = EnumSort([F, G, H, J])\ntests = Function([riders, bicycles, int] -> [bool])\n\n# Constraints\nForAll([r:riders, b:bicycles], Implies(tests(r, b, 1), Not(tests(r, b, 2)))) ::: Each rider tests only one bicycle per day\nForAll([b:bicycles, d:int], Count([r:riders], tests(r, b, d)) == 1) ::: all four bicycles are tested each day\nNot(tests(Reynaldo, F, 1)) ::: Reynaldo cannot test F\nNot(tests(Yuki, J, 1)) ::: Yuki cannot test J\ntests(Theresa, H, 1) ::: Theresa must be one of the testers for H\nForAll([b:bicycles], Implies(tests(Yuki, b, 1), tests(Seamus, b, 2))) ::: The bicycle that Yuki tests on the first day must be tested by Seamus on the second day\ntests(Theresa, G, 2) ::: If Theresa tests G on the second day\n\n# Options\nQuestion ::: If Theresa tests G on the second day, then which one of the following must be true?\nis_valid(tests(Reynaldo, H, 1)) ::: (A)\nis_valid(tests(Reynaldo, J, 1)) ::: (B)\nis_valid(tests(Theresa, H, 2)) ::: (C)\nis_valid(tests(Theresa, J, 1)) ::: (D)\nis_valid(tests(Yuki, H, 2)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201110_2-G_3_15",
    "context": "On the first day of a two-day study for a cycling magazine, four riders—Reynaldo, Seamus, Theresa, and Yuki—will each test one of four bicycles—F, G, H, and J. Each rider will then test a different one of the bicycles on the second day. Each rider tests only one bicycle per day, and all four bicycles are tested each day. The assignment of riders to bicycles is subject to the following conditions: Reynaldo cannot test F. Yuki cannot test J. Theresa must be one of the testers for H. The bicycle that Yuki tests on the first day must be tested by Seamus on the second day.",
    "question": "Any of the following could be true EXCEPT:",
    "answer": "D",
    "options": [
      "A) Reynaldo tests J on the first day.",
      "B) Reynaldo tests J on the second day.",
      "C) Seamus tests H on the first day.",
      "D) Yuki tests H on the first day.",
      "E) Yuki tests H on the second day."
    ],
    "raw_logic_programs": [
      "# Declarations\nriders = EnumSort([Reynaldo, Seamus, Theresa, Yuki])\nbicycles = EnumSort([F, G, H, J])\ntests = Function([riders, bicycles, int] -> [bool])\n\n# Constraints\nForAll([r:riders, b:bicycles], Implies(tests(r, b, 1), Not(tests(r, b, 2)))) ::: Each rider tests only one bicycle per day\nForAll([b:bicycles], Count([r:riders], tests(r, b, 1)) == 1) ::: all four bicycles are tested each day\nForAll([b:bicycles], Count([r:riders], tests(r, b, 2)) == 1) ::: all four bicycles are tested each day\nNot(tests(Reynaldo, F, 1)) ::: Reynaldo cannot test F\nNot(tests(Yuki, J, 1)) ::: Yuki cannot test J\ntests(Theresa, H, 1) ::: Theresa must be one of the testers for H\nForAll([b:bicycles], Implies(tests(Yuki, b, 1), tests(Seamus, b, 2))) ::: The bicycle that Yuki tests on the first day must be tested by Seamus on the second day\n\n# Options\nQuestion ::: Any of the following could be true EXCEPT:\nis_exception(is_sat(tests(Reynaldo, J, 1))) ::: (A)\nis_exception(is_sat(tests(Reynaldo, J, 2))) ::: (B)\nis_exception(is_sat(tests(Seamus, H, 1))) ::: (C)\nis_exception(is_sat(tests(Yuki, H, 1))) ::: (D)\nis_exception(is_sat(tests(Yuki, H, 2))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201110_2-G_3_16",
    "context": "On the first day of a two-day study for a cycling magazine, four riders—Reynaldo, Seamus, Theresa, and Yuki—will each test one of four bicycles—F, G, H, and J. Each rider will then test a different one of the bicycles on the second day. Each rider tests only one bicycle per day, and all four bicycles are tested each day. The assignment of riders to bicycles is subject to the following conditions: Reynaldo cannot test F. Yuki cannot test J. Theresa must be one of the testers for H. The bicycle that Yuki tests on the first day must be tested by Seamus on the second day.",
    "question": "Which one of the following CANNOT be true?",
    "answer": "C",
    "options": [
      "A) Reynaldo tests G on the second day.",
      "B) Seamus tests F on the first day.",
      "C) Theresa tests F on the second day.",
      "D) Reynaldo tests H on the first day.",
      "E) Yuki tests F on the second day."
    ],
    "raw_logic_programs": [
      "# Declarations\nriders = EnumSort([Reynaldo, Seamus, Theresa, Yuki])\nbicycles = EnumSort([F, G, H, J])\nday = EnumSort([1, 2])\ntests = Function([riders, bicycles, day] -> [bool])\n\n# Constraints\nForAll([r:riders, d:day], Count([b:bicycles], tests(r, b, d)) == 1) ::: Each rider tests only one bicycle per day\nForAll([b:bicycles, d:day], Count([r:riders], tests(r, b, d)) == 1) ::: all four bicycles are tested each day\nNot(tests(Reynaldo, F, 1)) ::: Reynaldo cannot test F\nNot(tests(Yuki, J, 1)) ::: Yuki cannot test J\ntests(Theresa, H, 1) ::: Theresa must be one of the testers for H\nForAll([b:bicycles], Implies(tests(Yuki, b, 1), tests(Seamus, b, 2))) ::: The bicycle that Yuki tests on the first day must be tested by Seamus on the second day\n\n# Options\nQuestion ::: Which one of the following CANNOT be true?\nis_unsat(tests(Reynaldo, G, 2)) ::: (A)\nis_unsat(tests(Seamus, F, 1)) ::: (B)\nis_unsat(tests(Theresa, F, 2)) ::: (C)\nis_unsat(tests(Reynaldo, H, 1)) ::: (D)\nis_unsat(tests(Yuki, F, 2)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201110_2-G_3_17",
    "context": "On the first day of a two-day study for a cycling magazine, four riders—Reynaldo, Seamus, Theresa, and Yuki—will each test one of four bicycles—F, G, H, and J. Each rider will then test a different one of the bicycles on the second day. Each rider tests only one bicycle per day, and all four bicycles are tested each day. The assignment of riders to bicycles is subject to the following conditions: Reynaldo cannot test F. Yuki cannot test J. Theresa must be one of the testers for H. The bicycle that Yuki tests on the first day must be tested by Seamus on the second day.",
    "question": "If Theresa tests J on the first day, then which one of the following could be true?",
    "answer": "B",
    "options": [
      "A) Reynaldo tests G on the second day.",
      "B) Seamus tests H on the first day.",
      "C) Yuki tests H on the second day.",
      "D) Seamus is one of the testers for J.",
      "E) Theresa is one of the testers for G."
    ],
    "raw_logic_programs": [
      "# Declarations\nriders = EnumSort([Reynaldo, Seamus, Theresa, Yuki])\nbicycles = EnumSort([F, G, H, J])\ntests = Function([riders, bicycles, int] -> [bool])\n\n# Constraints\nForAll([r:riders, b:bicycles], Implies(tests(r, b, 1), Not(tests(r, b, 2)))) ::: Each rider tests only one bicycle per day\nForAll([b:bicycles, d:int], Count([r:riders], tests(r, b, d)) == 1) ::: all four bicycles are tested each day\nNot(tests(Reynaldo, F, 1)) ::: Reynaldo cannot test F\nNot(tests(Yuki, J, 1)) ::: Yuki cannot test J\ntests(Theresa, H, 1) ::: Theresa must be one of the testers for H\nForAll([b:bicycles], Implies(tests(Yuki, b, 1), tests(Seamus, b, 2))) ::: The bicycle that Yuki tests on the first day must be tested by Seamus on the second day\ntests(Theresa, J, 1) ::: If Theresa tests J on the first day\n\n# Options\nQuestion ::: If Theresa tests J on the first day, then which one of the following could be true?\nis_sat(tests(Reynaldo, G, 2)) ::: (A)\nis_sat(tests(Seamus, H, 1)) ::: (B)\nis_sat(tests(Yuki, H, 2)) ::: (C)\nis_sat(tests(Seamus, J, 1)) ::: (D)\nis_sat(tests(Theresa, G, 1)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201110_2-G_3_18",
    "context": "On the first day of a two-day study for a cycling magazine, four riders—Reynaldo, Seamus, Theresa, and Yuki—will each test one of four bicycles—F, G, H, and J. Each rider will then test a different one of the bicycles on the second day. Each rider tests only one bicycle per day, and all four bicycles are tested each day. The assignment of riders to bicycles is subject to the following conditions: Reynaldo cannot test F. Yuki cannot test J. Theresa must be one of the testers for H. The bicycle that Yuki tests on the first day must be tested by Seamus on the second day.",
    "question": "Which one of the following CANNOT be true?",
    "answer": "D",
    "options": [
      "A) Both Reynaldo and Seamus test J.",
      "B) Both Reynaldo and Theresa test J.",
      "C) Both Reynaldo and Yuki test G.",
      "D) Both Seamus and Theresa test G.",
      "E) Both Theresa and Yuki test F."
    ],
    "raw_logic_programs": [
      "# Declarations\nriders = EnumSort([Reynaldo, Seamus, Theresa, Yuki])\nbicycles = EnumSort([F, G, H, J])\ntests = Function([riders, bicycles, int] -> [bool])\n\n# Constraints\nForAll([r:riders, b:bicycles], Implies(tests(r, b, 1), Not(tests(r, b, 2)))) ::: Each rider tests only one bicycle per day\nForAll([b:bicycles], Count([r:riders], tests(r, b, 1)) == 1) ::: all four bicycles are tested each day\nForAll([b:bicycles], Count([r:riders], tests(r, b, 2)) == 1) ::: all four bicycles are tested each day\nNot(tests(Reynaldo, F, 1)) ::: Reynaldo cannot test F\nNot(tests(Yuki, J, 1)) ::: Yuki cannot test J\nExists([b:bicycles], tests(Theresa, b, 1) == H) ::: Theresa must be one of the testers for H\nForAll([b:bicycles], Implies(tests(Yuki, b, 1), tests(Seamus, b, 2))) ::: The bicycle that Yuki tests on the first day must be tested by Seamus on the second day\n\n# Options\nQuestion ::: Which one of the following CANNOT be true?\nis_unsat(And(tests(Reynaldo, J, 1), tests(Seamus, J, 2))) ::: (A)\nis_unsat(And(tests(Reynaldo, J, 1), tests(Theresa, J, 2))) ::: (B)\nis_unsat(And(tests(Reynaldo, G, 1), tests(Yuki, G, 2))) ::: (C)\nis_unsat(And(tests(Seamus, G, 1), tests(Theresa, G, 2))) ::: (D)\nis_unsat(And(tests(Theresa, F, 1), tests(Yuki, F, 2))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201110_2-G_4_19",
    "context": "Exactly eight books—F, G, H, I, K, L, M, O—are placed on a bookcase with exactly three shelves—the top shelf, the middle shelf, and the bottom shelf. At least two books are placed on each shelf. The following conditions must apply: More of the books are placed on the bottom shelf than the top shelf. I is placed on the middle shelf. K is placed on a higher shelf than F. O is placed on a higher shelf than L. F is placed on the same shelf as M.",
    "question": "Which one of the following could be a complete and accurate list of the books placed on the bottom shelf?",
    "answer": "B",
    "options": [
      "A) F, M",
      "B) F, H, M",
      "C) G, H, K",
      "D) F, G, M, O",
      "E) G, H, L, M"
    ],
    "raw_logic_programs": [
      "# Declarations\nbooks = EnumSort([F, G, H, I, K, L, M, O])\nshelves = EnumSort([top, middle, bottom])\nplaced = Function([books] -> [shelves])\n\n# Constraints\nCount([b:books], placed(b) == bottom) > Count([b:books], placed(b) == top) ::: More of the books are placed on the bottom shelf than the top shelf\nForAll([s:shelves], Count([b:books], placed(b) == s) >= 2) ::: At least two books are placed on each shelf\nplaced(I) == middle ::: I is placed on the middle shelf\nAnd(placed(K) != placed(F), placed(K) > placed(F)) ::: K is placed on a higher shelf than F\nAnd(placed(O) != placed(L), placed(O) > placed(L)) ::: O is placed on a higher shelf than L\nplaced(F) == placed(M) ::: F is placed on the same shelf as M\n\n# Options\nQuestion ::: Which one of the following could be a complete and accurate list of the books placed on the bottom shelf?\nis_accurate_list([placed(F) == bottom, placed(M) == bottom]) ::: (A)\nis_accurate_list([placed(F) == bottom, placed(H) == bottom, placed(M) == bottom]) ::: (B)\nis_accurate_list([placed(G) == bottom, placed(H) == bottom, placed(K) == bottom]) ::: (C)\nis_accurate_list([placed(F) == bottom, placed(G) == bottom, placed(M) == bottom, placed(O) == bottom]) ::: (D)\nis_accurate_list([placed(G) == bottom, placed(H) == bottom, placed(L) == bottom, placed(M) == bottom]) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201110_2-G_4_20",
    "context": "Exactly eight books—F, G, H, I, K, L, M, O—are placed on a bookcase with exactly three shelves—the top shelf, the middle shelf, and the bottom shelf. At least two books are placed on each shelf. The following conditions must apply: More of the books are placed on the bottom shelf than the top shelf. I is placed on the middle shelf. K is placed on a higher shelf than F. O is placed on a higher shelf than L. F is placed on the same shelf as M.",
    "question": "It is fully determined which of the shelves each of the books is placed on if which one of the following is true?",
    "answer": "A",
    "options": [
      "A) I and M are placed on the same shelf as each other.",
      "B) K and G are placed on the same shelf as each other.",
      "C) L and F are placed on the same shelf as each other.",
      "D) M and H are placed on the same shelf as each other.",
      "E) H and O are placed on the same shelf as each other."
    ],
    "raw_logic_programs": [
      "# Declarations\nbooks = EnumSort([F, G, H, I, K, L, M, O])\nshelves = EnumSort([top, middle, bottom])\nplaced = Function([books] -> [shelves])\n\n# Constraints\nForAll([s:shelves], Count([b:books], placed(b) == s) >= 2) ::: At least two books are placed on each shelf\nCount([b:books], placed(b) == bottom) > Count([b:books], placed(b) == top) ::: More of the books are placed on the bottom shelf than the top shelf\nplaced(I) == middle ::: I is placed on the middle shelf\nplaced(K) > placed(F) ::: K is placed on a higher shelf than F\nplaced(O) > placed(L) ::: O is placed on a higher shelf than L\nplaced(F) == placed(M) ::: F is placed on the same shelf as M\n\n# Options\nQuestion ::: It is fully determined which of the shelves each of the books is placed on if which one of the following is true?\nis_determined(And(placed(I) == placed(M), placed(I) == middle)) ::: (A)\nis_determined(And(placed(K) == placed(G), placed(K) > placed(F))) ::: (B)\nis_determined(And(placed(L) == placed(F), placed(F) == placed(M))) ::: (C)\nis_determined(And(placed(M) == placed(H), placed(F) == placed(M))) ::: (D)\nis_determined(And(placed(H) == placed(O), placed(O) > placed(L))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201110_2-G_4_21",
    "context": "Exactly eight books—F, G, H, I, K, L, M, O—are placed on a bookcase with exactly three shelves—the top shelf, the middle shelf, and the bottom shelf. At least two books are placed on each shelf. The following conditions must apply: More of the books are placed on the bottom shelf than the top shelf. I is placed on the middle shelf. K is placed on a higher shelf than F. O is placed on a higher shelf than L. F is placed on the same shelf as M.",
    "question": "Which one of the following must be true?",
    "answer": "A",
    "options": [
      "A) O is placed on a shelf higher than the shelf M is placed on.",
      "B) K is placed on a shelf higher than the shelf G is placed on.",
      "C) I is placed on a shelf higher than the shelf F is placed on.",
      "D) G is placed on a shelf higher than the shelf O is placed on.",
      "E) F is placed on a shelf higher than the shelf L is placed on."
    ],
    "raw_logic_programs": [
      "# Declarations\nbooks = EnumSort([F, G, H, I, K, L, M, O])\nshelves = EnumSort([top, middle, bottom])\nplaced = Function([books] -> [shelves])\n\n# Constraints\nForAll([s:shelves], Count([b:books], placed(b) == s) >= 2) ::: At least two books are placed on each shelf\nCount([b:books], placed(b) == bottom) > Count([b:books], placed(b) == top) ::: More of the books are placed on the bottom shelf than the top shelf\nplaced(I) == middle ::: I is placed on the middle shelf\nplaced(K) > placed(F) ::: K is placed on a higher shelf than F\nplaced(O) > placed(L) ::: O is placed on a higher shelf than L\nplaced(F) == placed(M) ::: F is placed on the same shelf as M\n\n# Options\nQuestion ::: Which one of the following must be true?\nis_valid(placed(O) > placed(M)) ::: (A)\nis_valid(placed(K) > placed(G)) ::: (B)\nis_valid(placed(I) > placed(F)) ::: (C)\nis_valid(placed(G) > placed(O)) ::: (D)\nis_valid(placed(F) > placed(L)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201110_2-G_4_22",
    "context": "Exactly eight books—F, G, H, I, K, L, M, O—are placed on a bookcase with exactly three shelves—the top shelf, the middle shelf, and the bottom shelf. At least two books are placed on each shelf. The following conditions must apply: More of the books are placed on the bottom shelf than the top shelf. I is placed on the middle shelf. K is placed on a higher shelf than F. O is placed on a higher shelf than L. F is placed on the same shelf as M.",
    "question": "If G is placed on the top shelf, then which one of the following could be a complete and accurate list of the books placed on the middle shelf?",
    "answer": "D",
    "options": [
      "A) H, I",
      "B) I, L",
      "C) H, I, L",
      "D) I, K, L",
      "E) F, I, M"
    ],
    "raw_logic_programs": [
      "# Declarations\nbooks = EnumSort([F, G, H, I, K, L, M, O])\nshelves = EnumSort([top, middle, bottom])\nplaced = Function([books] -> [shelves])\n\n# Constraints\nCount([b:books], placed(b) == top) + Count([b:books], placed(b) == middle) + Count([b:books], placed(b) == bottom) == 8 ::: Exactly eight books—F, G, H, I, K, L, M, O—are placed on a bookcase with exactly three shelves—the top shelf, the middle shelf, and the bottom shelf\nAnd(Count([b:books], placed(b) == top) >= 2, Count([b:books], placed(b) == middle) >= 2, Count([b:books], placed(b) == bottom) >= 2) ::: At least two books are placed on each shelf\nCount([b:books], placed(b) == bottom) > Count([b:books], placed(b) == top) ::: More of the books are placed on the bottom shelf than the top shelf\nplaced(I) == middle ::: I is placed on the middle shelf\nplaced(K) > placed(F) ::: K is placed on a higher shelf than F\nplaced(O) > placed(L) ::: O is placed on a higher shelf than L\nplaced(F) == placed(M) ::: F is placed on the same shelf as M\nplaced(G) == top ::: If G is placed on the top shelf\n\n# Options\nQuestion ::: If G is placed on the top shelf, then which one of the following could be a complete and accurate list of the books placed on the middle shelf?\nis_accurate_list([placed(H) == middle, placed(I) == middle]) ::: (A)\nis_accurate_list([placed(I) == middle, placed(L) == middle]) ::: (B)\nis_accurate_list([placed(H) == middle, placed(I) == middle, placed(L) == middle]) ::: (C)\nis_accurate_list([placed(I) == middle, placed(K) == middle, placed(L) == middle]) ::: (D)\nis_accurate_list([placed(F) == middle, placed(I) == middle, placed(M) == middle]) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201110_2-G_4_23",
    "context": "Exactly eight books—F, G, H, I, K, L, M, O—are placed on a bookcase with exactly three shelves—the top shelf, the middle shelf, and the bottom shelf. At least two books are placed on each shelf. The following conditions must apply: More of the books are placed on the bottom shelf than the top shelf. I is placed on the middle shelf. K is placed on a higher shelf than F. O is placed on a higher shelf than L. F is placed on the same shelf as M.",
    "question": "If L is placed on a shelf higher than the shelf H is placed on, then which one of the following must be true?",
    "answer": "C",
    "options": [
      "A) F and G are placed on the same shelf as each other.",
      "B) G and H are placed on the same shelf as each other.",
      "C) H and M are placed on the same shelf as each other.",
      "D) I and G are placed on the same shelf as each other.",
      "E) K and O are placed on the same shelf as each other."
    ],
    "raw_logic_programs": [
      "# Declarations\nbooks = EnumSort([F, G, H, I, K, L, M, O])\nshelves = EnumSort([top, middle, bottom])\nplaced = Function([books] -> [shelves])\n\n# Constraints\nCount([b:books], placed(b) == top) + Count([b:books], placed(b) == middle) + Count([b:books], placed(b) == bottom) == 8 ::: Exactly eight books—F, G, H, I, K, L, M, O—are placed on a bookcase with exactly three shelves—the top shelf, the middle shelf, and the bottom shelf\nAnd(Count([b:books], placed(b) == top) >= 2, Count([b:books], placed(b) == middle) >= 2, Count([b:books], placed(b) == bottom) >= 2) ::: At least two books are placed on each shelf\nCount([b:books], placed(b) == bottom) > Count([b:books], placed(b) == top) ::: More of the books are placed on the bottom shelf than the top shelf\nplaced(I) == middle ::: I is placed on the middle shelf\nplaced(K) > placed(F) ::: K is placed on a higher shelf than F\nplaced(O) > placed(L) ::: O is placed on a higher shelf than L\nplaced(F) == placed(M) ::: F is placed on the same shelf as M\n\n# Options\nQuestion ::: If L is placed on a shelf higher than the shelf H is placed on, then which one of the following must be true?\nplaced(L) > placed(H) ::: If L is placed on a shelf higher than the shelf H is placed on\nis_valid(placed(F) == placed(G)) ::: (A)\nis_valid(placed(G) == placed(H)) ::: (B)\nis_valid(placed(H) == placed(M)) ::: (C)\nis_valid(placed(I) == placed(G)) ::: (D)\nis_valid(placed(K) == placed(O)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201206_3-G_1_1",
    "context": "A chemistry class has six lab sessions scheduled over three days—Wednesday, Thursday, and Friday—one session heing held each morning and one each afternoon. Each session will be led by a different lab assistant—Julio, Kevin, Lan, Nessa, Olivia, or Rebecca. The assignment of lab assistants to sessions is constrained as follows: Kevin and Rebecca must lead sessions that meet on the same day. Lan and Olivia cannot lead sessions that meet on the same day. Nessa must lead an afternoon session. Julio's session must meet on an earlier day of the week than Olivia's.",
    "question": "Which one of the following could he an accurate assignment of lab assistants to morning and afternoon sessions, respectively, on the three days?",
    "answer": "E",
    "options": [
      "A) Wednesday: Rebecca, Kevin Thursday: Julio, Lan Friday: Nessa, Olivia",
      "B) Wednesday: Olivia, Nessa Thursday: Julio, Lan Friday: Kevin, Rebecca",
      "C) Wednesday: Lan, Kevin Thursday: Rebecca, Julio Friday: Olivia, Nessa",
      "D) Wednesday: Kevin, Rebecca Thursday: Julio, Nessa Friday: Olivia, Lan",
      "E) Wednesday: Julio, Lan Thursday: Olivia, Nessa Friday: Rebecca, Kevin"
    ],
    "raw_logic_programs": [
      "# Declarations\ndays = EnumSort([Wednesday, Thursday, Friday])\ntimes = EnumSort([morning, afternoon])\nassistants = EnumSort([Julio, Kevin, Lan, Nessa, Olivia, Rebecca])\nleads = Function([days, times] -> [assistants])\n\n# Constraints\nForAll([d:days], Distinct([t:times], leads(d, t))) ::: Each session will be led by a different lab assistant\nExists([d:days], And(leads(d, morning) == Kevin, leads(d, afternoon) == Rebecca)) ::: Kevin and Rebecca must lead sessions that meet on the same day\nForAll([d:days], Implies(leads(d, morning) == Lan, leads(d, afternoon) != Olivia)) ::: Lan and Olivia cannot lead sessions that meet on the same day\nExists([d:days], leads(d, afternoon) == Nessa) ::: Nessa must lead an afternoon session\nExists([d1:days, d2:days], And(leads(d1, morning) == Julio, leads(d2, morning) == Olivia, d1 < d2)) ::: Julio's session must meet on an earlier day of the week than Olivia's\n\n# Options\nQuestion ::: Which one of the following could he an accurate assignment of lab assistants to morning and afternoon sessions, respectively, on the three days?\nis_valid(And(leads(Wednesday, morning) == Rebecca, leads(Wednesday, afternoon) == Kevin, leads(Thursday, morning) == Julio, leads(Thursday, afternoon) == Lan, leads(Friday, morning) == Nessa, leads(Friday, afternoon) == Olivia)) ::: (A)\nis_valid(And(leads(Wednesday, morning) == Olivia, leads(Wednesday, afternoon) == Nessa, leads(Thursday, morning) == Julio, leads(Thursday, afternoon) == Lan, leads(Friday, morning) == Kevin, leads(Friday, afternoon) == Rebecca)) ::: (B)\nis_valid(And(leads(Wednesday, morning) == Lan, leads(Wednesday, afternoon) == Kevin, leads(Thursday, morning) == Rebecca, leads(Thursday, afternoon) == Julio, leads(Friday, morning) == Olivia, leads(Friday, afternoon) == Nessa)) ::: (C)\nis_valid(And(leads(Wednesday, morning) == Kevin, leads(Wednesday, afternoon) == Rebecca, leads(Thursday, morning) == Julio, leads(Thursday, afternoon) == Nessa, leads(Friday, morning) == Olivia, leads(Friday, afternoon) == Lan)) ::: (D)\nis_valid(And(leads(Wednesday, morning) == Julio, leads(Wednesday, afternoon) == Lan, leads(Thursday, morning) == Olivia, leads(Thursday, afternoon) == Nessa, leads(Friday, morning) == Rebecca, leads(Friday, afternoon) == Kevin)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201206_3-G_1_2",
    "context": "A chemistry class has six lab sessions scheduled over three days—Wednesday, Thursday, and Friday—one session heing held each morning and one each afternoon. Each session will be led by a different lab assistant—Julio, Kevin, Lan, Nessa, Olivia, or Rebecca. The assignment of lab assistants to sessions is constrained as follows: Kevin and Rebecca must lead sessions that meet on the same day. Lan and Olivia cannot lead sessions that meet on the same day. Nessa must lead an afternoon session. Julio's session must meet on an earlier day of the week than Olivia's.",
    "question": "If Lan does not lead a Wednesday session, then which one of the following lab assistants must lead a Thursday session?",
    "answer": "E",
    "options": [
      "A) Rebecca",
      "B) Olivia",
      "C) Nessa",
      "D) Kevin",
      "E) Julio"
    ],
    "raw_logic_programs": [
      "# Declarations\nassistants = EnumSort([Julio, Kevin, Lan, Nessa, Olivia, Rebecca])\ndays = EnumSort([Wednesday, Thursday, Friday])\ntimes = EnumSort([morning, afternoon])\nleads = Function([assistants, days, times] -> [bool])\n\n# Constraints\nForAll([d:days], Exists([a:assistants], leads(a, d, morning))) ::: one session heing held each morning\nForAll([d:days], Exists([a:assistants], leads(a, d, afternoon))) ::: one session heing held each afternoon\nForAll([a:assistants], Count([d:days, t:times], leads(a, d, t)) == 1) ::: Each session will be led by a different lab assistant\nExists([d:days], And(leads(Kevin, d, morning), leads(Rebecca, d, afternoon))) ::: Kevin and Rebecca must lead sessions that meet on the same day\nForAll([d:days], Not(And(leads(Lan, d, morning), leads(Olivia, d, afternoon)))) ::: Lan and Olivia cannot lead sessions that meet on the same day\nExists([d:days], leads(Nessa, d, afternoon)) ::: Nessa must lead an afternoon session\nExists([d1:days, d2:days], And(leads(Julio, d1, morning), leads(Olivia, d2, morning), d1 < d2)) ::: Julio's session must meet on an earlier day of the week than Olivia's\n\n# Options\nQuestion ::: If Lan does not lead a Wednesday session, then which one of the following lab assistants must lead a Thursday session?\nis_valid(Implies(Not(leads(Lan, Wednesday, morning)), leads(Rebecca, Thursday, morning))) ::: (A)\nis_valid(Implies(Not(leads(Lan, Wednesday, morning)), leads(Olivia, Thursday, morning))) ::: (B)\nis_valid(Implies(Not(leads(Lan, Wednesday, morning)), leads(Nessa, Thursday, morning))) ::: (C)\nis_valid(Implies(Not(leads(Lan, Wednesday, morning)), leads(Kevin, Thursday, morning))) ::: (D)\nis_valid(Implies(Not(leads(Lan, Wednesday, morning)), leads(Julio, Thursday, morning))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201206_3-G_1_3",
    "context": "A chemistry class has six lab sessions scheduled over three days—Wednesday, Thursday, and Friday—one session heing held each morning and one each afternoon. Each session will be led by a different lab assistant—Julio, Kevin, Lan, Nessa, Olivia, or Rebecca. The assignment of lab assistants to sessions is constrained as follows: Kevin and Rebecca must lead sessions that meet on the same day. Lan and Olivia cannot lead sessions that meet on the same day. Nessa must lead an afternoon session. Julio's session must meet on an earlier day of the week than Olivia's.",
    "question": "If Kevin's session meets on the day before Nessa's, then which one of the following is a complete and accurate list of lab assistants any one of whom could lead the Thursday afternoon session?",
    "answer": "B",
    "options": [
      "A) Julio, Nessa",
      "B) Kevin, Rebecca",
      "C) Kevin, Nessa, Rebecca",
      "D) Julio, Kevin, Nessa, Rebecca",
      "E) Julio, Kevin, Lan, Nessa, Rebecca"
    ],
    "raw_logic_programs": [
      "# Declarations\ndays = EnumSort([Wednesday, Thursday, Friday])\ntimes = EnumSort([morning, afternoon])\nassistants = EnumSort([Julio, Kevin, Lan, Nessa, Olivia, Rebecca])\nleads = Function([assistants, days, times] -> [bool])\n\n# Constraints\nForAll([d:days], Exists([a:assistants], leads(a, d, morning))) ::: one session heing held each morning\nForAll([d:days], Exists([a:assistants], leads(a, d, afternoon))) ::: one session heing held each afternoon\nForAll([a:assistants], Count([d:days, t:times], leads(a, d, t)) == 1) ::: Each session will be led by a different lab assistant\nExists([d:days], And(leads(Kevin, d, morning), leads(Rebecca, d, afternoon))) ::: Kevin and Rebecca must lead sessions that meet on the same day\nForAll([d:days], Not(And(leads(Lan, d, morning), leads(Olivia, d, afternoon)))) ::: Lan and Olivia cannot lead sessions that meet on the same day\nExists([d:days], leads(Nessa, d, afternoon)) ::: Nessa must lead an afternoon session\nExists([d1:days, d2:days], And(leads(Julio, d1, morning), leads(Olivia, d2, morning), d1 < d2)) ::: Julio's session must meet on an earlier day of the week than Olivia's\nExists([d1:days, d2:days], And(leads(Kevin, d1, morning), leads(Nessa, d2, afternoon), d1 < d2)) ::: If Kevin's session meets on the day before Nessa's\n\n# Options\nQuestion ::: If Kevin's session meets on the day before Nessa's, then which one of the following is a complete and accurate list of lab assistants any one of whom could lead the Thursday afternoon session?\nis_accurate_list([leads(Julio, Thursday, afternoon), leads(Nessa, Thursday, afternoon)]) ::: (A)\nis_accurate_list([leads(Kevin, Thursday, afternoon), leads(Rebecca, Thursday, afternoon)]) ::: (B)\nis_accurate_list([leads(Kevin, Thursday, afternoon), leads(Nessa, Thursday, afternoon), leads(Rebecca, Thursday, afternoon)]) ::: (C)\nis_accurate_list([leads(Julio, Thursday, afternoon), leads(Kevin, Thursday, afternoon), leads(Nessa, Thursday, afternoon), leads(Rebecca, Thursday, afternoon)]) ::: (D)\nis_accurate_list([leads(Julio, Thursday, afternoon), leads(Kevin, Thursday, afternoon), leads(Lan, Thursday, afternoon), leads(Nessa, Thursday, afternoon), leads(Rebecca, Thursday, afternoon)]) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201206_3-G_1_4",
    "context": "A chemistry class has six lab sessions scheduled over three days—Wednesday, Thursday, and Friday—one session heing held each morning and one each afternoon. Each session will be led by a different lab assistant—Julio, Kevin, Lan, Nessa, Olivia, or Rebecca. The assignment of lab assistants to sessions is constrained as follows: Kevin and Rebecca must lead sessions that meet on the same day. Lan and Olivia cannot lead sessions that meet on the same day. Nessa must lead an afternoon session. Julio's session must meet on an earlier day of the week than Olivia's.",
    "question": "If Julio and Kevin both lead morning sessions, then any of the following could be true EXCEPT:",
    "answer": "A",
    "options": [
      "A) Lan's session meets Wednesday morning.",
      "B) Lan's session meets Thursday afternoon.",
      "C) Nessa's session meets Friday afternoon.",
      "D) Olivia's session meets Thursday morning.",
      "E) Olivia's session meets Friday morning."
    ],
    "raw_logic_programs": [
      "# Declarations\ndays = EnumSort([Wednesday, Thursday, Friday])\ntimes = EnumSort([morning, afternoon])\nassistants = EnumSort([Julio, Kevin, Lan, Nessa, Olivia, Rebecca])\nleads = Function([assistants, days, times] -> [bool])\n\n# Constraints\nForAll([d:days], Exists([a:assistants], leads(a, d, morning))) ::: one session heing held each morning\nForAll([d:days], Exists([a:assistants], leads(a, d, afternoon))) ::: one session heing held each afternoon\nForAll([a:assistants], Count([d:days, t:times], leads(a, d, t)) == 1) ::: Each session will be led by a different lab assistant\nAnd(Exists([d:days], And(leads(Kevin, d, morning), leads(Rebecca, d, morning))), Exists([d:days], And(leads(Kevin, d, afternoon), leads(Rebecca, d, afternoon)))) ::: Kevin and Rebecca must lead sessions that meet on the same day\nForAll([d:days], Not(And(leads(Lan, d, morning), leads(Olivia, d, morning)))) ::: Lan and Olivia cannot lead sessions that meet on the same day\nForAll([d:days], Not(And(leads(Lan, d, afternoon), leads(Olivia, d, afternoon)))) ::: Lan and Olivia cannot lead sessions that meet on the same day\nExists([d:days], leads(Nessa, d, afternoon)) ::: Nessa must lead an afternoon session\nExists([d1:days, d2:days], And(leads(Julio, d1, morning), leads(Olivia, d2, morning), d1 < d2)) ::: Julio's session must meet on an earlier day of the week than Olivia's\n\n# Options\nQuestion ::: If Julio and Kevin both lead morning sessions, then any of the following could be true EXCEPT:\nis_exception(And(leads(Julio, Wednesday, morning), leads(Kevin, Wednesday, morning), leads(Lan, Wednesday, morning))) ::: (A)\nis_exception(And(leads(Julio, Wednesday, morning), leads(Kevin, Wednesday, morning), leads(Lan, Thursday, afternoon))) ::: (B)\nis_exception(And(leads(Julio, Wednesday, morning), leads(Kevin, Wednesday, morning), leads(Nessa, Friday, afternoon))) ::: (C)\nis_exception(And(leads(Julio, Wednesday, morning), leads(Kevin, Wednesday, morning), leads(Olivia, Thursday, morning))) ::: (D)\nis_exception(And(leads(Julio, Wednesday, morning), leads(Kevin, Wednesday, morning), leads(Olivia, Friday, morning))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201206_3-G_1_5",
    "context": "A chemistry class has six lab sessions scheduled over three days—Wednesday, Thursday, and Friday—one session heing held each morning and one each afternoon. Each session will be led by a different lab assistant—Julio, Kevin, Lan, Nessa, Olivia, or Rebecca. The assignment of lab assistants to sessions is constrained as follows: Kevin and Rebecca must lead sessions that meet on the same day. Lan and Olivia cannot lead sessions that meet on the same day. Nessa must lead an afternoon session. Julio's session must meet on an earlier day of the week than Olivia's.",
    "question": "If Julio leads the Thursday afternoon session, then for how many of the other lab assistants can one determine which sessions they lead?",
    "answer": "C",
    "options": [
      "A) one",
      "B) two",
      "C) three",
      "D) four",
      "E) five"
    ],
    "raw_logic_programs": [
      "# Declarations\nassistants = EnumSort([Julio, Kevin, Lan, Nessa, Olivia, Rebecca])\ndays = EnumSort([Wednesday, Thursday, Friday])\ntimes = EnumSort([morning, afternoon])\nleads = Function([assistants, days, times] -> [bool])\n\n# Constraints\nForAll([d:days], Exists([a:assistants], leads(a, d, morning))) ::: one session heing held each morning\nForAll([d:days], Exists([a:assistants], leads(a, d, afternoon))) ::: one session heing held each afternoon\nForAll([a:assistants], Count([d:days, t:times], leads(a, d, t)) == 1) ::: Each session will be led by a different lab assistant\nExists([d:days], And(leads(Kevin, d, morning), leads(Rebecca, d, afternoon))) ::: Kevin and Rebecca must lead sessions that meet on the same day\nForAll([d:days], Not(And(leads(Lan, d, morning), leads(Olivia, d, afternoon)))) ::: Lan and Olivia cannot lead sessions that meet on the same day\nExists([d:days], leads(Nessa, d, afternoon)) ::: Nessa must lead an afternoon session\nExists([d1:days, d2:days], And(leads(Julio, d1, afternoon), leads(Olivia, d2, afternoon), d1 < d2)) ::: Julio's session must meet on an earlier day of the week than Olivia's\nleads(Julio, Thursday, afternoon) ::: If Julio leads the Thursday afternoon session\n\n# Options\nQuestion ::: If Julio leads the Thursday afternoon session, then for how many of the other lab assistants can one determine which sessions they lead?\nis_determined(Exists([d:days, t:times], leads(Kevin, d, t))) ::: Kevin\nis_determined(Exists([d:days, t:times], leads(Lan, d, t))) ::: Lan\nis_determined(Exists([d:days, t:times], leads(Nessa, d, t))) ::: Nessa\nis_determined(Exists([d:days, t:times], leads(Olivia, d, t))) ::: Olivia\nis_determined(Exists([d:days, t:times], leads(Rebecca, d, t))) ::: Rebecca\nis_valid(Count([a:assistants], is_determined(Exists([d:days, t:times], leads(a, d, t)))) == 4) ::: (D)\n"
    ]
  },
  {
    "id": "ar_lsat_201206_3-G_2_6",
    "context": "A shopping center has exactly seven spaces—space 1 through space 7—arranged in a straight row. Seven businesses—an optometrist, a pharmacy, two restaurants, a shoe store, a toy store, and a veterinarian—will be located in the shopping center, one in each space. The locations of the businesses are subject to the following constraints: The pharmacy must be at one end of the row and one of the restaurants at the other. The two restaurants must be separated by at least two other businesses. The pharmacy must be next to either the optometrist or the veterinarian. The toy store cannot be next to the veterinarian.",
    "question": "Which one of the following could be the order of the businesses in spaces 1 through 7 respectively?",
    "answer": "E",
    "options": [
      "A) pharmacy, optometrist, shoe store, restaurant, veterinarian, toy store, restaurant",
      "B) pharmacy, veterinarian, optometrist, shoe store, restaurant, toy store, restaurant",
      "C) restaurant, shoe store, veterinarian, pharmacy, optometrist, toy store, restaurant",
      "D) restaurant, toy store, optometrist, restaurant, veterinarian, shoe store, pharmacy",
      "E) restaurant, optometrist, toy store, restaurant, shoe store, veterinarian, pharmacy"
    ],
    "raw_logic_programs": [
      "# Declarations\nspaces = EnumSort([1, 2, 3, 4, 5, 6, 7])\nbusinesses = EnumSort([optometrist, pharmacy, restaurant1, restaurant2, shoe_store, toy_store, veterinarian])\nlocated = Function([businesses] -> [spaces])\n\n# Constraints\nForAll([b:businesses], Exists([s:spaces], located(b) == s)) ::: one in each space\nOr(located(pharmacy) == 1, located(pharmacy) == 7) ::: The pharmacy must be at one end of the row\nOr(located(restaurant1) == 1, located(restaurant1) == 7) ::: one of the restaurants at the other\nAbs(located(restaurant1) - located(restaurant2)) >= 3 ::: The two restaurants must be separated by at least two other businesses\nOr(Abs(located(pharmacy) - located(optometrist)) == 1, Abs(located(pharmacy) - located(veterinarian)) == 1) ::: The pharmacy must be next to either the optometrist or the veterinarian\nAbs(located(toy_store) - located(veterinarian)) != 1 ::: The toy store cannot be next to the veterinarian\n\n# Options\nQuestion ::: Which one of the following could be the order of the businesses in spaces 1 through 7 respectively?\nis_sat(And(located(pharmacy) == 1, located(optometrist) == 2, located(shoe_store) == 3, located(restaurant1) == 4, located(veterinarian) == 5, located(toy_store) == 6, located(restaurant2) == 7)) ::: (A)\nis_sat(And(located(pharmacy) == 1, located(veterinarian) == 2, located(optometrist) == 3, located(shoe_store) == 4, located(restaurant1) == 5, located(toy_store) == 6, located(restaurant2) == 7)) ::: (B)\nis_sat(And(located(restaurant1) == 1, located(shoe_store) == 2, located(veterinarian) == 3, located(pharmacy) == 4, located(optometrist) == 5, located(toy_store) == 6, located(restaurant2) == 7)) ::: (C)\nis_sat(And(located(restaurant1) == 1, located(toy_store) == 2, located(optometrist) == 3, located(restaurant2) == 4, located(veterinarian) == 5, located(shoe_store) == 6, located(pharmacy) == 7)) ::: (D)\nis_sat(And(located(restaurant1) == 1, located(optometrist) == 2, located(toy_store) == 3, located(restaurant2) == 4, located(shoe_store) == 5, located(veterinarian) == 6, located(pharmacy) == 7)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201206_3-G_2_7",
    "context": "A shopping center has exactly seven spaces—space 1 through space 7—arranged in a straight row. Seven businesses—an optometrist, a pharmacy, two restaurants, a shoe store, a toy store, and a veterinarian—will be located in the shopping center, one in each space. The locations of the businesses are subject to the following constraints: The pharmacy must be at one end of the row and one of the restaurants at the other. The two restaurants must be separated by at least two other businesses. The pharmacy must be next to either the optometrist or the veterinarian. The toy store cannot be next to the veterinarian.",
    "question": "If the shoe store is in space 2, which one of the following could be true?",
    "answer": "A",
    "options": [
      "A) The optometrist is in space 5.",
      "B) The pharmacy is in space 1.",
      "C) A restaurant is in space 3.",
      "D) The toy store is in space 6.",
      "E) The veterinarian is in space 4."
    ],
    "raw_logic_programs": [
      "# Declarations\nspaces = EnumSort([1, 2, 3, 4, 5, 6, 7])\nbusinesses = EnumSort([optometrist, pharmacy, restaurant1, restaurant2, shoe_store, toy_store, veterinarian])\nlocated = Function([businesses] -> [spaces])\n\n# Constraints\nForAll([b:businesses], Exists([s:spaces], located(b) == s)) ::: one in each space\nOr(located(pharmacy) == 1, located(pharmacy) == 7) ::: The pharmacy must be at one end of the row\nOr(located(restaurant1) == 1, located(restaurant1) == 7) ::: one of the restaurants at the other\nForAll([s:spaces], Implies(And(located(restaurant1) == s, located(restaurant2) == s), Abs(s - s) >= 3)) ::: The two restaurants must be separated by at least two other businesses\nOr(Abs(located(pharmacy) - located(optometrist)) == 1, Abs(located(pharmacy) - located(veterinarian)) == 1) ::: The pharmacy must be next to either the optometrist or the veterinarian\nForAll([s:spaces], Implies(And(located(toy_store) == s, located(veterinarian) == s), Abs(s - s) == 1)) ::: The toy store cannot be next to the veterinarian\nlocated(shoe_store) == 2 ::: If the shoe store is in space 2\n\n# Options\nQuestion ::: If the shoe store is in space 2, which one of the following could be true?\nis_sat(located(optometrist) == 5) ::: (A)\nis_sat(located(pharmacy) == 1) ::: (B)\nis_sat(located(restaurant1) == 3) ::: (C)\nis_sat(located(toy_store) == 6) ::: (D)\nis_sat(located(veterinarian) == 4) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201206_3-G_2_8",
    "context": "A shopping center has exactly seven spaces—space 1 through space 7—arranged in a straight row. Seven businesses—an optometrist, a pharmacy, two restaurants, a shoe store, a toy store, and a veterinarian—will be located in the shopping center, one in each space. The locations of the businesses are subject to the following constraints: The pharmacy must be at one end of the row and one of the restaurants at the other. The two restaurants must be separated by at least two other businesses. The pharmacy must be next to either the optometrist or the veterinarian. The toy store cannot be next to the veterinarian.",
    "question": "If the veterinarian is in space 5, which one of the following must be true?",
    "answer": "C",
    "options": [
      "A) The optometrist is in space 2.",
      "B) The pharmacy is in space 7.",
      "C) A restaurant is in space 4.",
      "D) The shoe store is in space 6.",
      "E) The toy store is in space 3."
    ],
    "raw_logic_programs": [
      "# Declarations\nspaces = EnumSort([1, 2, 3, 4, 5, 6, 7])\nbusinesses = EnumSort([optometrist, pharmacy, restaurant1, restaurant2, shoe_store, toy_store, veterinarian])\nlocated = Function([businesses] -> [spaces])\n\n# Constraints\nOr(located(pharmacy) == 1, located(pharmacy) == 7) ::: The pharmacy must be at one end of the row\nOr(located(restaurant1) == 1, located(restaurant1) == 7) ::: and one of the restaurants at the other\nAbs(located(restaurant1) - located(restaurant2)) >= 3 ::: The two restaurants must be separated by at least two other businesses\nOr(Abs(located(pharmacy) - located(optometrist)) == 1, Abs(located(pharmacy) - located(veterinarian)) == 1) ::: The pharmacy must be next to either the optometrist or the veterinarian\nAbs(located(toy_store) - located(veterinarian)) >= 2 ::: The toy store cannot be next to the veterinarian\nlocated(veterinarian) == 5 ::: If the veterinarian is in space 5\n\n# Options\nQuestion ::: If the veterinarian is in space 5, which one of the following must be true?\nis_sat(located(optometrist) == 2) ::: (A)\nis_sat(located(pharmacy) == 7) ::: (B)\nis_sat(located(restaurant1) == 4) ::: (C)\nis_sat(located(shoe_store) == 6) ::: (D)\nis_sat(located(toy_store) == 3) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201206_3-G_2_9",
    "context": "A shopping center has exactly seven spaces—space 1 through space 7—arranged in a straight row. Seven businesses—an optometrist, a pharmacy, two restaurants, a shoe store, a toy store, and a veterinarian—will be located in the shopping center, one in each space. The locations of the businesses are subject to the following constraints: The pharmacy must be at one end of the row and one of the restaurants at the other. The two restaurants must be separated by at least two other businesses. The pharmacy must be next to either the optometrist or the veterinarian. The toy store cannot be next to the veterinarian.",
    "question": "If the optometrist is next to the shoe store, the businesses immediately on either side of this pair must be",
    "answer": "D",
    "options": [
      "A) the pharmacy and a restaurant",
      "B) the pharmacy and the toy store",
      "C) the two restaurants",
      "D) a restaurant and the toy store",
      "E) a restaurant and the veterinarian"
    ],
    "raw_logic_programs": [
      "# Declarations\nspaces = EnumSort([1, 2, 3, 4, 5, 6, 7])\nbusinesses = EnumSort([optometrist, pharmacy, restaurant1, restaurant2, shoe_store, toy_store, veterinarian])\nlocated = Function([businesses] -> [spaces])\n\n# Constraints\nAnd(Or(located(pharmacy) == 1, located(pharmacy) == 7), Or(located(restaurant1) == 1, located(restaurant1) == 7, located(restaurant2) == 1, located(restaurant2) == 7)) ::: The pharmacy must be at one end of the row and one of the restaurants at the other\nForAll([b1:businesses, b2:businesses], Implies(And(b1 != b2, And(b1 == restaurant1, b2 == restaurant2, Or(b1 == restaurant2, b2 == restaurant1))), Abs(located(b1) - located(b2)) >= 3)) ::: The two restaurants must be separated by at least two other businesses\nOr(Abs(located(pharmacy) - located(optometrist)) == 1, Abs(located(pharmacy) - located(veterinarian)) == 1) ::: The pharmacy must be next to either the optometrist or the veterinarian\nAbs(located(toy_store) - located(veterinarian)) >= 2 ::: The toy store cannot be next to the veterinarian\n\n# Options\nQuestion ::: If the optometrist is next to the shoe store, the businesses immediately on either side of this pair must be\nis_sat(And(Abs(located(optometrist) - located(shoe_store)) == 1, And(Or(located(pharmacy) == located(optometrist) - 1, located(pharmacy) == located(optometrist) + 1), Or(located(restaurant1) == located(shoe_store) - 1, located(restaurant1) == located(shoe_store) + 1, located(restaurant2) == located(shoe_store) - 1, located(restaurant2) == located(shoe_store) + 1)))) ::: (A)\nis_sat(And(Abs(located(optometrist) - located(shoe_store)) == 1, And(Or(located(pharmacy) == located(optometrist) - 1, located(pharmacy) == located(optometrist) + 1), Or(located(toy_store) == located(shoe_store) - 1, located(toy_store) == located(shoe_store) + 1)))) ::: (B)\nis_sat(And(Abs(located(optometrist) - located(shoe_store)) == 1, And(Or(located(restaurant1) == located(optometrist) - 1, located(restaurant1) == located(optometrist) + 1, located(restaurant2) == located(optometrist) - 1, located(restaurant2) == located(optometrist) + 1), Or(located(restaurant1) == located(shoe_store) - 1, located(restaurant1) == located(shoe_store) + 1, located(restaurant2) == located(shoe_store) - 1, located(restaurant2) == located(shoe_store) + 1)))) ::: (C)\nis_sat(And(Abs(located(optometrist) - located(shoe_store)) == 1, And(Or(located(restaurant1) == located(optometrist) - 1, located(restaurant1) == located(optometrist) + 1, located(restaurant2) == located(optometrist) - 1, located(restaurant2) == located(optometrist) + 1), Or(located(toy_store) == located(shoe_store) - 1, located(toy_store) == located(shoe_store) + 1)))) ::: (D)\nis_sat(And(Abs(located(optometrist) - located(shoe_store)) == 1, And(Or(located(restaurant1) == located(optometrist) - 1, located(restaurant1) == located(optometrist) + 1, located(restaurant2) == located(optometrist) - 1, located(restaurant2) == located(optometrist) + 1), Or(located(veterinarian) == located(shoe_store) - 1, located(veterinarian) == located(shoe_store) + 1)))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201206_3-G_2_10",
    "context": "A shopping center has exactly seven spaces—space 1 through space 7—arranged in a straight row. Seven businesses—an optometrist, a pharmacy, two restaurants, a shoe store, a toy store, and a veterinarian—will be located in the shopping center, one in each space. The locations of the businesses are subject to the following constraints: The pharmacy must be at one end of the row and one of the restaurants at the other. The two restaurants must be separated by at least two other businesses. The pharmacy must be next to either the optometrist or the veterinarian. The toy store cannot be next to the veterinarian.",
    "question": "If the shoe store is in space 4, which one of the following must be true?",
    "answer": "B",
    "options": [
      "A) The optometrist is next to a restaurant.",
      "B) The pharmacy is next to the veterinarian.",
      "C) A restaurant is next to the toy store.",
      "D) The shoe store is next to the toy store.",
      "E) The shoe store is next to the veterinarian."
    ],
    "raw_logic_programs": [
      "# Declarations\nspaces = EnumSort([1, 2, 3, 4, 5, 6, 7])\nbusinesses = EnumSort([optometrist, pharmacy, restaurant1, restaurant2, shoe_store, toy_store, veterinarian])\nlocated = Function([businesses] -> [spaces])\n\n# Constraints\nForAll([b:businesses], Exists([s:spaces], located(b) == s)) ::: one in each space\nAnd(Or(located(pharmacy) == 1, located(pharmacy) == 7), Or(located(restaurant1) == 1, located(restaurant1) == 7, located(restaurant2) == 1, located(restaurant2) == 7)) ::: The pharmacy must be at one end of the row and one of the restaurants at the other\nForAll([s:spaces], Implies(And(located(restaurant1) == s, located(restaurant2) == s), Abs(s - located(restaurant2)) >= 3)) ::: The two restaurants must be separated by at least two other businesses\nOr(Abs(located(pharmacy) - located(optometrist)) == 1, Abs(located(pharmacy) - located(veterinarian)) == 1) ::: The pharmacy must be next to either the optometrist or the veterinarian\nForAll([s:spaces], Implies(And(located(toy_store) == s, located(veterinarian) == s), Abs(s - located(veterinarian)) != 1)) ::: The toy store cannot be next to the veterinarian\nlocated(shoe_store) == 4 ::: If the shoe store is in space 4\n\n# Options\nQuestion ::: If the shoe store is in space 4, which one of the following must be true?\nis_sat(Exists([s:spaces], And(Or(located(restaurant1) == s, located(restaurant2) == s), Abs(s - located(optometrist)) == 1))) ::: (A)\nis_sat(And(located(pharmacy) == 3, located(veterinarian) == 2)) ::: (B)\nis_sat(Exists([s:spaces], And(Or(located(restaurant1) == s, located(restaurant2) == s), Abs(s - located(toy_store)) == 1))) ::: (C)\nis_sat(And(located(shoe_store) == 4, located(toy_store) == 5)) ::: (D)\nis_sat(And(located(shoe_store) == 4, located(veterinarian) == 5)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201206_3-G_2_11",
    "context": "A shopping center has exactly seven spaces—space 1 through space 7—arranged in a straight row. Seven businesses—an optometrist, a pharmacy, two restaurants, a shoe store, a toy store, and a veterinarian—will be located in the shopping center, one in each space. The locations of the businesses are subject to the following constraints: The pharmacy must be at one end of the row and one of the restaurants at the other. The two restaurants must be separated by at least two other businesses. The pharmacy must be next to either the optometrist or the veterinarian. The toy store cannot be next to the veterinarian.",
    "question": "Which one of the following, if substituted for the constraint that the two restaurants must be separated by at least two other businesses, would have the same effect in determining the locations of the businesses?",
    "answer": "D",
    "options": [
      "A) A restaurant must be in either space 3, space 4, or space 5.",
      "B) A restaurant must be next to either the optometrist or the veterinarian.",
      "C) Either the toy store or the veterinarian must be somewhere between the two restaurants.",
      "D) No more than two businesses can separate the pharmacy and the restaurant nearest it.",
      "E) The optometrist cannot be next to the shoe store."
    ],
    "raw_logic_programs": [
      "# Declarations\nspaces = EnumSort([1, 2, 3, 4, 5, 6, 7])\nbusinesses = EnumSort([optometrist, pharmacy, restaurant1, restaurant2, shoe_store, toy_store, veterinarian])\nlocated = Function([businesses] -> [spaces])\n\n# Constraints\nAnd(Or(located(pharmacy) == 1, located(pharmacy) == 7), Or(located(restaurant1) == 1, located(restaurant1) == 7, located(restaurant2) == 1, located(restaurant2) == 7)) ::: The pharmacy must be at one end of the row and one of the restaurants at the other\nForAll([b1:businesses, b2:businesses], Implies(And(b1 != b2, And(b1 == restaurant1, b2 == restaurant2, Or(b1 == restaurant2, b2 == restaurant1))), Abs(located(b1) - located(b2)) >= 3)) ::: The two restaurants must be separated by at least two other businesses\nOr(Abs(located(pharmacy) - located(optometrist)) == 1, Abs(located(pharmacy) - located(veterinarian)) == 1) ::: The pharmacy must be next to either the optometrist or the veterinarian\nAbs(located(toy_store) - located(veterinarian)) != 1 ::: The toy store cannot be next to the veterinarian\n\n# Options\nQuestion ::: Which one of the following, if substituted for the constraint that the two restaurants must be separated by at least two other businesses, would have the same effect in determining the locations of the businesses?\nis_equivalent(ForAll([b:businesses], Implies(b == restaurant1, Or(located(b) == 3, located(b) == 4, located(b) == 5)))) ::: (A)\nis_equivalent(Or(Abs(located(restaurant1) - located(optometrist)) == 1, Abs(located(restaurant1) - located(veterinarian)) == 1, Abs(located(restaurant2) - located(optometrist)) == 1, Abs(located(restaurant2) - located(veterinarian)) == 1)) ::: (B)\nis_equivalent(Exists([b1:businesses, b2:businesses], And(And(b1 == restaurant1, b2 == restaurant2, Or(b1 == restaurant2, b2 == restaurant1)), And(located(b1) < located(toy_store), located(toy_store) < located(b2), Or(located(b1) < located(veterinarian), located(veterinarian) < located(b2)))))) ::: (C)\nis_equivalent(ForAll([b:businesses], Implies(And(b == restaurant1, Or(b == restaurant2, b == restaurant1)), Abs(located(pharmacy) - located(b)) <= 3))) ::: (D)\nis_equivalent(Abs(located(optometrist) - located(shoe_store)) != 1) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201206_3-G_3_12",
    "context": "A software company employs exactly seven sales representatives—Kim, Mahr, Parra, Quinn, Stuckey, Tiao, and Udall—to work in its three sales zones—Zone 1, Zone 2, and Zone 3. Each sales representative works in exactly one of the sales zones, in accordance with the following conditions: Either Parra or Tiao (but not both) works in Zone 1. Either Tiao or Udall (but not both) works in Zone 2. Parra and Quinn work in the same sales zone as each other. Stuckey and Udall work in the same sales zone as each other. There are more of the sales representatives working in Zone 3 than in Zone 2.",
    "question": "Which one of the following could be an accurate matching of the sales representatives to the sales zones in which they work?",
    "answer": "B",
    "options": [
      "A) Zone 1: Kim, Parra Zone 2: Stuckey, Udall Zone 3: Mahr, Quinn, Tiao",
      "B) Zone 1: Kim, Tiao Zone 2: Stuckey, Udall Zone 3: Mahr, Parra, Quinn",
      "C) Zone 1: Parra, Quinn Zone 2: Kim, Udall Zone 3: Mahr, Stuckey, Tiao",
      "D) Zone 1: Stuckey, Udall Zone 2: Kim, Tiao Zone 3: Mahr, Parra, Quinn",
      "E) Zone 1: Tiao Zone 2: Kim, Parra, Quinn Zone 3: Stuckey, Udall"
    ],
    "raw_logic_programs": [
      "# Declarations\nsales_reps = EnumSort([Kim, Mahr, Parra, Quinn, Stuckey, Tiao, Udall])\nzones = EnumSort([Zone1, Zone2, Zone3])\nworks_in = Function([sales_reps] -> [zones])\n\n# Constraints\nXor(works_in(Parra) == Zone1, works_in(Tiao) == Zone1) ::: Either Parra or Tiao (but not both) works in Zone 1\nXor(works_in(Tiao) == Zone2, works_in(Udall) == Zone2) ::: Either Tiao or Udall (but not both) works in Zone 2\nworks_in(Parra) == works_in(Quinn) ::: Parra and Quinn work in the same sales zone as each other\nworks_in(Stuckey) == works_in(Udall) ::: Stuckey and Udall work in the same sales zone as each other\nCount([r:sales_reps], works_in(r) == Zone3) > Count([r:sales_reps], works_in(r) == Zone2) ::: There are more of the sales representatives working in Zone 3 than in Zone 2\n\n# Options\nQuestion ::: Which one of the following could be an accurate matching of the sales representatives to the sales zones in which they work?\nis_sat(And(works_in(Kim) == Zone1, works_in(Parra) == Zone1, works_in(Stuckey) == Zone2, works_in(Udall) == Zone2, works_in(Mahr) == Zone3, works_in(Quinn) == Zone3, works_in(Tiao) == Zone3)) ::: (A)\nis_sat(And(works_in(Kim) == Zone1, works_in(Tiao) == Zone1, works_in(Stuckey) == Zone2, works_in(Udall) == Zone2, works_in(Mahr) == Zone3, works_in(Parra) == Zone3, works_in(Quinn) == Zone3)) ::: (B)\nis_sat(And(works_in(Parra) == Zone1, works_in(Quinn) == Zone1, works_in(Kim) == Zone2, works_in(Udall) == Zone2, works_in(Mahr) == Zone3, works_in(Stuckey) == Zone3, works_in(Tiao) == Zone3)) ::: (C)\nis_sat(And(works_in(Stuckey) == Zone1, works_in(Udall) == Zone1, works_in(Kim) == Zone2, works_in(Tiao) == Zone2, works_in(Mahr) == Zone3, works_in(Parra) == Zone3, works_in(Quinn) == Zone3)) ::: (D)\nis_sat(And(works_in(Tiao) == Zone1, works_in(Kim) == Zone2, works_in(Parra) == Zone2, works_in(Quinn) == Zone2, works_in(Stuckey) == Zone3, works_in(Udall) == Zone3)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201206_3-G_3_13",
    "context": "A software company employs exactly seven sales representatives—Kim, Mahr, Parra, Quinn, Stuckey, Tiao, and Udall—to work in its three sales zones—Zone 1, Zone 2, and Zone 3. Each sales representative works in exactly one of the sales zones, in accordance with the following conditions: Either Parra or Tiao (but not both) works in Zone 1. Either Tiao or Udall (but not both) works in Zone 2. Parra and Quinn work in the same sales zone as each other. Stuckey and Udall work in the same sales zone as each other. There are more of the sales representatives working in Zone 3 than in Zone 2.",
    "question": "If more sales representatives work in Zone 1 than in Zone 3, then which one of the following could be true?",
    "answer": "E",
    "options": [
      "A) Kim works in Zone 2.",
      "B) Mahr works in Zone 2.",
      "C) Parra works in Zone 3.",
      "D) Tiao works in Zone 1.",
      "E) Udall works in Zone 3."
    ],
    "raw_logic_programs": [
      "# Declarations\nsales_reps = EnumSort([Kim, Mahr, Parra, Quinn, Stuckey, Tiao, Udall])\nzones = EnumSort([Zone1, Zone2, Zone3])\nworks_in = Function([sales_reps] -> [zones])\n\n# Constraints\nXor(works_in(Parra) == Zone1, works_in(Tiao) == Zone1) ::: Either Parra or Tiao (but not both) works in Zone 1\nXor(works_in(Tiao) == Zone2, works_in(Udall) == Zone2) ::: Either Tiao or Udall (but not both) works in Zone 2\nworks_in(Parra) == works_in(Quinn) ::: Parra and Quinn work in the same sales zone as each other\nworks_in(Stuckey) == works_in(Udall) ::: Stuckey and Udall work in the same sales zone as each other\nCount([r:sales_reps], works_in(r) == Zone3) > Count([r:sales_reps], works_in(r) == Zone2) ::: There are more of the sales representatives working in Zone 3 than in Zone 2\n\n# Options\nQuestion ::: If more sales representatives work in Zone 1 than in Zone 3, then which one of the following could be true?\nis_sat(And(Count([r:sales_reps], works_in(r) == Zone1) > Count([r:sales_reps], works_in(r) == Zone3), works_in(Kim) == Zone2)) ::: (A)\nis_sat(And(Count([r:sales_reps], works_in(r) == Zone1) > Count([r:sales_reps], works_in(r) == Zone3), works_in(Mahr) == Zone2)) ::: (B)\nis_sat(And(Count([r:sales_reps], works_in(r) == Zone1) > Count([r:sales_reps], works_in(r) == Zone3), works_in(Parra) == Zone3)) ::: (C)\nis_sat(And(Count([r:sales_reps], works_in(r) == Zone1) > Count([r:sales_reps], works_in(r) == Zone3), works_in(Tiao) == Zone1)) ::: (D)\nis_sat(And(Count([r:sales_reps], works_in(r) == Zone1) > Count([r:sales_reps], works_in(r) == Zone3), works_in(Udall) == Zone3)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201206_3-G_3_14",
    "context": "A software company employs exactly seven sales representatives—Kim, Mahr, Parra, Quinn, Stuckey, Tiao, and Udall—to work in its three sales zones—Zone 1, Zone 2, and Zone 3. Each sales representative works in exactly one of the sales zones, in accordance with the following conditions: Either Parra or Tiao (but not both) works in Zone 1. Either Tiao or Udall (but not both) works in Zone 2. Parra and Quinn work in the same sales zone as each other. Stuckey and Udall work in the same sales zone as each other. There are more of the sales representatives working in Zone 3 than in Zone 2.",
    "question": "Which one of the following must be false?",
    "answer": "A",
    "options": [
      "A) Kim and Stuckey both work in Zone 1.",
      "B) Kim and Stuckey both work in Zone 3.",
      "C) Mahr and Stuckey both work in Zone 3.",
      "D) Mahr and Udall both work in Zone 3.",
      "E) Parra and Stuckey both work in Zone I."
    ],
    "raw_logic_programs": [
      "# Declarations\nsales_reps = EnumSort([Kim, Mahr, Parra, Quinn, Stuckey, Tiao, Udall])\nzones = EnumSort([Zone1, Zone2, Zone3])\nworks_in = Function([sales_reps] -> [zones])\n\n# Constraints\nXor(works_in(Parra) == Zone1, works_in(Tiao) == Zone1) ::: Either Parra or Tiao (but not both) works in Zone 1\nXor(works_in(Tiao) == Zone2, works_in(Udall) == Zone2) ::: Either Tiao or Udall (but not both) works in Zone 2\nworks_in(Parra) == works_in(Quinn) ::: Parra and Quinn work in the same sales zone as each other\nworks_in(Stuckey) == works_in(Udall) ::: Stuckey and Udall work in the same sales zone as each other\nCount([r:sales_reps], works_in(r) == Zone3) > Count([r:sales_reps], works_in(r) == Zone2) ::: There are more of the sales representatives working in Zone 3 than in Zone 2\n\n# Options\nQuestion ::: Which one of the following must be false?\nis_unsat(And(works_in(Kim) == Zone1, works_in(Stuckey) == Zone1)) ::: (A)\nis_unsat(And(works_in(Kim) == Zone3, works_in(Stuckey) == Zone3)) ::: (B)\nis_unsat(And(works_in(Mahr) == Zone3, works_in(Stuckey) == Zone3)) ::: (C)\nis_unsat(And(works_in(Mahr) == Zone3, works_in(Udall) == Zone3)) ::: (D)\nis_unsat(And(works_in(Parra) == Zone1, works_in(Stuckey) == Zone1)) ::: (E)\n\nProblem:\nA group of five friends—Alice, Bob, Carol, David, and Emily—are planning a trip to a theme park. Each friend will ride exactly one of the five roller coasters—the Cyclone, the Dragon, the Fury, the Hurricane, and the Inferno—and no two friends will ride the same roller coaster. The following conditions apply: Alice will ride either the Cyclone or the Fury. Bob will ride either the Dragon or the Hurricane. Carol will ride either the Fury or the Inferno. David will ride either the Cyclone or the Hurricane. Emily will ride either the Dragon or the Inferno.\nQuestion:\nIf Alice rides the Fury, which one of the following must be true?\nChoices:\n(A) Bob rides the Dragon.\n(B) Carol rides the Inferno.\n(C) David rides the Cyclone.\n(D) Emily rides the Inferno.\n(E) None of the above\n###\n# Declarations\nfriends = EnumSort([Alice, Bob, Carol, David, Emily])\ncoasters = EnumSort([Cyclone, Dragon, Fury, Hurricane, Inferno])\nrides = Function([friends] -> [coasters])\n\n# Constraints\nForAll([f:friends], Exists([c:coasters], rides(f) == c)) ::: Each friend will ride exactly one of the five roller coasters\nDistinct([f:friends], rides(f)) ::: no two friends will ride the same roller coaster\nOr(rides(Alice) == Cyclone, rides(Alice) == Fury) ::: Alice will ride either the Cyclone or the Fury\nOr(rides(Bob) == Dragon, rides(Bob) == Hurricane) ::: Bob will ride either the Dragon or the Hurricane\nOr(rides(Carol) == Fury, rides(Carol) == Inferno) ::: Carol will ride either the Fury or the Inferno\nOr(rides(David) == Cyclone, rides(David) == Hurricane) ::: David will ride either the Cyclone or the Hurricane\nOr(rides(Emily) == Dragon, rides(Emily) == Inferno) ::: Emily will ride either the Dragon or the Inferno\nrides(Alice) == Fury ::: If Alice rides the Fury\n\n# Options\nQuestion ::: If Alice rides the Fury, which one of the following must be true?\nis_sat(rides(Bob) == Dragon) ::: (A)\nis_sat(rides(Carol) == Inferno) ::: (B)\nis_sat(rides(David) == Cyclone) ::: (C)\nis_sat(rides(Emily) == Inferno) ::: (D)\nis_sat(False) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201206_3-G_3_15",
    "context": "A software company employs exactly seven sales representatives—Kim, Mahr, Parra, Quinn, Stuckey, Tiao, and Udall—to work in its three sales zones—Zone 1, Zone 2, and Zone 3. Each sales representative works in exactly one of the sales zones, in accordance with the following conditions: Either Parra or Tiao (but not both) works in Zone 1. Either Tiao or Udall (but not both) works in Zone 2. Parra and Quinn work in the same sales zone as each other. Stuckey and Udall work in the same sales zone as each other. There are more of the sales representatives working in Zone 3 than in Zone 2.",
    "question": "Which one of the following could be a complete and accurate list of the sales representatives working in Zone 3?",
    "answer": "A",
    "options": [
      "A) Kim, Mahr",
      "B) Kim, Tiao",
      "C) Parra, Quinn",
      "D) Stuckey, Tiao, Udall",
      "E) Parra, Quinn, Stuckey, Udall"
    ],
    "raw_logic_programs": [
      "# Declarations\nsales_reps = EnumSort([Kim, Mahr, Parra, Quinn, Stuckey, Tiao, Udall])\nzones = EnumSort([Zone1, Zone2, Zone3])\nworks_in = Function([sales_reps] -> [zones])\n\n# Constraints\nXor(works_in(Parra) == Zone1, works_in(Tiao) == Zone1) ::: Either Parra or Tiao (but not both) works in Zone 1\nXor(works_in(Tiao) == Zone2, works_in(Udall) == Zone2) ::: Either Tiao or Udall (but not both) works in Zone 2\nworks_in(Parra) == works_in(Quinn) ::: Parra and Quinn work in the same sales zone as each other\nworks_in(Stuckey) == works_in(Udall) ::: Stuckey and Udall work in the same sales zone as each other\nCount([r:sales_reps], works_in(r) == Zone3) > Count([r:sales_reps], works_in(r) == Zone2) ::: There are more of the sales representatives working in Zone 3 than in Zone 2\n\n# Options\nQuestion ::: Which one of the following could be a complete and accurate list of the sales representatives working in Zone 3?\nis_accurate_list([works_in(Kim) == Zone3, works_in(Mahr) == Zone3]) ::: (A)\nis_accurate_list([works_in(Kim) == Zone3, works_in(Tiao) == Zone3]) ::: (B)\nis_accurate_list([works_in(Parra) == Zone3, works_in(Quinn) == Zone3]) ::: (C)\nis_accurate_list([works_in(Stuckey) == Zone3, works_in(Tiao) == Zone3, works_in(Udall) == Zone3]) ::: (D)\nis_accurate_list([works_in(Parra) == Zone3, works_in(Quinn) == Zone3, works_in(Stuckey) == Zone3, works_in(Udall) == Zone3]) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201206_3-G_3_16",
    "context": "A software company employs exactly seven sales representatives—Kim, Mahr, Parra, Quinn, Stuckey, Tiao, and Udall—to work in its three sales zones—Zone 1, Zone 2, and Zone 3. Each sales representative works in exactly one of the sales zones, in accordance with the following conditions: Either Parra or Tiao (but not both) works in Zone 1. Either Tiao or Udall (but not both) works in Zone 2. Parra and Quinn work in the same sales zone as each other. Stuckey and Udall work in the same sales zone as each other. There are more of the sales representatives working in Zone 3 than in Zone 2.",
    "question": "Quinn CANNOT work in the same sales zone as which one of the following?",
    "answer": "D",
    "options": [
      "A) Kim",
      "B) Mahr",
      "C) Stuckey",
      "D) Tiao",
      "E) Udall"
    ],
    "raw_logic_programs": [
      "# Declarations\nsales_reps = EnumSort([Kim, Mahr, Parra, Quinn, Stuckey, Tiao, Udall])\nzones = EnumSort([Zone1, Zone2, Zone3])\nworks_in = Function([sales_reps] -> [zones])\n\n# Constraints\nXor(works_in(Parra) == Zone1, works_in(Tiao) == Zone1) ::: Either Parra or Tiao (but not both) works in Zone 1\nXor(works_in(Tiao) == Zone2, works_in(Udall) == Zone2) ::: Either Tiao or Udall (but not both) works in Zone 2\nworks_in(Parra) == works_in(Quinn) ::: Parra and Quinn work in the same sales zone as each other\nworks_in(Stuckey) == works_in(Udall) ::: Stuckey and Udall work in the same sales zone as each other\nCount([r:sales_reps], works_in(r) == Zone3) > Count([r:sales_reps], works_in(r) == Zone2) ::: There are more of the sales representatives working in Zone 3 than in Zone 2\n\n# Options\nQuestion ::: Quinn CANNOT work in the same sales zone as which one of the following?\nis_unsat(works_in(Quinn) == works_in(Kim)) ::: (A)\nis_unsat(works_in(Quinn) == works_in(Mahr)) ::: (B)\nis_unsat(works_in(Quinn) == works_in(Stuckey)) ::: (C)\nis_unsat(works_in(Quinn) == works_in(Tiao)) ::: (D)\nis_unsat(works_in(Quinn) == works_in(Udall)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201206_3-G_3_17",
    "context": "A software company employs exactly seven sales representatives—Kim, Mahr, Parra, Quinn, Stuckey, Tiao, and Udall—to work in its three sales zones—Zone 1, Zone 2, and Zone 3. Each sales representative works in exactly one of the sales zones, in accordance with the following conditions: Either Parra or Tiao (but not both) works in Zone 1. Either Tiao or Udall (but not both) works in Zone 2. Parra and Quinn work in the same sales zone as each other. Stuckey and Udall work in the same sales zone as each other. There are more of the sales representatives working in Zone 3 than in Zone 2.",
    "question": "If Mahr and Stuckey work in the same sales zone, then which one of the following could be true?",
    "answer": "A",
    "options": [
      "A) Kim works in Zone 2.",
      "B) Mahr works in Zone 1.",
      "C) Parra works in Zone 3.",
      "D) Stuckey works in Zone 2.",
      "E) Tiao works in Zone 1."
    ],
    "raw_logic_programs": [
      "# Declarations\nsales_reps = EnumSort([Kim, Mahr, Parra, Quinn, Stuckey, Tiao, Udall])\nzones = EnumSort([Zone1, Zone2, Zone3])\nworks_in = Function([sales_reps] -> [zones])\n\n# Constraints\nXor(works_in(Parra) == Zone1, works_in(Tiao) == Zone1) ::: Either Parra or Tiao (but not both) works in Zone 1\nXor(works_in(Tiao) == Zone2, works_in(Udall) == Zone2) ::: Either Tiao or Udall (but not both) works in Zone 2\nworks_in(Parra) == works_in(Quinn) ::: Parra and Quinn work in the same sales zone as each other\nworks_in(Stuckey) == works_in(Udall) ::: Stuckey and Udall work in the same sales zone as each other\nCount([r:sales_reps], works_in(r) == Zone3) > Count([r:sales_reps], works_in(r) == Zone2) ::: There are more of the sales representatives working in Zone 3 than in Zone 2\nworks_in(Mahr) == works_in(Stuckey) ::: If Mahr and Stuckey work in the same sales zone\n\n# Options\nQuestion ::: then which one of the following could be true?\nis_sat(works_in(Kim) == Zone2) ::: (A)\nis_sat(works_in(Mahr) == Zone1) ::: (B)\nis_sat(works_in(Parra) == Zone3) ::: (C)\nis_sat(works_in(Stuckey) == Zone2) ::: (D)\nis_sat(works_in(Tiao) == Zone1) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201206_3-G_4_18",
    "context": "During a recital, two pianists—Wayne and Zara—will perform solos. There will be five solos altogether, performed one immediately after another. Each solo will be either a modern piece or a traditional piece. The choice of pianist and type of piece for the solos must conform to the following conditions: The third solo is a traditional piece. Exactly two of the traditional pieces are performed consecutively. In the fourth solo, either Wayne performs a traditional piece or Zara performs a modern piece. The pianist who performs the second solo does not perform the fifth solo. No traditional piece is performed until Wayne performs at least one modem piece.",
    "question": "Which one of the following could be all of the solos that are traditional pieces?",
    "answer": "C",
    "options": [
      "A) the first, third, and fourth",
      "B) the second, third, and fourth",
      "C) the third and fourth",
      "D) the third and fifth",
      "E) the fourth and fifth"
    ],
    "raw_logic_programs": [
      "# Declarations\npianists = EnumSort([Wayne, Zara])\nsolos = EnumSort([1, 2, 3, 4, 5])\npieces = EnumSort([modern, traditional])\nperforms = Function([solos, pianists] -> [pieces])\n\n# Constraints\nperforms(3, _) == traditional ::: The third solo is a traditional piece\nCount([s:solos], And(performs(s, _) == traditional, performs(s + 1, _) == traditional)) == 2 ::: Exactly two of the traditional pieces are performed consecutively\nOr(And(performs(4, Wayne) == traditional, performs(4, Zara) == modern), And(performs(4, Wayne) == modern, performs(4, Zara) == traditional)) ::: In the fourth solo, either Wayne performs a traditional piece or Zara performs a modern piece\nForAll([p:pianists], Implies(performs(2, p) == traditional, performs(5, p) == modern)) ::: The pianist who performs the second solo does not perform the fifth solo\nForAll([s:solos], Implies(performs(s, _) == traditional, Exists([s1:solos], And(s1 < s, performs(s1, Wayne) == modern)))) ::: No traditional piece is performed until Wayne performs at least one modem piece\n\n# Options\nQuestion ::: Which one of the following could be all of the solos that are traditional pieces?\nis_valid(And(performs(1, _) == traditional, performs(3, _) == traditional, performs(4, _) == traditional)) ::: (A)\nis_valid(And(performs(2, _) == traditional, performs(3, _) == traditional, performs(4, _) == traditional)) ::: (B)\nis_valid(And(performs(3, _) == traditional, performs(4, _) == traditional)) ::: (C)\nis_valid(And(performs(3, _) == traditional, performs(5, _) == traditional)) ::: (D)\nis_valid(And(performs(4, _) == traditional, performs(5, _) == traditional)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201206_3-G_4_19",
    "context": "During a recital, two pianists—Wayne and Zara—will perform solos. There will be five solos altogether, performed one immediately after another. Each solo will be either a modern piece or a traditional piece. The choice of pianist and type of piece for the solos must conform to the following conditions: The third solo is a traditional piece. Exactly two of the traditional pieces are performed consecutively. In the fourth solo, either Wayne performs a traditional piece or Zara performs a modern piece. The pianist who performs the second solo does not perform the fifth solo. No traditional piece is performed until Wayne performs at least one modem piece.",
    "question": "What is the minimum number of solos in which Wayne performs a traditional piece?",
    "answer": "A",
    "options": [
      "A) zero",
      "B) one",
      "C) two",
      "D) three",
      "E) four"
    ],
    "raw_logic_programs": [
      "# Declarations\npianists = EnumSort([Wayne, Zara])\nsolos = EnumSort([1, 2, 3, 4, 5])\npieces = EnumSort([modern, traditional])\nperforms = Function([solos, pianists] -> [pieces])\n\n# Constraints\nperforms(3, _) == traditional ::: The third solo is a traditional piece\nExists([s:solos], And(performs(s, _) == traditional, performs(s + 1, _) == traditional)) ::: Exactly two of the traditional pieces are performed consecutively\nOr(performs(4, Wayne) == traditional, performs(4, Zara) == modern) ::: In the fourth solo, either Wayne performs a traditional piece or Zara performs a modern piece\nNot(performs(2, _) == performs(5, _)) ::: The pianist who performs the second solo does not perform the fifth solo\nForAll([s:solos], Implies(performs(s, _) == traditional, Exists([s1:solos], And(s1 < s, performs(s1, Wayne) == modern)))) ::: No traditional piece is performed until Wayne performs at least one modem piece\n\n# Options\nQuestion ::: What is the minimum number of solos in which Wayne performs a traditional piece?\nis_valid(Count([s:solos], performs(s, Wayne) == traditional) == 0) ::: (A)\nis_valid(Count([s:solos], performs(s, Wayne) == traditional) == 1) ::: (B)\nis_valid(Count([s:solos], performs(s, Wayne) == traditional) == 2) ::: (C)\nis_valid(Count([s:solos], performs(s, Wayne) == traditional) == 3) ::: (D)\nis_valid(Count([s:solos], performs(s, Wayne) == traditional) == 4) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201206_3-G_4_20",
    "context": "During a recital, two pianists—Wayne and Zara—will perform solos. There will be five solos altogether, performed one immediately after another. Each solo will be either a modern piece or a traditional piece. The choice of pianist and type of piece for the solos must conform to the following conditions: The third solo is a traditional piece. Exactly two of the traditional pieces are performed consecutively. In the fourth solo, either Wayne performs a traditional piece or Zara performs a modern piece. The pianist who performs the second solo does not perform the fifth solo. No traditional piece is performed until Wayne performs at least one modem piece.",
    "question": "If the pianist who performs the first solo also performs the second solo, then which one of the following must be true?",
    "answer": "C",
    "options": [
      "A) Zara performs the first solo.",
      "B) Wayne performs the third solo.",
      "C) Zara performs the fifth solo.",
      "D) The second solo is a traditional piece.",
      "E) The fourth solo is a modem piece."
    ],
    "raw_logic_programs": [
      "# Declarations\npianists = EnumSort([Wayne, Zara])\nsolos = EnumSort([1, 2, 3, 4, 5])\npieces = EnumSort([modern, traditional])\nperforms = Function([solos, pianists] -> [bool])\ntype_of = Function([solos] -> [pieces])\n\n# Constraints\ntype_of(3) == traditional ::: The third solo is a traditional piece\nCount([s:solos], And(type_of(s) == traditional, type_of(s + 1) == traditional)) == 2 ::: Exactly two of the traditional pieces are performed consecutively\nOr(And(performs(4, Wayne), type_of(4) == traditional), And(performs(4, Zara), type_of(4) == modern)) ::: In the fourth solo, either Wayne performs a traditional piece or Zara performs a modern piece\nNot(performs(2, Wayne) == performs(5, Wayne)) ::: The pianist who performs the second solo does not perform the fifth solo\nForAll([s:solos], Implies(type_of(s) == traditional, Exists([s1:solos], And(s1 < s, performs(s1, Wayne), type_of(s1) == modern)))) ::: No traditional piece is performed until Wayne performs at least one modem piece\nAnd(performs(1, Wayne), performs(2, Wayne)) ::: If the pianist who performs the first solo also performs the second solo\n\n# Options\nQuestion ::: If the pianist who performs the first solo also performs the second solo, then which one of the following must be true?\nis_valid(performs(1, Zara)) ::: (A)\nis_valid(performs(3, Wayne)) ::: (B)\nis_valid(performs(5, Zara)) ::: (C)\nis_valid(type_of(2) == traditional) ::: (D)\nis_valid(type_of(4) == modern) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201206_3-G_4_21",
    "context": "During a recital, two pianists—Wayne and Zara—will perform solos. There will be five solos altogether, performed one immediately after another. Each solo will be either a modern piece or a traditional piece. The choice of pianist and type of piece for the solos must conform to the following conditions: The third solo is a traditional piece. Exactly two of the traditional pieces are performed consecutively. In the fourth solo, either Wayne performs a traditional piece or Zara performs a modern piece. The pianist who performs the second solo does not perform the fifth solo. No traditional piece is performed until Wayne performs at least one modem piece.",
    "question": "If the fifth solo is a traditional piece, then for exactly determined?",
    "answer": "B",
    "options": [
      "A) one",
      "B) two",
      "C) three",
      "D) four",
      "E) five"
    ],
    "raw_logic_programs": [
      "# Declarations\npianists = EnumSort([Wayne, Zara])\nsolos = EnumSort([1, 2, 3, 4, 5])\npieces = EnumSort([modern, traditional])\nperforms = Function([solos, pianists] -> [pieces])\n\n# Constraints\nperforms(3, _) == traditional ::: The third solo is a traditional piece\nCount([s:solos], And(s < 5, performs(s, _) == traditional, performs(s + 1, _) == traditional)) == 1 ::: Exactly two of the traditional pieces are performed consecutively\nOr(And(performs(4, Wayne) == traditional, performs(4, Zara) == modern), And(performs(4, Wayne) == modern, performs(4, Zara) == traditional)) ::: In the fourth solo, either Wayne performs a traditional piece or Zara performs a modern piece\nForAll([p:pianists], Implies(performs(2, p) == traditional, performs(5, p) == modern)) ::: The pianist who performs the second solo does not perform the fifth solo\nForAll([s:solos], Implies(performs(s, _) == traditional, Exists([s1:solos], And(s1 < s, performs(s1, Wayne) == modern)))) ::: No traditional piece is performed until Wayne performs at least one modem piece\nperforms(5, _) == traditional ::: If the fifth solo is a traditional piece\n\n# Options\nQuestion ::: If the fifth solo is a traditional piece, then for exactly determined?\nis_determined(performs(1, Wayne)) ::: (A)\nis_determined(And(performs(1, Wayne), performs(2, Wayne))) ::: (B)\nis_determined(And(performs(1, Wayne), performs(2, Wayne), performs(3, Wayne))) ::: (C)\nis_determined(And(performs(1, Wayne), performs(2, Wayne), performs(3, Wayne), performs(4, Wayne))) ::: (D)\nis_determined(And(performs(1, Wayne), performs(2, Wayne), performs(3, Wayne), performs(4, Wayne), performs(5, Wayne))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201206_3-G_4_22",
    "context": "During a recital, two pianists—Wayne and Zara—will perform solos. There will be five solos altogether, performed one immediately after another. Each solo will be either a modern piece or a traditional piece. The choice of pianist and type of piece for the solos must conform to the following conditions: The third solo is a traditional piece. Exactly two of the traditional pieces are performed consecutively. In the fourth solo, either Wayne performs a traditional piece or Zara performs a modern piece. The pianist who performs the second solo does not perform the fifth solo. No traditional piece is performed until Wayne performs at least one modem piece.",
    "question": "If in the fifth solo Wayne performs a traditional piece, which one of the following could be true?",
    "answer": "C",
    "options": [
      "A) Zara performs the first solo.",
      "B) Wayne performs the second solo.",
      "C) Zara performs the third solo.",
      "D) The second solo is a modem piece.",
      "E) The fourth solo is a traditional piece."
    ],
    "raw_logic_programs": [
      "# Declarations\npianists = EnumSort([Wayne, Zara])\nsolos = EnumSort([1, 2, 3, 4, 5])\npieces = EnumSort([modern, traditional])\nperforms = Function([solos, pianists] -> [pieces])\n\n# Constraints\nperforms(3, _) == traditional ::: The third solo is a traditional piece\nCount([s:solos], And(s < 5, performs(s, _) == traditional, performs(s + 1, _) == traditional)) == 2 ::: Exactly two of the traditional pieces are performed consecutively\nOr(performs(4, Wayne) == traditional, performs(4, Zara) == modern) ::: In the fourth solo, either Wayne performs a traditional piece or Zara performs a modern piece\nNot(performs(2, _) == performs(5, _)) ::: The pianist who performs the second solo does not perform the fifth solo\nForAll([s:solos], Implies(performs(s, _) == traditional, Exists([s1:solos], And(s1 < s, performs(s1, Wayne) == modern)))) ::: No traditional piece is performed until Wayne performs at least one modem piece\nperforms(5, Wayne) == traditional ::: If in the fifth solo Wayne performs a traditional piece\n\n# Options\nQuestion ::: Which one of the following could be true?\nis_sat(performs(1, Zara) == modern) ::: (A)\nis_sat(performs(2, Wayne) == modern) ::: (B)\nis_sat(performs(3, Zara) == modern) ::: (C)\nis_sat(performs(2, _) == modern) ::: (D)\nis_sat(performs(4, _) == traditional) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201212_4-G_1_1",
    "context": "A realtor will show a prospective buyer seven houses—J, K, L, M, N, 0, and P—during a single day. The first and second houses to be shown will be shown in the morning; the third, fourth, and fifth houses to be shown will be shown in the afternoon; the sixth and seventh houses to be shown will be shown in the evening. The houses will be shown according to the following rules: J must be shown in the evening. K cannot be shown in the morning. L must be shown at some time after K is shown and at some time before M is shown.",
    "question": "Which one of the following could be the order, from first through seventh, in which the realtor shows the houses?",
    "answer": "C",
    "options": [
      "A) K, 0, L, M, N, J, P",
      "B) N, L, P, K, M, 0, J",
      "C) 0, P, K, L, N, M, J",
      "D) 0, P, M, N, K, L, J",
      "E) P, 0, K, J, L, N, M"
    ],
    "raw_logic_programs": [
      "# Declarations\nhouses = EnumSort([J, K, L, M, N, O, P])\nshow_order = Function([houses] -> [int])\nForAll([h:houses], And(1 <= show_order(h), show_order(h) <= 7))\n\n# Constraints\nAnd(show_order(J) > 5, show_order(J) <= 7) ::: J must be shown in the evening\nAnd(show_order(K) > 2, show_order(K) <= 7) ::: K cannot be shown in the morning\nAnd(show_order(L) > show_order(K), show_order(L) < show_order(M)) ::: L must be shown at some time after K is shown and at some time before M is shown\n\n# Options\nQuestion ::: Which one of the following could be the order, from first through seventh, in which the realtor shows the houses?\nis_sat(And(show_order(K) == 1, show_order(O) == 2, show_order(L) == 3, show_order(M) == 4, show_order(N) == 5, show_order(J) == 6, show_order(P) == 7)) ::: (A)\nis_sat(And(show_order(N) == 1, show_order(L) == 2, show_order(P) == 3, show_order(K) == 4, show_order(M) == 5, show_order(O) == 6, show_order(J) == 7)) ::: (B)\nis_sat(And(show_order(O) == 1, show_order(P) == 2, show_order(K) == 3, show_order(L) == 4, show_order(N) == 5, show_order(M) == 6, show_order(J) == 7)) ::: (C)\nis_sat(And(show_order(O) == 1, show_order(P) == 2, show_order(M) == 3, show_order(N) == 4, show_order(K) == 5, show_order(L) == 6, show_order(J) == 7)) ::: (D)\nis_sat(And(show_order(P) == 1, show_order(O) == 2, show_order(K) == 3, show_order(J) == 4, show_order(L) == 5, show_order(N) == 6, show_order(M) == 7)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201212_4-G_1_2",
    "context": "A realtor will show a prospective buyer seven houses—J, K, L, M, N, 0, and P—during a single day. The first and second houses to be shown will be shown in the morning; the third, fourth, and fifth houses to be shown will be shown in the afternoon; the sixth and seventh houses to be shown will be shown in the evening. The houses will be shown according to the following rules: J must be shown in the evening. K cannot be shown in the morning. L must be shown at some time after K is shown and at some time before M is shown.",
    "question": "Which one of the following is a pair of houses that CANNOT be shown consecutively in either order?",
    "answer": "A",
    "options": [
      "A) J, K",
      "B) J, M",
      "C) J, O",
      "D) J, P",
      "E) M, P"
    ],
    "raw_logic_programs": [
      "# Declarations\nhouses = EnumSort([J, K, L, M, N, O, P])\nshow_time = EnumSort([morning, afternoon, evening])\nshown = Function([houses] -> [show_time])\n\n# Constraints\nForAll([h:houses], Or(shown(h) == morning, shown(h) == afternoon, shown(h) == evening)) ::: each house is shown at one of the three times\nAnd(shown(J) == evening, shown(K) != morning) ::: J must be shown in the evening. K cannot be shown in the morning\nAnd(shown(L) > shown(K), shown(L) < shown(M)) ::: L must be shown at some time after K is shown and at some time before M is shown\n\n# Options\nQuestion ::: Which one of the following is a pair of houses that CANNOT be shown consecutively in either order?\nis_unsat(Or(And(shown(J) == morning, shown(K) == afternoon), And(shown(K) == morning, shown(J) == afternoon))) ::: (A)\nis_unsat(Or(And(shown(J) == morning, shown(M) == afternoon), And(shown(M) == morning, shown(J) == afternoon))) ::: (B)\nis_unsat(Or(And(shown(J) == morning, shown(O) == afternoon), And(shown(O) == morning, shown(J) == afternoon))) ::: (C)\nis_unsat(Or(And(shown(J) == morning, shown(P) == afternoon), And(shown(P) == morning, shown(J) == afternoon))) ::: (D)\nis_unsat(Or(And(shown(M) == morning, shown(P) == afternoon), And(shown(P) == morning, shown(M) == afternoon))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201212_4-G_1_3",
    "context": "A realtor will show a prospective buyer seven houses—J, K, L, M, N, 0, and P—during a single day. The first and second houses to be shown will be shown in the morning; the third, fourth, and fifth houses to be shown will be shown in the afternoon; the sixth and seventh houses to be shown will be shown in the evening. The houses will be shown according to the following rules: J must be shown in the evening. K cannot be shown in the morning. L must be shown at some time after K is shown and at some time before M is shown.",
    "question": "Which one of the following must be true?",
    "answer": "B",
    "options": [
      "A) K is shown in the evening.",
      "B) L is shown in the afternoon.",
      "C) L is shown in the evening.",
      "D) M is shown in the morning.",
      "E) M is shown in the afternoon."
    ],
    "raw_logic_programs": [
      "# Declarations\nhouses = EnumSort([J, K, L, M, N, O, P])\ntimes = EnumSort([morning, afternoon, evening])\nshown = Function([houses] -> [times])\n\n# Constraints\nForAll([h:houses], Or(shown(h) == morning, shown(h) == afternoon, shown(h) == evening)) ::: each house is shown at one of the three times\nAnd(shown(J) == evening, shown(K) != morning) ::: J must be shown in the evening. K cannot be shown in the morning\nAnd(shown(L) > shown(K), shown(L) < shown(M)) ::: L must be shown at some time after K is shown and at some time before M is shown\n\n# Options\nQuestion ::: Which one of the following must be true?\nis_sat(shown(K) == evening) ::: (A)\nis_sat(shown(L) == afternoon) ::: (B)\nis_sat(shown(L) == evening) ::: (C)\nis_sat(shown(M) == morning) ::: (D)\nis_sat(shown(M) == afternoon) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201212_4-G_1_4",
    "context": "A realtor will show a prospective buyer seven houses—J, K, L, M, N, 0, and P—during a single day. The first and second houses to be shown will be shown in the morning; the third, fourth, and fifth houses to be shown will be shown in the afternoon; the sixth and seventh houses to be shown will be shown in the evening. The houses will be shown according to the following rules: J must be shown in the evening. K cannot be shown in the morning. L must be shown at some time after K is shown and at some time before M is shown.",
    "question": "Which one of the following could be true?",
    "answer": "C",
    "options": [
      "A) K is shown at some time after J is shown.",
      "B) L is shown at some time after J is shown.",
      "C) P is shown at some time after J is shown.",
      "D) Both N and O are shown at some time after M is",
      "E) Both N and P are shown at some time after K is"
    ],
    "raw_logic_programs": [
      "# Declarations\nhouses = EnumSort([J, K, L, M, N, O, P])\ntimes = EnumSort([morning, afternoon, evening])\nshown = Function([houses] -> [times])\n\n# Constraints\nForAll([h:houses], Exists([t:times], shown(h) == t)) ::: each house is shown at some time\nAnd(shown(J) == evening, shown(K) != morning) ::: J must be shown in the evening. K cannot be shown in the morning\nAnd(shown(L) > shown(K), shown(L) < shown(M)) ::: L must be shown at some time after K is shown and at some time before M is shown\nAnd(shown(J) == evening, shown(K) != morning) ::: J must be shown in the evening. K cannot be shown in the morning\nAnd(shown(L) > shown(K), shown(L) < shown(M)) ::: L must be shown at some time after K is shown and at some time before M is shown\nAnd(shown(J) == evening, shown(K) != morning) ::: J must be shown in the evening. K cannot be shown in the morning\nAnd(shown(L) > shown(K), shown(L) < shown(M)) ::: L must be shown at some time after K is shown and at some time before M is shown\nAnd(shown(J) == evening, shown(K) != morning) ::: J must be shown in the evening. K cannot be shown in the morning\nAnd(shown(L) > shown(K), shown(L) < shown(M)) ::: L must be shown at some time after K is shown and at some time before M is shown\n\n# Options\nQuestion ::: Which one of the following could be true?\nis_sat(shown(K) > shown(J)) ::: (A)\nis_sat(shown(L) > shown(J)) ::: (B)\nis_sat(shown(P) > shown(J)) ::: (C)\nis_sat(And(shown(N) > shown(M), shown(O) > shown(M))) ::: (D)\nis_sat(And(shown(N) > shown(K), shown(P) > shown(K))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201212_4-G_1_5",
    "context": "A realtor will show a prospective buyer seven houses—J, K, L, M, N, 0, and P—during a single day. The first and second houses to be shown will be shown in the morning; the third, fourth, and fifth houses to be shown will be shown in the afternoon; the sixth and seventh houses to be shown will be shown in the evening. The houses will be shown according to the following rules: J must be shown in the evening. K cannot be shown in the morning. L must be shown at some time after K is shown and at some time before M is shown.",
    "question": "If P is shown in the afternoon, which one of the following must be true?",
    "answer": "E",
    "options": [
      "A) J is shown seventh.",
      "B) K is shown third.",
      "C) N is shown first.",
      "D) M is shown in the afternoon.",
      "E) O is shown in the morning."
    ],
    "raw_logic_programs": [
      "# Declarations\nhouses = EnumSort([J, K, L, M, N, O, P])\ntimes = EnumSort([morning, afternoon, evening])\nshown = Function([houses] -> [times])\n\n# Constraints\nForAll([h:houses], Or(shown(h) == morning, shown(h) == afternoon, shown(h) == evening))\nshown(J) == evening\nshown(K) != morning\nAnd(shown(L) > shown(K), shown(L) < shown(M))\nshown(P) == afternoon\n\n# Options\nQuestion ::: If P is shown in the afternoon, which one of the following must be true?\nis_sat(And(shown(P) == afternoon, shown(J) == evening)) ::: (A)\nis_sat(And(shown(P) == afternoon, shown(K) == afternoon)) ::: (B)\nis_sat(And(shown(P) == afternoon, shown(N) == morning)) ::: (C)\nis_sat(And(shown(P) == afternoon, shown(M) == afternoon)) ::: (D)\nis_sat(And(shown(P) == afternoon, shown(O) == morning)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201212_4-G_2_6",
    "context": "Exactly five witnesses—Franco, Garcia, Hong, Iturbe, and Jackson—are to be scheduled to testify at a hearing that is to take exactly three days of one week—Monday, Tuesday, and Wednesday. Each witness testifies on exactly one day of the hearing. The schedule must meet the following conditions: Franco does not testify on the same day that Garcia testifies. Iturbe testifies on Wednesday. Exactly two witnesses testify on Tuesday. Hong does not testify on Monday. At least one witness testifies on Monday.",
    "question": "Which one of the following is an acceptable schedule of witnesses?",
    "answer": "D",
    "options": [
      "A) Monday: Franco Tuesday: Hong and Iturbe Wednesday: Garcia and Jackson",
      "B) Monday: Franco and Hong Tuesday: Iturbe and Jackson Wednesday: Garcia",
      "C) Monday: Garcia Tuesday: Franco and Iturbe Wednesday: Hong and Jackson",
      "D) Monday: Garcia and Jackson Tuesday: Franco and Hong Wednesday: Iturbe",
      "E) Monday: Garcia and Jackson Tuesday: Hong Wednesday: Franco and Iturbe"
    ],
    "raw_logic_programs": [
      "# Declarations\nwitnesses = EnumSort([Franco, Garcia, Hong, Iturbe, Jackson])\ndays = EnumSort([Monday, Tuesday, Wednesday])\ntestifies = Function([witnesses] -> [days])\n\n# Constraints\nForAll([w:witnesses], Count([d:days], testifies(w) == d) == 1) ::: Each witness testifies on exactly one day of the hearing\ntestifies(Franco) != testifies(Garcia) ::: Franco does not testify on the same day that Garcia testifies\ntestifies(Iturbe) == Wednesday ::: Iturbe testifies on Wednesday\nCount([w:witnesses], testifies(w) == Tuesday) == 2 ::: Exactly two witnesses testify on Tuesday\ntestifies(Hong) != Monday ::: Hong does not testify on Monday\nExists([w:witnesses], testifies(w) == Monday) ::: At least one witness testifies on Monday\n\n# Options\nQuestion ::: Which one of the following is an acceptable schedule of witnesses?\nis_sat(And(testifies(Franco) == Monday, And(testifies(Hong) == Tuesday, And(testifies(Iturbe) == Wednesday, And(testifies(Garcia) == Wednesday, testifies(Jackson) == Tuesday))))) ::: (A)\nis_sat(And(testifies(Franco) == Monday, And(testifies(Hong) == Monday, And(testifies(Iturbe) == Tuesday, And(testifies(Garcia) == Wednesday, testifies(Jackson) == Tuesday))))) ::: (B)\nis_sat(And(testifies(Franco) == Tuesday, And(testifies(Hong) == Wednesday, And(testifies(Iturbe) == Wednesday, And(testifies(Garcia) == Monday, testifies(Jackson) == Tuesday))))) ::: (C)\nis_sat(And(testifies(Franco) == Tuesday, And(testifies(Hong) == Monday, And(testifies(Iturbe) == Wednesday, And(testifies(Garcia) == Monday, testifies(Jackson) == Tuesday))))) ::: (D)\nis_sat(And(testifies(Franco) == Wednesday, And(testifies(Hong) == Tuesday, And(testifies(Iturbe) == Wednesday, And(testifies(Garcia) == Monday, testifies(Jackson) == Monday))))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201212_4-G_2_7",
    "context": "Exactly five witnesses—Franco, Garcia, Hong, Iturbe, and Jackson—are to be scheduled to testify at a hearing that is to take exactly three days of one week—Monday, Tuesday, and Wednesday. Each witness testifies on exactly one day of the hearing. The schedule must meet the following conditions: Franco does not testify on the same day that Garcia testifies. Iturbe testifies on Wednesday. Exactly two witnesses testify on Tuesday. Hong does not testify on Monday. At least one witness testifies on Monday.",
    "question": "Which one of the following CANNOT be true of the schedule?",
    "answer": "E",
    "options": [
      "A) Franco is the only witness scheduled to testify on Monday.",
      "B) Franco is scheduled to testify on the same day as Iturbe.",
      "C) Garcia and Hong are both scheduled to testify on Tuesday.",
      "D) Garcia is the only witness scheduled to testify on Monday and Hong is one of two witnesses scheduled to testify on Wednesday.",
      "E) Jackson is scheduled to testify on Tuesday and two witnesses are scheduled to testify on Monday."
    ],
    "raw_logic_programs": [
      "# Declarations\nwitnesses = EnumSort([Franco, Garcia, Hong, Iturbe, Jackson])\ndays = EnumSort([Monday, Tuesday, Wednesday])\ntestifies = Function([witnesses] -> [days])\n\n# Constraints\nForAll([w:witnesses], Count([d:days], testifies(w) == d) == 1) ::: Each witness testifies on exactly one day of the hearing\ntestifies(Franco) != testifies(Garcia) ::: Franco does not testify on the same day that Garcia testifies\ntestifies(Iturbe) == Wednesday ::: Iturbe testifies on Wednesday\nCount([w:witnesses], testifies(w) == Tuesday) == 2 ::: Exactly two witnesses testify on Tuesday\ntestifies(Hong) != Monday ::: Hong does not testify on Monday\nExists([w:witnesses], testifies(w) == Monday) ::: At least one witness testifies on Monday\n\n# Options\nQuestion ::: Which one of the following CANNOT be true of the schedule?\nis_unsat(And(Count([w:witnesses], testifies(w) == Monday) == 1, testifies(Franco) == Monday)) ::: (A)\nis_unsat(testifies(Franco) == testifies(Iturbe)) ::: (B)\nis_unsat(And(testifies(Garcia) == Tuesday, testifies(Hong) == Tuesday)) ::: (C)\nis_unsat(And(testifies(Garcia) == Monday, Count([w:witnesses], testifies(w) == Wednesday) == 2, testifies(Hong) == Wednesday)) ::: (D)\nis_unsat(And(testifies(Jackson) == Tuesday, Count([w:witnesses], testifies(w) == Monday) == 2)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201212_4-G_2_8",
    "context": "Exactly five witnesses—Franco, Garcia, Hong, Iturbe, and Jackson—are to be scheduled to testify at a hearing that is to take exactly three days of one week—Monday, Tuesday, and Wednesday. Each witness testifies on exactly one day of the hearing. The schedule must meet the following conditions: Franco does not testify on the same day that Garcia testifies. Iturbe testifies on Wednesday. Exactly two witnesses testify on Tuesday. Hong does not testify on Monday. At least one witness testifies on Monday.",
    "question": "If Jackson is scheduled to testify on Wednesday, which one of the following must be true of the schedule?",
    "answer": "C",
    "options": [
      "A) Franco is scheduled to testify on Monday.",
      "B) Garcia is scheduled to testify on Monday.",
      "C) Exactly one witness is scheduled to testify on Monday.",
      "D) Exactly two witnesses are scheduled to testify on Monday.",
      "E) Garcia is scheduled to testify on the same day as Hong."
    ],
    "raw_logic_programs": [
      "# Declarations\nwitnesses = EnumSort([Franco, Garcia, Hong, Iturbe, Jackson])\ndays = EnumSort([Monday, Tuesday, Wednesday])\ntestifies = Function([witnesses] -> [days])\n\n# Constraints\nForAll([w:witnesses], Count([d:days], testifies(w) == d) == 1) ::: Each witness testifies on exactly one day of the hearing\ntestifies(Franco) != testifies(Garcia) ::: Franco does not testify on the same day that Garcia testifies\ntestifies(Iturbe) == Wednesday ::: Iturbe testifies on Wednesday\nCount([w:witnesses], testifies(w) == Tuesday) == 2 ::: Exactly two witnesses testify on Tuesday\ntestifies(Hong) != Monday ::: Hong does not testify on Monday\nExists([w:witnesses], testifies(w) == Monday) ::: At least one witness testifies on Monday\ntestifies(Jackson) == Wednesday ::: If Jackson is scheduled to testify on Wednesday\n\n# Options\nQuestion ::: Which one of the following must be true of the schedule?\nis_valid(testifies(Franco) == Monday) ::: (A)\nis_valid(testifies(Garcia) == Monday) ::: (B)\nis_valid(Count([w:witnesses], testifies(w) == Monday) == 1) ::: (C)\nis_valid(Count([w:witnesses], testifies(w) == Monday) == 2) ::: (D)\nis_valid(testifies(Garcia) == testifies(Hong)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201212_4-G_2_9",
    "context": "Exactly five witnesses—Franco, Garcia, Hong, Iturbe, and Jackson—are to be scheduled to testify at a hearing that is to take exactly three days of one week—Monday, Tuesday, and Wednesday. Each witness testifies on exactly one day of the hearing. The schedule must meet the following conditions: Franco does not testify on the same day that Garcia testifies. Iturbe testifies on Wednesday. Exactly two witnesses testify on Tuesday. Hong does not testify on Monday. At least one witness testifies on Monday.",
    "question": "If Jackson is the only witness scheduled to testify on Monday, which one of the following must be true of the schedule?",
    "answer": "B",
    "options": [
      "A) Franco is scheduled to testify on Wednesday.",
      "B) Hong is scheduled to testify on Tuesday.",
      "C) Garcia is scheduled to testify on Tuesday.",
      "D) Franco is scheduled to testify on the same day as Hong.",
      "E) Garcia is scheduled to testify on the same day as Hong."
    ],
    "raw_logic_programs": [
      "# Declarations\nwitnesses = EnumSort([Franco, Garcia, Hong, Iturbe, Jackson])\ndays = EnumSort([Monday, Tuesday, Wednesday])\ntestifies = Function([witnesses] -> [days])\n\n# Constraints\nForAll([w:witnesses], Count([d:days], testifies(w) == d) == 1) ::: Each witness testifies on exactly one day of the hearing\ntestifies(Franco) != testifies(Garcia) ::: Franco does not testify on the same day that Garcia testifies\ntestifies(Iturbe) == Wednesday ::: Iturbe testifies on Wednesday\nCount([w:witnesses], testifies(w) == Tuesday) == 2 ::: Exactly two witnesses testify on Tuesday\ntestifies(Hong) != Monday ::: Hong does not testify on Monday\nExists([w:witnesses], testifies(w) == Monday) ::: At least one witness testifies on Monday\ntestifies(Jackson) == Monday ::: If Jackson is the only witness scheduled to testify on Monday\n\n# Options\nQuestion ::: If Jackson is the only witness scheduled to testify on Monday, which one of the following must be true of the schedule?\nis_valid(testifies(Franco) == Wednesday) ::: (A)\nis_valid(testifies(Hong) == Tuesday) ::: (B)\nis_valid(testifies(Garcia) == Tuesday) ::: (C)\nis_valid(testifies(Franco) == testifies(Hong)) ::: (D)\nis_valid(testifies(Garcia) == testifies(Hong)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201212_4-G_2_10",
    "context": "Exactly five witnesses—Franco, Garcia, Hong, Iturbe, and Jackson—are to be scheduled to testify at a hearing that is to take exactly three days of one week—Monday, Tuesday, and Wednesday. Each witness testifies on exactly one day of the hearing. The schedule must meet the following conditions: Franco does not testify on the same day that Garcia testifies. Iturbe testifies on Wednesday. Exactly two witnesses testify on Tuesday. Hong does not testify on Monday. At least one witness testifies on Monday.",
    "question": "If Franco is scheduled to testify on the same day as Hong, which one of the following must be true of the schedule?",
    "answer": "D",
    "options": [
      "A) Franco is scheduled to testify on Wednesday.",
      "B) Garcia is scheduled to testify on Monday.",
      "C) Garcia is scheduled to testify on Wednesday.",
      "D) Hong is scheduled to testify on Tuesday.",
      "E) Iturbe is the only witness scheduled to testify on Wednesday."
    ],
    "raw_logic_programs": [
      "# Declarations\nwitnesses = EnumSort([Franco, Garcia, Hong, Iturbe, Jackson])\ndays = EnumSort([Monday, Tuesday, Wednesday])\ntestifies = Function([witnesses] -> [days])\n\n# Constraints\nForAll([w:witnesses], Count([d:days], testifies(w) == d) == 1) ::: Each witness testifies on exactly one day of the hearing\ntestifies(Franco) != testifies(Garcia) ::: Franco does not testify on the same day that Garcia testifies\ntestifies(Iturbe) == Wednesday ::: Iturbe testifies on Wednesday\nCount([w:witnesses], testifies(w) == Tuesday) == 2 ::: Exactly two witnesses testify on Tuesday\ntestifies(Hong) != Monday ::: Hong does not testify on Monday\nExists([w:witnesses], testifies(w) == Monday) ::: At least one witness testifies on Monday\ntestifies(Franco) == testifies(Hong) ::: If Franco is scheduled to testify on the same day as Hong\n\n# Options\nQuestion ::: Which one of the following must be true of the schedule?\nis_valid(testifies(Franco) == Wednesday) ::: (A)\nis_valid(testifies(Garcia) == Monday) ::: (B)\nis_valid(testifies(Garcia) == Wednesday) ::: (C)\nis_valid(testifies(Hong) == Tuesday) ::: (D)\nis_valid(ForAll([w:witnesses], Implies(testifies(w) == Wednesday, w == Iturbe))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201212_4-G_3_11",
    "context": "A maintenance company that takes service requests from three clients—Image, Solide, and Truvest—plans to set targets for its average service response times. Service targets will be set at 3 days, 2 days, or 1 day. Two service targets are set for each client—one for requests received through the maintenance company's website and one for requests received by voicemail. The six targets are set according to the following conditions: None of the clients can have a website target that is longer than its voicemail target. Image's voicemail target must be shorter than the other clients' voicemail targets. Solide's website target must be shorter than Truvest's website target.",
    "question": "If none of the clients has a voicemail target of 3 days, then each of the following must be true EXCEPT:",
    "answer": "B",
    "options": [
      "A) Image's website target is 1 day.",
      "B) Solide's website target is 2 days.",
      "C) Solide's voicemail target is 2 days.",
      "D) Truvest's website target is 2 days.",
      "E) Truvest's voicemail target is 2 days."
    ],
    "raw_logic_programs": [
      "# Declarations\nclients = EnumSort([Image, Solide, Truvest])\nchannels = EnumSort([website, voicemail])\ntargets = EnumSort([1, 2, 3])\ntarget = Function([clients, channels] -> [targets])\n\n# Constraints\nForAll([c:clients], target(c, website) <= target(c, voicemail)) ::: None of the clients can have a website target that is longer than its voicemail target\ntarget(Image, voicemail) < target(Solide, voicemail) ::: Image's voicemail target must be shorter than the other clients' voicemail targets\ntarget(Solide, website) < target(Truvest, website) ::: Solide's website target must be shorter than Truvest's website target\nForAll([c:clients], target(c, voicemail) != 3) ::: If none of the clients has a voicemail target of 3 days\n\n# Options\nQuestion ::: If none of the clients has a voicemail target of 3 days, then each of the following must be true EXCEPT:\nis_unsat(target(Image, website) != 1) ::: (A)\nis_unsat(target(Solide, website) != 2) ::: (B)\nis_unsat(target(Solide, voicemail) != 2) ::: (C)\nis_unsat(target(Truvest, website) != 2) ::: (D)\nis_unsat(target(Truvest, voicemail) != 2) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201212_4-G_3_12",
    "context": "A maintenance company that takes service requests from three clients—Image, Solide, and Truvest—plans to set targets for its average service response times. Service targets will be set at 3 days, 2 days, or 1 day. Two service targets are set for each client—one for requests received through the maintenance company's website and one for requests received by voicemail. The six targets are set according to the following conditions: None of the clients can have a website target that is longer than its voicemail target. Image's voicemail target must be shorter than the other clients' voicemail targets. Solide's website target must be shorter than Truvest's website target.",
    "question": "If Truvest's website target is shorter than its voicemail target, which one of the following must be true?",
    "answer": "E",
    "options": [
      "A) Image's voicemail target is 2 days.",
      "B) Image's website target is 2 days.",
      "C) Image's website target is 1 day.",
      "D) Solide's website target is 2 days.",
      "E) Solide's website target is 1 day."
    ],
    "raw_logic_programs": [
      "# Declarations\nclients = EnumSort([Image, Solide, Truvest])\nchannels = EnumSort([website, voicemail])\ntargets = EnumSort([1, 2, 3])\ntarget = Function([clients, channels] -> [targets])\n\n# Constraints\nForAll([c:clients], target(c, website) <= target(c, voicemail)) ::: None of the clients can have a website target that is longer than its voicemail target\ntarget(Image, voicemail) < target(Solide, voicemail) ::: Image's voicemail target must be shorter than the other clients' voicemail targets\ntarget(Image, voicemail) < target(Truvest, voicemail) ::: Image's voicemail target must be shorter than the other clients' voicemail targets\ntarget(Solide, website) < target(Truvest, website) ::: Solide's website target must be shorter than Truvest's website target\ntarget(Truvest, website) < target(Truvest, voicemail) ::: Truvest's website target is shorter than its voicemail target\n\n# Options\nQuestion ::: If Truvest's website target is shorter than its voicemail target, which one of the following must be true?\nis_valid(target(Image, voicemail) == 2) ::: (A)\nis_valid(target(Image, website) == 2) ::: (B)\nis_valid(target(Image, website) == 1) ::: (C)\nis_valid(target(Solide, website) == 2) ::: (D)\nis_valid(target(Solide, website) == 1) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201212_4-G_3_13",
    "context": "A maintenance company that takes service requests from three clients—Image, Solide, and Truvest—plans to set targets for its average service response times. Service targets will be set at 3 days, 2 days, or 1 day. Two service targets are set for each client—one for requests received through the maintenance company's website and one for requests received by voicemail. The six targets are set according to the following conditions: None of the clients can have a website target that is longer than its voicemail target. Image's voicemail target must be shorter than the other clients' voicemail targets. Solide's website target must be shorter than Truvest's website target.",
    "question": "If Image's website target is 2 days, which one of the following targets must also be 2 days?",
    "answer": "A",
    "options": [
      "A) Image's voicemail target",
      "B) Solide's website target",
      "C) Solide's voicemail target",
      "D) Truvest's website target",
      "E) Truvest's voicemail target"
    ],
    "raw_logic_programs": [
      "# Declarations\nclients = EnumSort([Image, Solide, Truvest])\nchannels = EnumSort([website, voicemail])\ntargets = EnumSort([1, 2, 3])\ntarget = Function([clients, channels] -> [targets])\n\n# Constraints\nForAll([c:clients], target(c, website) <= target(c, voicemail)) ::: None of the clients can have a website target that is longer than its voicemail target\ntarget(Image, voicemail) < target(Solide, voicemail) ::: Image's voicemail target must be shorter than the other clients' voicemail targets\ntarget(Image, voicemail) < target(Truvest, voicemail) ::: Image's voicemail target must be shorter than the other clients' voicemail targets\ntarget(Solide, website) < target(Truvest, website) ::: Solide's website target must be shorter than Truvest's website target\ntarget(Image, website) == 2 ::: If Image's website target is 2 days\n\n# Options\nQuestion ::: If Image's website target is 2 days, which one of the following targets must also be 2 days?\nis_valid(target(Image, voicemail) == 2) ::: (A)\nis_valid(target(Solide, website) == 2) ::: (B)\nis_valid(target(Solide, voicemail) == 2) ::: (C)\nis_valid(target(Truvest, website) == 2) ::: (D)\nis_valid(target(Truvest, voicemail) == 2) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201212_4-G_3_14",
    "context": "A maintenance company that takes service requests from three clients—Image, Solide, and Truvest—plans to set targets for its average service response times. Service targets will be set at 3 days, 2 days, or 1 day. Two service targets are set for each client—one for requests received through the maintenance company's website and one for requests received by voicemail. The six targets are set according to the following conditions: None of the clients can have a website target that is longer than its voicemail target. Image's voicemail target must be shorter than the other clients' voicemail targets. Solide's website target must be shorter than Truvest's website target.",
    "question": "If Solide's voicemail target is shorter than Truvest's website target, which one of the following targets could be 2 days?",
    "answer": "C",
    "options": [
      "A) Image's website target",
      "B) Image's voicemail target",
      "C) Solide's website target",
      "D) Truvest's voicemail target",
      "E) Truvest's website target"
    ],
    "raw_logic_programs": [
      "# Declarations\nclients = EnumSort([Image, Solide, Truvest])\nchannels = EnumSort([website, voicemail])\ntargets = EnumSort([1, 2, 3])\ntarget = Function([clients, channels] -> [targets])\n\n# Constraints\nForAll([c:clients], target(c, website) <= target(c, voicemail)) ::: None of the clients can have a website target that is longer than its voicemail target\ntarget(Image, voicemail) < target(Solide, voicemail) ::: Image's voicemail target must be shorter than the other clients' voicemail targets\ntarget(Image, voicemail) < target(Truvest, voicemail) ::: Image's voicemail target must be shorter than the other clients' voicemail targets\ntarget(Solide, website) < target(Truvest, website) ::: Solide's website target must be shorter than Truvest's website target\ntarget(Solide, voicemail) < target(Truvest, website) ::: If Solide's voicemail target is shorter than Truvest's website target\n\n# Options\nQuestion ::: Which one of the following targets could be 2 days?\nis_valid(target(Image, website) == 2) ::: (A)\nis_valid(target(Image, voicemail) == 2) ::: (B)\nis_valid(target(Solide, website) == 2) ::: (C)\nis_valid(target(Truvest, voicemail) == 2) ::: (D)\nis_valid(target(Truvest, website) == 2) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201212_4-G_3_15",
    "context": "A maintenance company that takes service requests from three clients—Image, Solide, and Truvest—plans to set targets for its average service response times. Service targets will be set at 3 days, 2 days, or 1 day. Two service targets are set for each client—one for requests received through the maintenance company's website and one for requests received by voicemail. The six targets are set according to the following conditions: None of the clients can have a website target that is longer than its voicemail target. Image's voicemail target must be shorter than the other clients' voicemail targets. Solide's website target must be shorter than Truvest's website target.",
    "question": "Which one of the following targets CANNOT be set for more than one of the clients?",
    "answer": "E",
    "options": [
      "A) a 1-day website target",
      "B) a 2-day voicemail target",
      "C) a 2-day website target",
      "D) a 3-day voicemail target",
      "E) a 3-day website target"
    ],
    "raw_logic_programs": [
      "# Declarations\nclients = EnumSort([Image, Solide, Truvest])\nmethods = EnumSort([website, voicemail])\ntargets = EnumSort([1, 2, 3])\ntarget = Function([clients, methods] -> [targets])\n\n# Constraints\nForAll([c:clients], target(c, website) <= target(c, voicemail)) ::: None of the clients can have a website target that is longer than its voicemail target\nAnd(target(Image, voicemail) < target(Solide, voicemail), target(Image, voicemail) < target(Truvest, voicemail)) ::: Image's voicemail target must be shorter than the other clients' voicemail targets\ntarget(Solide, website) < target(Truvest, website) ::: Solide's website target must be shorter than Truvest's website target\n\n# Options\nQuestion ::: Which one of the following targets CANNOT be set for more than one of the clients?\nis_unsat(And(Exists([c1:clients, c2:clients], And(c1 != c2, target(c1, website) == 1, target(c2, website) == 1)), Exists([c1:clients, c2:clients], And(c1 != c2, target(c1, website) == 1, target(c2, website) == 1)))) ::: (A)\nis_unsat(And(Exists([c1:clients, c2:clients], And(c1 != c2, target(c1, voicemail) == 2, target(c2, voicemail) == 2)), Exists([c1:clients, c2:clients], And(c1 != c2, target(c1, voicemail) == 2, target(c2, voicemail) == 2)))) ::: (B)\nis_unsat(And(Exists([c1:clients, c2:clients], And(c1 != c2, target(c1, website) == 2, target(c2, website) == 2)), Exists([c1:clients, c2:clients], And(c1 != c2, target(c1, website) == 2, target(c2, website) == 2)))) ::: (C)\nis_unsat(And(Exists([c1:clients, c2:clients], And(c1 != c2, target(c1, voicemail) == 3, target(c2, voicemail) == 3)), Exists([c1:clients, c2:clients], And(c1 != c2, target(c1, voicemail) == 3, target(c2, voicemail) == 3)))) ::: (D)\nis_unsat(And(Exists([c1:clients, c2:clients], And(c1 != c2, target(c1, website) == 3, target(c2, website) == 3)), Exists([c1:clients, c2:clients], And(c1 != c2, target(c1, website) == 3, target(c2, website) == 3)))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201212_4-G_3_16",
    "context": "A maintenance company that takes service requests from three clients—Image, Solide, and Truvest—plans to set targets for its average service response times. Service targets will be set at 3 days, 2 days, or 1 day. Two service targets are set for each client—one for requests received through the maintenance company's website and one for requests received by voicemail. The six targets are set according to the following conditions: None of the clients can have a website target that is longer than its voicemail target. Image's voicemail target must be shorter than the other clients' voicemail targets. Solide's website target must be shorter than Truvest's website target.",
    "question": "If none of the clients has a website target of 2 days, which one of the following could be true?",
    "answer": "C",
    "options": [
      "A) Image's website target is shorter than Solide's.",
      "B) Solide's website target is shorter than Image's.",
      "C) Solide's voicemail target is shorter than Truvest's.",
      "D) Truvest's website target is shorter than Image's.",
      "E) Truvest's voicemail target is shorter than Solide's."
    ],
    "raw_logic_programs": [
      "# Declarations\nclients = EnumSort([Image, Solide, Truvest])\nchannels = EnumSort([website, voicemail])\ntargets = EnumSort([1, 2, 3])\ntarget = Function([clients, channels] -> [targets])\n\n# Constraints\nForAll([c:clients], target(c, website) <= target(c, voicemail)) ::: None of the clients can have a website target that is longer than its voicemail target\ntarget(Image, voicemail) < target(Solide, voicemail) ::: Image's voicemail target must be shorter than the other clients' voicemail targets\ntarget(Solide, website) < target(Truvest, website) ::: Solide's website target must be shorter than Truvest's website target\nForAll([c:clients], target(c, website) != 2) ::: none of the clients has a website target of 2 days\n\n# Options\nQuestion ::: If none of the clients has a website target of 2 days, which one of the following could be true?\nis_sat(target(Image, website) < target(Solide, website)) ::: (A)\nis_sat(target(Solide, website) < target(Image, website)) ::: (B)\nis_sat(target(Solide, voicemail) < target(Truvest, voicemail)) ::: (C)\nis_sat(target(Truvest, website) < target(Image, website)) ::: (D)\nis_sat(target(Truvest, voicemail) < target(Solide, voicemail)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201212_4-G_4_17",
    "context": "An editor will edit seven articles, one at a time. Three of the articles—G, H, and J—cover finance; three other articles—Q, R, and S—cover nutrition; and the remaining article, Y, covers wildlife. The order in which the articles are edited is subject to the following conditions: Consecutive articles cannot cover the same topic as each other. S can be earlier than Q only if Q is third. S must be earlier than Y. J must be earlier than G, and G must be earlier than R.",
    "question": "Which one of the following is an acceptable order for editing the articles, from first through seventh?",
    "answer": "C",
    "options": [
      "A) H, S, J, Q, Y, G, R",
      "B) J, Q, G, H, S, Y, R",
      "C) Q, J, S, H, Y, G, R",
      "D) Q, J, Y, S, G, R, H",
      "E) S, G, Q, J, Y, R, H"
    ],
    "raw_logic_programs": [
      "# Declarations\narticles = EnumSort([G, H, J, Q, R, S, Y])\ntopics = EnumSort([finance, nutrition, wildlife])\ncovers = Function([articles] -> [topics])\nedited = Function([articles] -> [int])\nForAll([a:articles], And(1 <= edited(a), edited(a) <= 7))\n\n# Constraints\nForAll([a1:articles, a2:articles], Implies(And(edited(a1) + 1 == edited(a2), a1 != a2), covers(a1) != covers(a2))) ::: Consecutive articles cannot cover the same topic as each other\nImplies(edited(S) < edited(Q), edited(Q) == 3) ::: S can be earlier than Q only if Q is third\nedited(S) < edited(Y) ::: S must be earlier than Y\nAnd(edited(J) < edited(G), edited(G) < edited(R)) ::: J must be earlier than G, and G must be earlier than R\ncovers(G) == finance ::: G covers finance\ncovers(H) == finance ::: H covers finance\ncovers(J) == finance ::: J covers finance\ncovers(Q) == nutrition ::: Q covers nutrition\ncovers(R) == nutrition ::: R covers nutrition\ncovers(S) == nutrition ::: S covers nutrition\ncovers(Y) == wildlife ::: Y covers wildlife\n\n# Options\nQuestion ::: Which one of the following is an acceptable order for editing the articles, from first through seventh?\nis_valid(And(edited(H) == 1, edited(S) == 2, edited(J) == 3, edited(Q) == 4, edited(Y) == 5, edited(G) == 6, edited(R) == 7)) ::: (A)\nis_valid(And(edited(J) == 1, edited(Q) == 2, edited(G) == 3, edited(H) == 4, edited(S) == 5, edited(Y) == 6, edited(R) == 7)) ::: (B)\nis_valid(And(edited(Q) == 1, edited(J) == 2, edited(S) == 3, edited(H) == 4, edited(Y) == 5, edited(G) == 6, edited(R) == 7)) ::: (C)\nis_valid(And(edited(Q) == 1, edited(J) == 2, edited(Y) == 3, edited(S) == 4, edited(G) == 5, edited(R) == 6, edited(H) == 7)) ::: (D)\nis_valid(And(edited(S) == 1, edited(G) == 2, edited(Q) == 3, edited(J) == 4, edited(Y) == 5, edited(R) == 6, edited(H) == 7)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201212_4-G_4_18",
    "context": "An editor will edit seven articles, one at a time. Three of the articles—G, H, and J—cover finance; three other articles—Q, R, and S—cover nutrition; and the remaining article, Y, covers wildlife. The order in which the articles are edited is subject to the following conditions: Consecutive articles cannot cover the same topic as each other. S can be earlier than Q only if Q is third. S must be earlier than Y. J must be earlier than G, and G must be earlier than R.",
    "question": "If Y is fourth, which one of the following must be true?",
    "answer": "A",
    "options": [
      "A) J is second.",
      "B) J is third",
      "C) Q is first.",
      "D) Q is third",
      "E) R is seventh."
    ],
    "raw_logic_programs": [
      "# Declarations\narticles = EnumSort([G, H, J, Q, R, S, Y])\ntopics = EnumSort([finance, nutrition, wildlife])\ncovers = Function([articles] -> [topics])\nedited = Function([articles] -> [int])\nForAll([a:articles], And(1 <= edited(a), edited(a) <= 7))\n\n# Constraints\nForAll([a1:articles, a2:articles], Implies(And(edited(a1) + 1 == edited(a2), a1 != a2), covers(a1) != covers(a2))) ::: Consecutive articles cannot cover the same topic as each other\nImplies(edited(S) < edited(Q), edited(Q) == 3) ::: S can be earlier than Q only if Q is third\nedited(S) < edited(Y) ::: S must be earlier than Y\nAnd(edited(J) < edited(G), edited(G) < edited(R)) ::: J must be earlier than G, and G must be earlier than R\nedited(Y) == 4 ::: If Y is fourth\n\n# Options\nQuestion ::: If Y is fourth, which one of the following must be true?\nis_valid(edited(J) == 2) ::: (A)\nis_valid(edited(J) == 3) ::: (B)\nis_valid(edited(Q) == 1) ::: (C)\nis_valid(edited(Q) == 3) ::: (D)\nis_valid(edited(R) == 7) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201212_4-G_4_19",
    "context": "An editor will edit seven articles, one at a time. Three of the articles—G, H, and J—cover finance; three other articles—Q, R, and S—cover nutrition; and the remaining article, Y, covers wildlife. The order in which the articles are edited is subject to the following conditions: Consecutive articles cannot cover the same topic as each other. S can be earlier than Q only if Q is third. S must be earlier than Y. J must be earlier than G, and G must be earlier than R.",
    "question": "If G is fourth, which one of the following could be true?",
    "answer": "E",
    "options": [
      "A) H is fifth.",
      "B) J is first.",
      "C) Q is second.",
      "D) S is fifth",
      "E) Y is sixth."
    ],
    "raw_logic_programs": [
      "# Declarations\narticles = EnumSort([G, H, J, Q, R, S, Y])\ntopics = EnumSort([finance, nutrition, wildlife])\nedited = Function([articles] -> [int])\ncovers = Function([articles] -> [topics])\n\n# Constraints\nForAll([a:articles], And(1 <= edited(a), edited(a) <= 7))\nForAll([a1:articles, a2:articles], Implies(And(edited(a1) == edited(a2) - 1, a1 != a2), covers(a1) != covers(a2))) ::: Consecutive articles cannot cover the same topic as each other\nImplies(edited(S) < edited(Q), edited(Q) == 3) ::: S can be earlier than Q only if Q is third\nedited(S) < edited(Y) ::: S must be earlier than Y\nAnd(edited(J) < edited(G), edited(G) < edited(R)) ::: J must be earlier than G, and G must be earlier than R\nedited(G) == 4 ::: If G is fourth\n\n# Options\nQuestion ::: If G is fourth, which one of the following could be true?\nis_sat(edited(H) == 5) ::: (A)\nis_sat(edited(J) == 1) ::: (B)\nis_sat(edited(Q) == 2) ::: (C)\nis_sat(edited(S) == 5) ::: (D)\nis_sat(edited(Y) == 6) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201212_4-G_4_20",
    "context": "An editor will edit seven articles, one at a time. Three of the articles—G, H, and J—cover finance; three other articles—Q, R, and S—cover nutrition; and the remaining article, Y, covers wildlife. The order in which the articles are edited is subject to the following conditions: Consecutive articles cannot cover the same topic as each other. S can be earlier than Q only if Q is third. S must be earlier than Y. J must be earlier than G, and G must be earlier than R.",
    "question": "Which one of the following could be true?",
    "answer": "B",
    "options": [
      "A) G is second",
      "B) H is second.",
      "C) S is second",
      "D) R is third.",
      "E) Y is third"
    ],
    "raw_logic_programs": [
      "# Declarations\narticles = EnumSort([G, H, J, Q, R, S, Y])\ntopics = EnumSort([finance, nutrition, wildlife])\ncovers = Function([articles] -> [topics])\nedited = Function([articles] -> [int])\nForAll([a:articles], And(1 <= edited(a), edited(a) <= 7))\n\n# Constraints\nForAll([a1:articles, a2:articles], Implies(And(edited(a1) == edited(a2) - 1, a1 != a2), covers(a1) != covers(a2))) ::: Consecutive articles cannot cover the same topic as each other\nImplies(edited(S) < edited(Q), edited(Q) == 3) ::: S can be earlier than Q only if Q is third\nedited(S) < edited(Y) ::: S must be earlier than Y\nAnd(edited(J) < edited(G), edited(G) < edited(R)) ::: J must be earlier than G, and G must be earlier than R\nAnd(covers(G) == finance, covers(H) == finance, covers(J) == finance, covers(Q) == nutrition, covers(R) == nutrition, covers(S) == nutrition, covers(Y) == wildlife) ::: Three of the articles—G, H, and J—cover finance; three other articles—Q, R, and S—cover nutrition; and the remaining article, Y, covers wildlife\n\n# Options\nQuestion ::: Which one of the following could be true?\nis_sat(edited(G) == 2) ::: (A)\nis_sat(edited(H) == 2) ::: (B)\nis_sat(edited(S) == 2) ::: (C)\nis_sat(edited(R) == 3) ::: (D)\nis_sat(edited(Y) == 3) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201212_4-G_4_21",
    "context": "An editor will edit seven articles, one at a time. Three of the articles—G, H, and J—cover finance; three other articles—Q, R, and S—cover nutrition; and the remaining article, Y, covers wildlife. The order in which the articles are edited is subject to the following conditions: Consecutive articles cannot cover the same topic as each other. S can be earlier than Q only if Q is third. S must be earlier than Y. J must be earlier than G, and G must be earlier than R.",
    "question": "If J is third, which one of the following could be true?",
    "answer": "E",
    "options": [
      "A) G is fourth",
      "B) His sixth",
      "C) Q is first",
      "D) S is second",
      "E) Y is fifth"
    ],
    "raw_logic_programs": [
      "# Declarations\narticles = EnumSort([G, H, J, Q, R, S, Y])\ntopics = EnumSort([finance, nutrition, wildlife])\ncovers = Function([articles] -> [topics])\nedited = Function([articles] -> [int])\nForAll([a:articles], And(1 <= edited(a), edited(a) <= 7))\n\n# Constraints\nForAll([a1:articles, a2:articles], Implies(And(edited(a1) + 1 == edited(a2), a1 != a2), covers(a1) != covers(a2))) ::: Consecutive articles cannot cover the same topic as each other\nImplies(edited(S) < edited(Q), edited(Q) == 3) ::: S can be earlier than Q only if Q is third\nedited(S) < edited(Y) ::: S must be earlier than Y\nAnd(edited(J) < edited(G), edited(G) < edited(R)) ::: J must be earlier than G, and G must be earlier than R\nedited(J) == 3 ::: If J is third\n\n# Options\nQuestion ::: If J is third, which one of the following could be true?\nis_sat(edited(G) == 4) ::: (A)\nis_sat(edited(H) == 6) ::: (B)\nis_sat(edited(Q) == 1) ::: (C)\nis_sat(edited(S) == 2) ::: (D)\nis_sat(edited(Y) == 5) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201212_4-G_4_22",
    "context": "An editor will edit seven articles, one at a time. Three of the articles—G, H, and J—cover finance; three other articles—Q, R, and S—cover nutrition; and the remaining article, Y, covers wildlife. The order in which the articles are edited is subject to the following conditions: Consecutive articles cannot cover the same topic as each other. S can be earlier than Q only if Q is third. S must be earlier than Y. J must be earlier than G, and G must be earlier than R.",
    "question": "In the order in which the articles are edited, S could be in any of the following positions EXCEPT:",
    "answer": "D",
    "options": [
      "A) first",
      "B) third",
      "C) fourth",
      "D) fifth",
      "E) sixth"
    ],
    "raw_logic_programs": [
      "# Declarations\narticles = EnumSort([G, H, J, Q, R, S, Y])\ntopics = EnumSort([finance, nutrition, wildlife])\ncovers = Function([articles] -> [topics])\nedited = Function([articles] -> [int])\nForAll([a:articles], And(1 <= edited(a), edited(a) <= 7))\n\n# Constraints\nForAll([a1:articles, a2:articles], Implies(And(edited(a1) == edited(a2) - 1, a1 != a2), covers(a1) != covers(a2))) ::: Consecutive articles cannot cover the same topic as each other\nImplies(edited(S) < edited(Q), edited(Q) == 3) ::: S can be earlier than Q only if Q is third\nedited(S) < edited(Y) ::: S must be earlier than Y\nAnd(edited(J) < edited(G), edited(G) < edited(R)) ::: J must be earlier than G, and G must be earlier than R\ncovers(G) == covers(H) == covers(J) == finance ::: Three of the articles—G, H, and J—cover finance\ncovers(Q) == covers(R) == covers(S) == nutrition ::: Three other articles—Q, R, and S—cover nutrition\ncovers(Y) == wildlife ::: the remaining article, Y, covers wildlife\n\n# Options\nQuestion ::: In the order in which the articles are edited, S could be in any of the following positions EXCEPT:\nis_exception(is_sat(edited(S) == 1)) ::: (A)\nis_exception(is_sat(edited(S) == 3)) ::: (B)\nis_exception(is_sat(edited(S) == 4)) ::: (C)\nis_exception(is_sat(edited(S) == 5)) ::: (D)\nis_exception(is_sat(edited(S) == 6)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201212_4-G_4_23",
    "context": "An editor will edit seven articles, one at a time. Three of the articles—G, H, and J—cover finance; three other articles—Q, R, and S—cover nutrition; and the remaining article, Y, covers wildlife. The order in which the articles are edited is subject to the following conditions: Consecutive articles cannot cover the same topic as each other. S can be earlier than Q only if Q is third. S must be earlier than Y. J must be earlier than G, and G must be earlier than R.",
    "question": "The order in which the articles are edited is fully determined if which one of the following is true?",
    "answer": "C",
    "options": [
      "A) H is fourth.",
      "B) H is sixth.",
      "C) R is fourth.",
      "D) R is seventh.",
      "E) Y is fifth."
    ],
    "raw_logic_programs": [
      "# Declarations\narticles = EnumSort([G, H, J, Q, R, S, Y])\nfinance = EnumSort([G, H, J])\nnutrition = EnumSort([Q, R, S])\nedited = Function([articles] -> [int])\nForAll([a:articles], And(1 <= edited(a), edited(a) <= 7))\n\n# Constraints\nForAll([a1:articles, a2:articles], Implies(And(a1 != a2, Abs(edited(a1) - edited(a2)) == 1), Not(And(a1 in finance, a2 in finance)))) ::: Consecutive articles cannot cover the same topic as each other\nImplies(edited(S) < edited(Q), edited(Q) == 3) ::: S can be earlier than Q only if Q is third\nedited(S) < edited(Y) ::: S must be earlier than Y\nAnd(edited(J) < edited(G), edited(G) < edited(R)) ::: J must be earlier than G, and G must be earlier than R\n\n# Options\nQuestion ::: The order in which the articles are edited is fully determined if which one of the following is true?\nis_fully_determined(edited(H) == 4) ::: (A)\nis_fully_determined(edited(H) == 6) ::: (B)\nis_fully_determined(edited(R) == 4) ::: (C)\nis_fully_determined(edited(R) == 7) ::: (D)\nis_fully_determined(edited(Y) == 5) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201310_3-G_1_1",
    "context": "A concert promoter is filling the six slots at a benefit concert. The slots, from earliest to latest, are numbered slot one through slot six. The slots will be filled by six bands—Uneasy, Vegemite, Wellspring, Xpert, Yardsign, and Zircon. Each band will perform in just one slot. The order must meet the following constraints: Vegemite performs in an earlier slot than Zircon. Wellspring and Zircon each perform in an earlier slot than Xpert. Uneasy performs in one of the last three slots. Yardsign performs in one of the first three slots.",
    "question": "Which one of the following CANNOT be the band that performs in slot five?",
    "answer": "B",
    "options": [
      "A) Uneasy",
      "B) Veqemite",
      "C) Wellspring",
      "D) Xpert",
      "E) Zircon"
    ],
    "raw_logic_programs": [
      "# Declarations\nbands = EnumSort([Uneasy, Vegemite, Wellspring, Xpert, Yardsign, Zircon])\nslots = EnumSort([1, 2, 3, 4, 5, 6])\nperforms = Function([bands] -> [slots])\n\n# Constraints\nForAll([b:bands], Exists([s:slots], performs(b) == s)) ::: Each band will perform in just one slot\nperforms(Vegemite) < performs(Zircon) ::: Vegemite performs in an earlier slot than Zircon\nAnd(performs(Wellspring) < performs(Xpert), performs(Zircon) < performs(Xpert)) ::: Wellspring and Zircon each perform in an earlier slot than Xpert\nAnd(performs(Uneasy) >= 4, performs(Uneasy) <= 6) ::: Uneasy performs in one of the last three slots\nAnd(performs(Yardsign) >= 1, performs(Yardsign) <= 3) ::: Yardsign performs in one of the first three slots\n\n# Options\nQuestion ::: Which one of the following CANNOT be the band that performs in slot five?\nis_unsat(performs(Uneasy) == 5) ::: (A)\nis_unsat(performs(Vegemite) == 5) ::: (B)\nis_unsat(performs(Wellspring) == 5) ::: (C)\nis_unsat(performs(Xpert) == 5) ::: (D)\nis_unsat(performs(Zircon) == 5) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201310_3-G_1_2",
    "context": "A concert promoter is filling the six slots at a benefit concert. The slots, from earliest to latest, are numbered slot one through slot six. The slots will be filled by six bands—Uneasy, Vegemite, Wellspring, Xpert, Yardsign, and Zircon. Each band will perform in just one slot. The order must meet the following constraints: Vegemite performs in an earlier slot than Zircon. Wellspring and Zircon each perform in an earlier slot than Xpert. Uneasy performs in one of the last three slots. Yardsign performs in one of the first three slots.",
    "question": "If Zircon performs in an earlier slot than Yardsign, which one of the following is the earliest slot in which Wellspring could perform?",
    "answer": "C",
    "options": [
      "A) two",
      "B) three",
      "C) four",
      "D) five",
      "E) six"
    ],
    "raw_logic_programs": [
      "# Declarations\nbands = EnumSort([Uneasy, Vegemite, Wellspring, Xpert, Yardsign, Zircon])\nslots = EnumSort([1, 2, 3, 4, 5, 6])\nperforms = Function([bands] -> [slots])\n\n# Constraints\nForAll([b:bands], And(1 <= performs(b), performs(b) <= 6)) ::: Each band will perform in just one slot\nperforms(Vegemite) < performs(Zircon) ::: Vegemite performs in an earlier slot than Zircon\nAnd(performs(Wellspring) < performs(Xpert), performs(Zircon) < performs(Xpert)) ::: Wellspring and Zircon each perform in an earlier slot than Xpert\nAnd(3 <= performs(Uneasy), performs(Uneasy) <= 6) ::: Uneasy performs in one of the last three slots\nAnd(1 <= performs(Yardsign), performs(Yardsign) <= 3) ::: Yardsign performs in one of the first three slots\nperforms(Zircon) < performs(Yardsign) ::: If Zircon performs in an earlier slot than Yardsign\n\n# Options\nQuestion ::: Which one of the following is the earliest slot in which Wellspring could perform?\nis_valid(performs(Wellspring) == 2) ::: (A)\nis_valid(performs(Wellspring) == 3) ::: (B)\nis_valid(performs(Wellspring) == 4) ::: (C)\nis_valid(performs(Wellspring) == 5) ::: (D)\nis_valid(performs(Wellspring) == 6) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201310_3-G_1_3",
    "context": "A concert promoter is filling the six slots at a benefit concert. The slots, from earliest to latest, are numbered slot one through slot six. The slots will be filled by six bands—Uneasy, Vegemite, Wellspring, Xpert, Yardsign, and Zircon. Each band will perform in just one slot. The order must meet the following constraints: Vegemite performs in an earlier slot than Zircon. Wellspring and Zircon each perform in an earlier slot than Xpert. Uneasy performs in one of the last three slots. Yardsign performs in one of the first three slots.",
    "question": "If Veqemite performs in slot three, which one of the following must be true?",
    "answer": "B",
    "options": [
      "A) Uneasy performs in an earlier slot than Xpert.",
      "B) Wellspring performs in an earlier slot than zircon",
      "C) Xpert performs in an earlier slot than Uneasy",
      "D) Yardsign performs in an earlier slot than, wellspring",
      "E) Zircon performs in an earlier slot than Uneasy."
    ],
    "raw_logic_programs": [
      "# Declarations\nbands = EnumSort([Uneasy, Vegemite, Wellspring, Xpert, Yardsign, Zircon])\nslots = EnumSort([1, 2, 3, 4, 5, 6])\nperforms = Function([bands] -> [slots])\n\n# Constraints\nForAll([b:bands], Exists([s:slots], performs(b) == s)) ::: Each band will perform in just one slot\nperforms(Vegemite) < performs(Zircon) ::: Vegemite performs in an earlier slot than Zircon\nAnd(performs(Wellspring) < performs(Xpert), performs(Zircon) < performs(Xpert)) ::: Wellspring and Zircon each perform in an earlier slot than Xpert\nAnd(3 <= performs(Uneasy), performs(Uneasy) <= 6) ::: Uneasy performs in one of the last three slots\nAnd(1 <= performs(Yardsign), performs(Yardsign) <= 3) ::: Yardsign performs in one of the first three slots\nperforms(Vegemite) == 3 ::: If Veqemite performs in slot three\n\n# Options\nQuestion ::: If Veqemite performs in slot three, which one of the following must be true?\nis_valid(performs(Uneasy) < performs(Xpert)) ::: (A)\nis_valid(performs(Wellspring) < performs(Zircon)) ::: (B)\nis_valid(performs(Xpert) < performs(Uneasy)) ::: (C)\nis_valid(performs(Yardsign) < performs(Wellspring)) ::: (D)\nis_valid(performs(Zircon) < performs(Uneasy)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201310_3-G_1_4",
    "context": "A concert promoter is filling the six slots at a benefit concert. The slots, from earliest to latest, are numbered slot one through slot six. The slots will be filled by six bands—Uneasy, Vegemite, Wellspring, Xpert, Yardsign, and Zircon. Each band will perform in just one slot. The order must meet the following constraints: Vegemite performs in an earlier slot than Zircon. Wellspring and Zircon each perform in an earlier slot than Xpert. Uneasy performs in one of the last three slots. Yardsign performs in one of the first three slots.",
    "question": "If Zircon performs immediately before Wellspring, which one of the following must be true?",
    "answer": "E",
    "options": [
      "A) Uneasy performs in slot five.",
      "B) Vegemite performs in slot one.",
      "C) Xpert performs in slot five.",
      "D) Yardsign performs in slot two.",
      "E) Zircon performs in slot three."
    ],
    "raw_logic_programs": [
      "# Declarations\nbands = EnumSort([Uneasy, Vegemite, Wellspring, Xpert, Yardsign, Zircon])\nslots = EnumSort([1, 2, 3, 4, 5, 6])\nperforms = Function([bands] -> [slots])\n\n# Constraints\nForAll([b:bands], Count([s:slots], performs(b) == s) == 1) ::: Each band will perform in just one slot\nperforms(Vegemite) < performs(Zircon) ::: Vegemite performs in an earlier slot than Zircon\nAnd(performs(Wellspring) < performs(Xpert), performs(Zircon) < performs(Xpert)) ::: Wellspring and Zircon each perform in an earlier slot than Xpert\nAnd(performs(Uneasy) >= 4, performs(Uneasy) <= 6) ::: Uneasy performs in one of the last three slots\nAnd(performs(Yardsign) >= 1, performs(Yardsign) <= 3) ::: Yardsign performs in one of the first three slots\nperforms(Zircon) + 1 == performs(Wellspring) ::: Zircon performs immediately before Wellspring\n\n# Options\nQuestion ::: If Zircon performs immediately before Wellspring, which one of the following must be true?\nis_valid(performs(Uneasy) == 5) ::: (A)\nis_valid(performs(Vegemite) == 1) ::: (B)\nis_valid(performs(Xpert) == 5) ::: (C)\nis_valid(performs(Yardsign) == 2) ::: (D)\nis_valid(performs(Zircon) == 3) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201310_3-G_1_5",
    "context": "A concert promoter is filling the six slots at a benefit concert. The slots, from earliest to latest, are numbered slot one through slot six. The slots will be filled by six bands—Uneasy, Vegemite, Wellspring, Xpert, Yardsign, and Zircon. Each band will perform in just one slot. The order must meet the following constraints: Vegemite performs in an earlier slot than Zircon. Wellspring and Zircon each perform in an earlier slot than Xpert. Uneasy performs in one of the last three slots. Yardsign performs in one of the first three slots.",
    "question": "Which one of the following is a complete and accurate list of bands any one of which could be the band that performs in slot one?",
    "answer": "D",
    "options": [
      "A) Yardsign",
      "B) Vegemite, Wellspring",
      "C) Vegemite, Yardsign",
      "D) Vegemite, Wellspring, Yardsign",
      "E) Vegemite, Wellspring, Yardsign, Zircon"
    ],
    "raw_logic_programs": [
      "# Declarations\nbands = EnumSort([Uneasy, Vegemite, Wellspring, Xpert, Yardsign, Zircon])\nslots = EnumSort([1, 2, 3, 4, 5, 6])\nperforms = Function([bands] -> [slots])\n\n# Constraints\nForAll([b:bands], Exists([s:slots], performs(b) == s)) ::: Each band will perform in just one slot\nperforms(Vegemite) < performs(Zircon) ::: Vegemite performs in an earlier slot than Zircon\nAnd(performs(Wellspring) < performs(Xpert), performs(Zircon) < performs(Xpert)) ::: Wellspring and Zircon each perform in an earlier slot than Xpert\nAnd(3 <= performs(Uneasy), performs(Uneasy) <= 6) ::: Uneasy performs in one of the last three slots\nAnd(1 <= performs(Yardsign), performs(Yardsign) <= 3) ::: Yardsign performs in one of the first three slots\n\n# Options\nQuestion ::: Which one of the following is a complete and accurate list of bands any one of which could be the band that performs in slot one?\nis_accurate_list([performs(Yardsign) == 1]) ::: (A)\nis_accurate_list([performs(Vegemite) == 1, performs(Wellspring) == 1]) ::: (B)\nis_accurate_list([performs(Vegemite) == 1, performs(Yardsign) == 1]) ::: (C)\nis_accurate_list([performs(Vegemite) == 1, performs(Wellspring) == 1, performs(Yardsign) == 1]) ::: (D)\nis_accurate_list([performs(Vegemite) == 1, performs(Wellspring) == 1, performs(Yardsign) == 1, performs(Zircon) == 1]) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201310_3-G_1_6",
    "context": "A concert promoter is filling the six slots at a benefit concert. The slots, from earliest to latest, are numbered slot one through slot six. The slots will be filled by six bands—Uneasy, Vegemite, Wellspring, Xpert, Yardsign, and Zircon. Each band will perform in just one slot. The order must meet the following constraints: Vegemite performs in an earlier slot than Zircon. Wellspring and Zircon each perform in an earlier slot than Xpert. Uneasy performs in one of the last three slots. Yardsign performs in one of the first three slots.",
    "question": "If Wellspring performs immediately before Xpert, which one of the following could be true?",
    "answer": "D",
    "options": [
      "A) Uneasy performs in slot five.",
      "B) Vegemite performs in slot three.",
      "C) Wellspring performs in slot three.",
      "D) Zircon performs in slot two.",
      "E) Zircon performs in slot four."
    ],
    "raw_logic_programs": [
      "# Declarations\nbands = EnumSort([Uneasy, Vegemite, Wellspring, Xpert, Yardsign, Zircon])\nslots = EnumSort([1, 2, 3, 4, 5, 6])\nperforms = Function([bands] -> [slots])\n\n# Constraints\nForAll([b:bands], Count([s:slots], performs(b) == s) == 1) ::: Each band will perform in just one slot\nperforms(Vegemite) < performs(Zircon) ::: Vegemite performs in an earlier slot than Zircon\nAnd(performs(Wellspring) < performs(Xpert), performs(Zircon) < performs(Xpert)) ::: Wellspring and Zircon each perform in an earlier slot than Xpert\nAnd(performs(Uneasy) >= 4, performs(Uneasy) <= 6) ::: Uneasy performs in one of the last three slots\nAnd(performs(Yardsign) >= 1, performs(Yardsign) <= 3) ::: Yardsign performs in one of the first three slots\nperforms(Wellspring) + 1 == performs(Xpert) ::: Wellspring performs immediately before Xpert\n\n# Options\nQuestion ::: If Wellspring performs immediately before Xpert, which one of the following could be true?\nis_sat(performs(Uneasy) == 5) ::: (A)\nis_sat(performs(Vegemite) == 3) ::: (B)\nis_sat(performs(Wellspring) == 3) ::: (C)\nis_sat(performs(Zircon) == 2) ::: (D)\nis_sat(performs(Zircon) == 4) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201310_3-G_1_7",
    "context": "A concert promoter is filling the six slots at a benefit concert. The slots, from earliest to latest, are numbered slot one through slot six. The slots will be filled by six bands—Uneasy, Vegemite, Wellspring, Xpert, Yardsign, and Zircon. Each band will perform in just one slot. The order must meet the following constraints: Vegemite performs in an earlier slot than Zircon. Wellspring and Zircon each perform in an earlier slot than Xpert. Uneasy performs in one of the last three slots. Yardsign performs in one of the first three slots.",
    "question": "Which one of the following, if substituted for the constraint that Wellspring and Zircon each perform in an earlier slot than Xpert, would have the same effect in determining the order in which the bands perform?",
    "answer": "A",
    "options": [
      "A) Only Uneasy can perform in a later slot than Xpert.",
      "B) Vegemite performs in an earlier slot than Wellspring, which performs in an earlier slot than Zircon.",
      "C) Vegemite and Wellspring each perform in an earlier slot than Xpert.",
      "D) Xpert performs either immediately before or immediately after Uneasy.",
      "E) Xpert performs in either slot five or slot six."
    ],
    "raw_logic_programs": [
      "# Declarations\nbands = EnumSort([Uneasy, Vegemite, Wellspring, Xpert, Yardsign, Zircon])\nslots = EnumSort([1, 2, 3, 4, 5, 6])\nperforms = Function([bands] -> [slots])\n\n# Constraints\nForAll([b:bands], Count([s:slots], performs(b) == s) == 1) ::: Each band will perform in just one slot\nperforms(Vegemite) < performs(Zircon) ::: Vegemite performs in an earlier slot than Zircon\nAnd(performs(Wellspring) < performs(Xpert), performs(Zircon) < performs(Xpert)) ::: Wellspring and Zircon each perform in an earlier slot than Xpert\nAnd(3 <= performs(Uneasy), performs(Uneasy) <= 6) ::: Uneasy performs in one of the last three slots\nAnd(1 <= performs(Yardsign), performs(Yardsign) <= 3) ::: Yardsign performs in one of the first three slots\n\n# Options\nQuestion ::: Which one of the following, if substituted for the constraint that Wellspring and Zircon each perform in an earlier slot than Xpert, would have the same effect in determining the order in which the bands perform?\nis_equivalent(ForAll([b:bands], Implies(b == Uneasy, performs(b) < performs(Xpert)))) ::: (A)\nis_equivalent(And(performs(Vegemite) < performs(Wellspring), performs(Wellspring) < performs(Zircon))) ::: (B)\nis_equivalent(And(performs(Vegemite) < performs(Xpert), performs(Wellspring) < performs(Xpert))) ::: (C)\nis_equivalent(Or(performs(Xpert) == performs(Uneasy) - 1, performs(Xpert) == performs(Uneasy) + 1)) ::: (D)\nis_equivalent(Or(performs(Xpert) == 5, performs(Xpert) == 6)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201310_3-G_2_8",
    "context": "A corporate manager is selecting employees for a research team. The team will include at least four employees, all from among the following eight: Myers, Ortega, Paine, Schmidt, Thomson, Wong, Yoder, and Zayre. The selection is constrained by the following conditions: If Myers is on the team, neither Ortega nor Paine can be. If Schmidt is on the team, both Paine and Thomson must also be. If Wong is on the team, both Myers and Yoder must also be.",
    "question": "Which one of the following is a possible selection of employees for the team?",
    "answer": "B",
    "options": [
      "A) Myers, Paine, Schmidt, and Thomson",
      "B) Ortega, Paine, Thomson, and Zayre",
      "C) Paine, Schmidt, Yoder, and Zayre",
      "D) Schmidt, Thomson, Yoder, and Zayre",
      "E) Thomson, Wong, Yoder, and Zayre"
    ],
    "raw_logic_programs": [
      "# Declarations\nemployees = EnumSort([Myers, Ortega, Paine, Schmidt, Thomson, Wong, Yoder, Zayre])\non_team = Function([employees] -> [bool])\n\n# Constraints\nForAll([e:employees], Implies(on_team(e), on_team(e))) ::: If an employee is on the team, then they are on the team\nCount([e:employees], on_team(e)) >= 4 ::: The team will include at least four employees\nImplies(on_team(Myers), And(Not(on_team(Ortega)), Not(on_team(Paine)))) ::: If Myers is on the team, neither Ortega nor Paine can be\nImplies(on_team(Schmidt), And(on_team(Paine), on_team(Thomson))) ::: If Schmidt is on the team, both Paine and Thomson must also be\nImplies(on_team(Wong), And(on_team(Myers), on_team(Yoder))) ::: If Wong is on the team, both Myers and Yoder must also be\n\n# Options\nQuestion ::: Which one of the following is a possible selection of employees for the team?\nis_sat(And(on_team(Myers), on_team(Paine), on_team(Schmidt), on_team(Thomson))) ::: (A)\nis_sat(And(on_team(Ortega), on_team(Paine), on_team(Thomson), on_team(Zayre))) ::: (B)\nis_sat(And(on_team(Paine), on_team(Schmidt), on_team(Yoder), on_team(Zayre))) ::: (C)\nis_sat(And(on_team(Schmidt), on_team(Thomson), on_team(Yoder), on_team(Zayre))) ::: (D)\nis_sat(And(on_team(Thomson), on_team(Wong), on_team(Yoder), on_team(Zayre))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201310_3-G_2_9",
    "context": "A corporate manager is selecting employees for a research team. The team will include at least four employees, all from among the following eight: Myers, Ortega, Paine, Schmidt, Thomson, Wong, Yoder, and Zayre. The selection is constrained by the following conditions: If Myers is on the team, neither Ortega nor Paine can be. If Schmidt is on the team, both Paine and Thomson must also be. If Wong is on the team, both Myers and Yoder must also be.",
    "question": "Which one of the following is a pair of employees who CANNOT be on the team together?",
    "answer": "D",
    "options": [
      "A) Myers and Thomson",
      "B) Ortega and Yoder",
      "C) Paine and Zayre",
      "D) Schmidt and Wong",
      "E) Wong and Yoder"
    ],
    "raw_logic_programs": [
      "# Declarations\nemployees = EnumSort([Myers, Ortega, Paine, Schmidt, Thomson, Wong, Yoder, Zayre])\non_team = Function([employees] -> [bool])\n\n# Constraints\nForAll([e:employees], on_team(e) <= 1) ::: each employee can be on the team at most once\nCount([e:employees], on_team(e)) >= 4 ::: the team will include at least four employees\nImplies(on_team(Myers), And(Not(on_team(Ortega)), Not(on_team(Paine)))) ::: If Myers is on the team, neither Ortega nor Paine can be\nImplies(on_team(Schmidt), And(on_team(Paine), on_team(Thomson))) ::: If Schmidt is on the team, both Paine and Thomson must also be\nImplies(on_team(Wong), And(on_team(Myers), on_team(Yoder))) ::: If Wong is on the team, both Myers and Yoder must also be\n\n# Options\nQuestion ::: Which one of the following is a pair of employees who CANNOT be on the team together?\nis_unsat(And(on_team(Myers), on_team(Thomson))) ::: (A)\nis_unsat(And(on_team(Ortega), on_team(Yoder))) ::: (B)\nis_unsat(And(on_team(Paine), on_team(Zayre))) ::: (C)\nis_unsat(And(on_team(Schmidt), on_team(Wong))) ::: (D)\nis_unsat(And(on_team(Wong), on_team(Yoder))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201310_3-G_2_10",
    "context": "A corporate manager is selecting employees for a research team. The team will include at least four employees, all from among the following eight: Myers, Ortega, Paine, Schmidt, Thomson, Wong, Yoder, and Zayre. The selection is constrained by the following conditions: If Myers is on the team, neither Ortega nor Paine can be. If Schmidt is on the team, both Paine and Thomson must also be. If Wong is on the team, both Myers and Yoder must also be.",
    "question": "If Yoder is not on the team, then any of the following could be on the team EXCEPT:",
    "answer": "E",
    "options": [
      "A) Zayre",
      "B) Thomson",
      "C) Paine",
      "D) Ortega",
      "E) Myers"
    ],
    "raw_logic_programs": [
      "# Declarations\nemployees = EnumSort([Myers, Ortega, Paine, Schmidt, Thomson, Wong, Yoder, Zayre])\non_team = Function([employees] -> [bool])\n\n# Constraints\nImplies(on_team(Myers), And(Not(on_team(Ortega)), Not(on_team(Paine)))) ::: If Myers is on the team, neither Ortega nor Paine can be\nImplies(on_team(Schmidt), And(on_team(Paine), on_team(Thomson))) ::: If Schmidt is on the team, both Paine and Thomson must also be\nImplies(on_team(Wong), And(on_team(Myers), on_team(Yoder))) ::: If Wong is on the team, both Myers and Yoder must also be\nCount([e:employees], on_team(e)) >= 4 ::: The team will include at least four employees\n\n# Options\nQuestion ::: If Yoder is not on the team, then any of the following could be on the team EXCEPT:\nNot(on_team(Yoder))\nis_unsat(on_team(Zayre)) ::: (A)\nis_unsat(on_team(Thomson)) ::: (B)\nis_unsat(on_team(Paine)) ::: (C)\nis_unsat(on_team(Ortega)) ::: (D)\nis_unsat(on_team(Myers)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201310_3-G_2_11",
    "context": "A corporate manager is selecting employees for a research team. The team will include at least four employees, all from among the following eight: Myers, Ortega, Paine, Schmidt, Thomson, Wong, Yoder, and Zayre. The selection is constrained by the following conditions: If Myers is on the team, neither Ortega nor Paine can be. If Schmidt is on the team, both Paine and Thomson must also be. If Wong is on the team, both Myers and Yoder must also be.",
    "question": "If Paine is not on the team, which one of the following could be true?",
    "answer": "D",
    "options": [
      "A) Neither Myers nor Ortega is on the team.",
      "B) Neither Myers nor Thomson is on the team.",
      "C) Neither Myers nor Zayre is on the team.",
      "D) Neither Ortega nor Thomson is on the team.",
      "E) Neither Ortega nor Yoder is on the team."
    ],
    "raw_logic_programs": [
      "# Declarations\nemployees = EnumSort([Myers, Ortega, Paine, Schmidt, Thomson, Wong, Yoder, Zayre])\non_team = Function([employees] -> [bool])\n\n# Constraints\nForAll([e:employees], on_team(e) <= 1) ::: each employee is either on the team or not\nCount([e:employees], on_team(e)) >= 4 ::: The team will include at least four employees\nImplies(on_team(Myers), And(Not(on_team(Ortega)), Not(on_team(Paine)))) ::: If Myers is on the team, neither Ortega nor Paine can be\nImplies(on_team(Schmidt), And(on_team(Paine), on_team(Thomson))) ::: If Schmidt is on the team, both Paine and Thomson must also be\nImplies(on_team(Wong), And(on_team(Myers), on_team(Yoder))) ::: If Wong is on the team, both Myers and Yoder must also be\nNot(on_team(Paine)) ::: Paine is not on the team\n\n# Options\nQuestion ::: If Paine is not on the team, which one of the following could be true?\nis_sat(And(Not(on_team(Myers)), Not(on_team(Ortega)))) ::: (A)\nis_sat(And(Not(on_team(Myers)), Not(on_team(Thomson)))) ::: (B)\nis_sat(And(Not(on_team(Myers)), Not(on_team(Zayre)))) ::: (C)\nis_sat(And(Not(on_team(Ortega)), Not(on_team(Thomson)))) ::: (D)\nis_sat(And(Not(on_team(Ortega)), Not(on_team(Yoder)))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201310_3-G_2_12",
    "context": "A corporate manager is selecting employees for a research team. The team will include at least four employees, all from among the following eight: Myers, Ortega, Paine, Schmidt, Thomson, Wong, Yoder, and Zayre. The selection is constrained by the following conditions: If Myers is on the team, neither Ortega nor Paine can be. If Schmidt is on the team, both Paine and Thomson must also be. If Wong is on the team, both Myers and Yoder must also be.",
    "question": "Which one of the following is a pair of employees at least one of whom must be on the team?",
    "answer": "D",
    "options": [
      "A) Ortega and Schmidt",
      "B) Ortega and Wong",
      "C) Paine and Schmidt",
      "D) Thomson and Yoder",
      "E) Yoder and Zayre"
    ],
    "raw_logic_programs": [
      "# Declarations\nemployees = EnumSort([Myers, Ortega, Paine, Schmidt, Thomson, Wong, Yoder, Zayre])\non_team = Function([employees] -> [bool])\n\n# Constraints\nImplies(on_team(Myers), And(Not(on_team(Ortega)), Not(on_team(Paine)))) ::: If Myers is on the team, neither Ortega nor Paine can be\nImplies(on_team(Schmidt), And(on_team(Paine), on_team(Thomson))) ::: If Schmidt is on the team, both Paine and Thomson must also be\nImplies(on_team(Wong), And(on_team(Myers), on_team(Yoder))) ::: If Wong is on the team, both Myers and Yoder must also be\nCount([e:employees], on_team(e)) >= 4 ::: The team will include at least four employees\n\n# Options\nQuestion ::: Which one of the following is a pair of employees at least one of whom must be on the team?\nis_unsat(And(Not(on_team(Ortega)), Not(on_team(Schmidt)))) ::: (A)\nis_unsat(And(Not(on_team(Ortega)), Not(on_team(Wong)))) ::: (B)\nis_unsat(And(Not(on_team(Paine)), Not(on_team(Schmidt)))) ::: (C)\nis_unsat(And(Not(on_team(Thomson)), Not(on_team(Yoder)))) ::: (D)\nis_unsat(And(Not(on_team(Yoder)), Not(on_team(Zayre)))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201310_3-G_3_13",
    "context": "Exactly five movies are showing at the repertory theater this evening: a horror film, a mystery, a romance, a sci-fi film, and a western. Each movie is shown exactly once, on one of the theater's three screens: screens 1, 2, and 3. Screens 1 and 2 show two movies each, one beginning at 7 P.M. and the other at 9 P.M.; screen 3 shows exactly one movie, at 8 P.M. The following conditions apply to this evening's schedule: The western begins at some time before the horror film does. The sci-fi film is not shown on screen 3. The romance is not shown on screen 2. The horror film and the mystery are shown on different screens.",
    "question": "Which one of the following is an acceptable schedule of the movies for this evening?",
    "answer": "A",
    "options": [
      "A) screen 1: romance at 7 P.M., horror film at 9 P.M. screen 2: western at 7 P.M., sci-fi film at 9 P.M. screen 3: mystery at 8 P.M.",
      "B) screen 1: mystery at 7 P.M., romance at 9 P.M. screen 2: horror film at 7 P.M., sci-fi film at 9 P.M. screen 3: western at 8 P.M.",
      "C) screen 1: western at 7 P.M., sci-fi film at 9 P.M. screen 2: mystery at 7 P.M., horror film at 9 P.M. screen 3: romance at 8 P.M.",
      "D) screen 1: romance at 7 P.M., mystery at 9 P.M. screen 2: western at 7 P.M., horror film at 9 P.M. screen 3: sci-fi film at 8 P.M.",
      "E) screen 1: western at 7 P.M., mystery at 9 P.M. screen 2: sci-fi film at 7 P.M., romance at 9 P.M. screen 3: horror film at 8 P.M."
    ],
    "raw_logic_programs": [
      "# Declarations\nmovies = EnumSort([horror, mystery, romance, sci_fi, western])\nscreens = EnumSort([1, 2, 3])\ntimes = EnumSort([7, 8, 9])\nshows = Function([movies, screens, times] -> [bool])\n\n# Constraints\nForAll([m:movies], Count([s:screens, t:times], shows(m, s, t)) == 1) ::: Each movie is shown exactly once\nForAll([s:screens], Count([m:movies, t:times], shows(m, s, t)) <= 2) ::: Screens 1 and 2 show two movies each\nForAll([s:screens], Count([m:movies, t:times], shows(m, s, t)) == 1) ::: screen 3 shows exactly one movie\nForAll([m:movies], Exists([t:times], shows(m, 3, t))) ::: screen 3 shows exactly one movie\nForAll([t:times], Exists([m:movies], shows(m, 3, t))) ::: screen 3 shows exactly one movie\nExists([t1:times, t2:times], And(shows(western, _, t1), shows(horror, _, t2), t1 < t2)) ::: The western begins at some time before the horror film does\nForAll([t:times], Not(shows(sci_fi, 3, t))) ::: The sci-fi film is not shown on screen 3\nForAll([t:times], Not(shows(romance, 2, t))) ::: The romance is not shown on screen 2\nForAll([s1:screens, s2:screens, t1:times, t2:times], Implies(And(shows(horror, s1, t1), shows(mystery, s2, t2)), s1 != s2)) ::: The horror film and the mystery are shown on different screens\n\n# Options\nQuestion ::: Which one of the following is an acceptable schedule of the movies for this evening?\nis_sat(And(shows(romance, 1, 7), shows(horror, 1, 9), shows(western, 2, 7), shows(sci_fi, 2, 9), shows(mystery, 3, 8))) ::: (A)\nis_sat(And(shows(mystery, 1, 7), shows(romance, 1, 9), shows(horror, 2, 7), shows(sci_fi, 2, 9), shows(western, 3, 8))) ::: (B)\nis_sat(And(shows(western, 1, 7), shows(sci_fi, 1, 9), shows(mystery, 2, 7), shows(horror, 2, 9), shows(romance, 3, 8))) ::: (C)\nis_sat(And(shows(romance, 1, 7), shows(mystery, 1, 9), shows(western, 2, 7), shows(horror, 2, 9), shows(sci_fi, 3, 8))) ::: (D)\nis_sat(And(shows(western, 1, 7), shows(mystery, 1, 9), shows(sci_fi, 2, 7), shows(romance, 2, 9), shows(horror, 3, 8))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201310_3-G_3_14",
    "context": "Exactly five movies are showing at the repertory theater this evening: a horror film, a mystery, a romance, a sci-fi film, and a western. Each movie is shown exactly once, on one of the theater's three screens: screens 1, 2, and 3. Screens 1 and 2 show two movies each, one beginning at 7 P.M. and the other at 9 P.M.; screen 3 shows exactly one movie, at 8 P.M. The following conditions apply to this evening's schedule: The western begins at some time before the horror film does. The sci-fi film is not shown on screen 3. The romance is not shown on screen 2. The horror film and the mystery are shown on different screens.",
    "question": "Which one of the following CANNOT be an accurate list of the movies scheduled to be shown on screen 2 this evening, listing the 7 P.M. movie first?",
    "answer": "D",
    "options": [
      "A) the sci-fi film, the horror film",
      "B) the sci-fi film, the mystery",
      "C) the sci-fi film, the western",
      "D) the western, the horror film",
      "E) the western, the mystery"
    ],
    "raw_logic_programs": [
      "# Declarations\nmovies = EnumSort([horror, mystery, romance, sci_fi, western])\nscreens = EnumSort([1, 2, 3])\ntimes = EnumSort([7, 8, 9])\nshows = Function([movies, screens, times] -> [bool])\n\n# Constraints\nForAll([m:movies], Count([s:screens, t:times], shows(m, s, t)) == 1) ::: Each movie is shown exactly once\nForAll([s:screens], Count([m:movies, t:times], shows(m, s, t)) <= 2) ::: Screens 1 and 2 show two movies each\nForAll([s:screens], Count([m:movies, t:times], shows(m, s, t)) == 1) ::: screen 3 shows exactly one movie\nForAll([m:movies], Exists([t:times], shows(m, 3, t))) ::: screen 3 shows exactly one movie\nForAll([t:times], Exists([m:movies], shows(m, 3, t))) ::: screen 3 shows exactly one movie\nExists([t:times], And(shows(western, t, 1), shows(horror, t, 1))) ::: The western begins at some time before the horror film does\nForAll([t:times], Not(shows(sci_fi, 3, t))) ::: The sci-fi film is not shown on screen 3\nForAll([t:times], Not(shows(romance, 2, t))) ::: The romance is not shown on screen 2\nForAll([t:times], Implies(shows(horror, 1, t), Not(shows(mystery, 1, t)))) ::: The horror film and the mystery are shown on different screens\nForAll([t:times], Implies(shows(horror, 2, t), Not(shows(mystery, 2, t)))) ::: The horror film and the mystery are shown on different screens\nForAll([t:times], Implies(shows(horror, 3, t), Not(shows(mystery, 3, t)))) ::: The horror film and the mystery are shown on different screens\n\n# Options\nQuestion ::: Which one of the following CANNOT be an accurate list of the movies scheduled to be shown on screen 2 this evening, listing the 7 P.M. movie first?\nis_unsat(And(shows(sci_fi, 2, 7), shows(horror, 2, 9))) ::: (A)\nis_unsat(And(shows(sci_fi, 2, 7), shows(mystery, 2, 9))) ::: (B)\nis_unsat(And(shows(sci_fi, 2, 7), shows(western, 2, 9))) ::: (C)\nis_unsat(And(shows(western, 2, 7), shows(horror, 2, 9))) ::: (D)\nis_unsat(And(shows(western, 2, 7), shows(mystery, 2, 9))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201310_3-G_3_15",
    "context": "Exactly five movies are showing at the repertory theater this evening: a horror film, a mystery, a romance, a sci-fi film, and a western. Each movie is shown exactly once, on one of the theater's three screens: screens 1, 2, and 3. Screens 1 and 2 show two movies each, one beginning at 7 P.M. and the other at 9 P.M.; screen 3 shows exactly one movie, at 8 P.M. The following conditions apply to this evening's schedule: The western begins at some time before the horror film does. The sci-fi film is not shown on screen 3. The romance is not shown on screen 2. The horror film and the mystery are shown on different screens.",
    "question": "If the western and the sci-fi film are scheduled to be shown on the same screen, then which one of the following could be true of this evening's schedule?",
    "answer": "B",
    "options": [
      "A) The horror film is shown on screen 2.",
      "B) The mystery begins at 9 P.M.",
      "C) The romance is shown on screen 3.",
      "D) The sci-fi film begins at 7 P.M.",
      "E) The western begins at 8 P.M."
    ],
    "raw_logic_programs": [
      "# Declarations\nmovies = EnumSort([horror, mystery, romance, sci_fi, western])\nscreens = EnumSort([1, 2, 3])\ntimes = EnumSort([7, 8, 9])\nshows = Function([movies] -> [screens])\nstarts = Function([movies] -> [times])\n\n# Constraints\nForAll([m:movies], Exists([s:screens], shows(m) == s)) ::: Each movie is shown exactly once, on one of the theater's three screens\nForAll([s:screens], Count([m:movies], shows(m) == s) <= 2) ::: Screens 1 and 2 show two movies each, one beginning at 7 P.M. and the other at 9 P.M.; screen 3 shows exactly one movie, at 8 P.M.\nstarts(western) < starts(horror) ::: The western begins at some time before the horror film does\nshows(sci_fi) != 3 ::: The sci-fi film is not shown on screen 3\nshows(romance) != 2 ::: The romance is not shown on screen 2\nshows(horror) != shows(mystery) ::: The horror film and the mystery are shown on different screens\n\n# Options\nQuestion ::: If the western and the sci-fi film are scheduled to be shown on the same screen, then which one of the following could be true of this evening's schedule?\nis_sat(And(shows(western) == shows(sci_fi), shows(horror) == 2)) ::: (A)\nis_sat(And(shows(western) == shows(sci_fi), starts(mystery) == 9)) ::: (B)\nis_sat(And(shows(western) == shows(sci_fi), shows(romance) == 3)) ::: (C)\nis_sat(And(shows(western) == shows(sci_fi), starts(sci_fi) == 7)) ::: (D)\nis_sat(And(shows(western) == shows(sci_fi), starts(western) == 8)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201310_3-G_3_16",
    "context": "Exactly five movies are showing at the repertory theater this evening: a horror film, a mystery, a romance, a sci-fi film, and a western. Each movie is shown exactly once, on one of the theater's three screens: screens 1, 2, and 3. Screens 1 and 2 show two movies each, one beginning at 7 P.M. and the other at 9 P.M.; screen 3 shows exactly one movie, at 8 P.M. The following conditions apply to this evening's schedule: The western begins at some time before the horror film does. The sci-fi film is not shown on screen 3. The romance is not shown on screen 2. The horror film and the mystery are shown on different screens.",
    "question": "If the romance is scheduled to begin before the western does, then which one of the following must be true of this evening's schedule?",
    "answer": "E",
    "options": [
      "A) The horror film is shown on screen 1.",
      "B) The mystery begins at 7 P.M.",
      "C) The mystery is shown on screen 2.",
      "D) The sci-fi film begins at 9 P.M.",
      "E) The sci-fi film is shown on screen 2."
    ],
    "raw_logic_programs": [
      "# Declarations\nmovies = EnumSort([horror, mystery, romance, sci_fi, western])\nscreens = EnumSort([1, 2, 3])\ntimes = EnumSort([7, 8, 9])\nshows = Function([movies] -> [screens])\nbegins = Function([movies] -> [times])\n\n# Constraints\nForAll([m:movies], Exists([s:screens], shows(m) == s)) ::: Each movie is shown exactly once, on one of the theater's three screens\nForAll([m:movies], Exists([t:times], begins(m) == t)) ::: Each movie is shown exactly once, on one of the theater's three screens\nAnd(Count([m:movies], shows(m) == 1) == 1, Count([m:movies], shows(m) == 2) == 2) ::: Screens 1 and 2 show two movies each, one beginning at 7 P.M. and the other at 9 P.M.; screen 3 shows exactly one movie, at 8 P.M.\nAnd(Count([m:movies], begins(m) == 7) == 2, Count([m:movies], begins(m) == 9) == 2, Count([m:movies], begins(m) == 8) == 1) ::: Screens 1 and 2 show two movies each, one beginning at 7 P.M. and the other at 9 P.M.; screen 3 shows exactly one movie, at 8 P.M.\nbegins(western) < begins(horror) ::: The western begins at some time before the horror film does\nshows(sci_fi) != 3 ::: The sci-fi film is not shown on screen 3\nshows(romance) != 2 ::: The romance is not shown on screen 2\nshows(horror) != shows(mystery) ::: The horror film and the mystery are shown on different screens\n\n# Options\nQuestion ::: If the romance is scheduled to begin before the western does, then which one of the following must be true of this evening's schedule?\nis_valid(Implies(begins(romance) < begins(western), shows(horror) == 1)) ::: (A)\nis_valid(Implies(begins(romance) < begins(western), begins(mystery) == 7)) ::: (B)\nis_valid(Implies(begins(romance) < begins(western), shows(mystery) == 2)) ::: (C)\nis_valid(Implies(begins(romance) < begins(western), begins(sci_fi) == 9)) ::: (D)\nis_valid(Implies(begins(romance) < begins(western), shows(sci_fi) == 2)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201310_3-G_3_17",
    "context": "Exactly five movies are showing at the repertory theater this evening: a horror film, a mystery, a romance, a sci-fi film, and a western. Each movie is shown exactly once, on one of the theater's three screens: screens 1, 2, and 3. Screens 1 and 2 show two movies each, one beginning at 7 P.M. and the other at 9 P.M.; screen 3 shows exactly one movie, at 8 P.M. The following conditions apply to this evening's schedule: The western begins at some time before the horror film does. The sci-fi film is not shown on screen 3. The romance is not shown on screen 2. The horror film and the mystery are shown on different screens.",
    "question": "Which one of the following CANNOT be an accurate list of the movies scheduled to be shown on screen 1 this evening, listing the 7 P.M. movie first?",
    "answer": "E",
    "options": [
      "A) the sci-fi film, the horror film",
      "B) the sci-fi film, the mystery",
      "C) the western, the horror film",
      "D) the western, the mystery",
      "E) the western, the sci-fi film"
    ],
    "raw_logic_programs": [
      "# Declarations\nmovies = EnumSort([horror, mystery, romance, sci_fi, western])\nscreens = EnumSort([1, 2, 3])\ntimes = EnumSort([7, 8, 9])\nshows = Function([movies, screens, times] -> [bool])\n\n# Constraints\nForAll([m:movies], Count([s:screens, t:times], shows(m, s, t)) == 1) ::: Each movie is shown exactly once\nForAll([s:screens], Count([m:movies, t:times], shows(m, s, t)) <= 2) ::: Screens 1 and 2 show two movies each\nForAll([s:screens], Count([m:movies, t:times], shows(m, s, t)) == 1) ::: screen 3 shows exactly one movie\nForAll([m:movies], Exists([t:times], shows(m, 3, t))) ::: screen 3 shows exactly one movie\nForAll([t:times], Count([m:movies, s:screens], shows(m, s, t)) <= 1) ::: no two movies are shown at the same time\nExists([t1:times, t2:times], And(shows(western, _, t1), shows(horror, _, t2), t1 < t2)) ::: The western begins at some time before the horror film does\nForAll([t:times], Not(shows(sci_fi, 3, t))) ::: The sci-fi film is not shown on screen 3\nForAll([t:times], Not(shows(romance, 2, t))) ::: The romance is not shown on screen 2\nForAll([s1:screens, s2:screens, t1:times, t2:times], Implies(And(shows(horror, s1, t1), shows(mystery, s2, t2)), s1 != s2)) ::: The horror film and the mystery are shown on different screens\n\n# Options\nQuestion ::: Which one of the following CANNOT be an accurate list of the movies scheduled to be shown on screen 1 this evening, listing the 7 P.M. movie first?\nis_unsat(And(shows(sci_fi, 1, 7), shows(horror, 1, 9))) ::: (A)\nis_unsat(And(shows(sci_fi, 1, 7), shows(mystery, 1, 9))) ::: (B)\nis_unsat(And(shows(western, 1, 7), shows(horror, 1, 9))) ::: (C)\nis_unsat(And(shows(western, 1, 7), shows(mystery, 1, 9))) ::: (D)\nis_unsat(And(shows(western, 1, 7), shows(sci_fi, 1, 9))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201310_3-G_3_18",
    "context": "Exactly five movies are showing at the repertory theater this evening: a horror film, a mystery, a romance, a sci-fi film, and a western. Each movie is shown exactly once, on one of the theater's three screens: screens 1, 2, and 3. Screens 1 and 2 show two movies each, one beginning at 7 P.M. and the other at 9 P.M.; screen 3 shows exactly one movie, at 8 P.M. The following conditions apply to this evening's schedule: The western begins at some time before the horror film does. The sci-fi film is not shown on screen 3. The romance is not shown on screen 2. The horror film and the mystery are shown on different screens.",
    "question": "If the sci-fi film and the romance are to be shown on the same screen, then which one of the following must be true of this evening's schedule?",
    "answer": "A",
    "options": [
      "A) The western begins at 7 P.M.",
      "B) The sci-fi film begins at 9 P.M.",
      "C) The mystery begins at 8 P.M.",
      "D) The romance begins at 9 P.M.",
      "E) The horror film begins at 8 P.M."
    ],
    "raw_logic_programs": [
      "# Declarations\nmovies = EnumSort([horror, mystery, romance, sci_fi, western])\nscreens = EnumSort([1, 2, 3])\ntimes = EnumSort([7, 8, 9])\nshows = Function([movies] -> [screens])\nstarts = Function([movies] -> [times])\n\n# Constraints\nForAll([m:movies], Exists([s:screens], shows(m) == s)) ::: Each movie is shown exactly once, on one of the theater's three screens\nForAll([m:movies], Exists([t:times], starts(m) == t)) ::: Each movie is shown exactly once, on one of the theater's three screens\nAnd(Count([m:movies], And(shows(m) == 1, starts(m) == 7)) == 1, Count([m:movies], And(shows(m) == 1, starts(m) == 9)) == 1) ::: Screens 1 and 2 show two movies each, one beginning at 7 P.M. and the other at 9 P.M.\nAnd(Count([m:movies], And(shows(m) == 2, starts(m) == 7)) == 1, Count([m:movies], And(shows(m) == 2, starts(m) == 9)) == 1) ::: Screens 1 and 2 show two movies each, one beginning at 7 P.M. and the other at 9 P.M.\nCount([m:movies], And(shows(m) == 3, starts(m) == 8)) == 1 ::: screen 3 shows exactly one movie, at 8 P.M.\nstarts(western) < starts(horror) ::: The western begins at some time before the horror film does\nshows(sci_fi) != 3 ::: The sci-fi film is not shown on screen 3\nshows(romance) != 2 ::: The romance is not shown on screen 2\nshows(horror) != shows(mystery) ::: The horror film and the mystery are shown on different screens\n\n# Options\nQuestion ::: If the sci-fi film and the romance are to be shown on the same screen, then which one of the following must be true of this evening's schedule?\nis_valid(And(shows(sci_fi) == shows(romance), starts(western) == 7)) ::: (A)\nis_valid(And(shows(sci_fi) == shows(romance), starts(sci_fi) == 9)) ::: (B)\nis_valid(And(shows(sci_fi) == shows(romance), starts(mystery) == 8)) ::: (C)\nis_valid(And(shows(sci_fi) == shows(romance), starts(romance) == 9)) ::: (D)\nis_valid(And(shows(sci_fi) == shows(romance), starts(horror) == 8)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201310_3-G_4_19",
    "context": "A naturalist will give five lectures, each on a different type of bird: oystercatchers, petrels, rails, sandpipers, or terns. The lectures must be given in either Gladwyn Hall or Howard Auditorium, in an order that meets the following conditions: The first lecture is in Gladwyn Hall. The fourth lecture is in Howard Auditorium. Exactly three of the lectures are in Gladwyn Hall. The lecture on sandpipers is in Howard Auditorium and is given earlier than the lecture on oystercatchers. The lecture on terns is given earlier than the lecture on petrels, which is in Gladwyn Hall.",
    "question": "Which one of the following is an acceptable order for the lectures, from first to fifth?",
    "answer": "E",
    "options": [
      "A) oystercatchers, petrels, rails, sandpipers, terns",
      "B) petrels, sandpipers, oystercatchers, terns, rails",
      "C) rails, sandpipers, terns, petrels, oystercatchers",
      "D) sandpipers, terns, oystercatchers, rails, petrels",
      "E) terns, petrels, sandpipers, oystercatchers, rails"
    ],
    "raw_logic_programs": [
      "# Declarations\nbirds = EnumSort([oystercatchers, petrels, rails, sandpipers, terns])\nlocations = EnumSort([Gladwyn_Hall, Howard_Auditorium])\nlecture_order = Function([birds] -> [int])\nlocation = Function([birds] -> [locations])\nForAll([b:birds], And(1 <= lecture_order(b), lecture_order(b) <= 5))\n\n# Constraints\nlocation(oystercatchers) == Gladwyn_Hall ::: The first lecture is in Gladwyn Hall\nlocation(sandpipers) == Howard_Auditorium ::: The lecture on sandpipers is in Howard Auditorium\nCount([b:birds], location(b) == Gladwyn_Hall) == 3 ::: Exactly three of the lectures are in Gladwyn Hall\nlocation(petrels) == Gladwyn_Hall ::: The lecture on petrels is in Gladwyn Hall\nlecture_order(sandpipers) < lecture_order(oystercatchers) ::: The lecture on sandpipers is given earlier than the lecture on oystercatchers\nlecture_order(terns) < lecture_order(petrels) ::: The lecture on terns is given earlier than the lecture on petrels\n\n# Options\nQuestion ::: Which one of the following is an acceptable order for the lectures, from first to fifth?\nis_valid(And(lecture_order(oystercatchers) == 1, lecture_order(petrels) == 2, lecture_order(rails) == 3, lecture_order(sandpipers) == 4, lecture_order(terns) == 5)) ::: (A)\nis_valid(And(lecture_order(petrels) == 1, lecture_order(sandpipers) == 2, lecture_order(oystercatchers) == 3, lecture_order(terns) == 4, lecture_order(rails) == 5)) ::: (B)\nis_valid(And(lecture_order(rails) == 1, lecture_order(sandpipers) == 2, lecture_order(terns) == 3, lecture_order(petrels) == 4, lecture_order(oystercatchers) == 5)) ::: (C)\nis_valid(And(lecture_order(sandpipers) == 1, lecture_order(terns) == 2, lecture_order(oystercatchers) == 3, lecture_order(rails) == 4, lecture_order(petrels) == 5)) ::: (D)\nis_valid(And(lecture_order(terns) == 1, lecture_order(petrels) == 2, lecture_order(sandpipers) == 3, lecture_order(oystercatchers) == 4, lecture_order(rails) == 5)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201310_3-G_4_20",
    "context": "A naturalist will give five lectures, each on a different type of bird: oystercatchers, petrels, rails, sandpipers, or terns. The lectures must be given in either Gladwyn Hall or Howard Auditorium, in an order that meets the following conditions: The first lecture is in Gladwyn Hall. The fourth lecture is in Howard Auditorium. Exactly three of the lectures are in Gladwyn Hall. The lecture on sandpipers is in Howard Auditorium and is given earlier than the lecture on oystercatchers. The lecture on terns is given earlier than the lecture on petrels, which is in Gladwyn Hall.",
    "question": "Which one of the following must be false?",
    "answer": "B",
    "options": [
      "A) The first and second lectures are both in Gladwyn Hall.",
      "B) The second and third lectures are both in Howard Auditorium.",
      "C) The second and fifth lectures are both in Gladwyn Hall.",
      "D) The third and fourth lectures are both in Howard Auditorium.",
      "E) The third and fifth lectures are both in Gladwyn Hall"
    ],
    "raw_logic_programs": [
      "# Declarations\nbirds = EnumSort([oystercatchers, petrels, rails, sandpipers, terns])\nhalls = EnumSort([Gladwyn_Hall, Howard_Auditorium])\nlecture = Function([birds] -> [halls])\norder = Function([birds] -> [int])\nForAll([b:birds], And(1 <= order(b), order(b) <= 5))\n\n# Constraints\nlecture(oystercatchers) == Gladwyn_Hall ::: The first lecture is in Gladwyn Hall\nlecture(sandpipers) == Howard_Auditorium ::: The lecture on sandpipers is in Howard Auditorium\nlecture(petrels) == Gladwyn_Hall ::: The lecture on petrels is in Gladwyn Hall\nCount([b:birds], lecture(b) == Gladwyn_Hall) == 3 ::: Exactly three of the lectures are in Gladwyn Hall\norder(sandpipers) < order(oystercatchers) ::: The lecture on sandpipers is given earlier than the lecture on oystercatchers\norder(terns) < order(petrels) ::: The lecture on terns is given earlier than the lecture on petrels\nlecture(rails) == Howard_Auditorium ::: The fourth lecture is in Howard Auditorium\n\n# Options\nQuestion ::: Which one of the following must be false?\nis_unsat(And(lecture(oystercatchers) == Gladwyn_Hall, lecture(petrels) == Gladwyn_Hall)) ::: (A)\nis_unsat(And(lecture(petrels) == Howard_Auditorium, lecture(rails) == Howard_Auditorium)) ::: (B)\nis_unsat(And(lecture(petrels) == Gladwyn_Hall, lecture(terns) == Gladwyn_Hall)) ::: (C)\nis_unsat(And(lecture(rails) == Howard_Auditorium, lecture(sandpipers) == Howard_Auditorium)) ::: (D)\nis_unsat(And(lecture(rails) == Gladwyn_Hall, lecture(terns) == Gladwyn_Hall)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201310_3-G_4_21",
    "context": "A naturalist will give five lectures, each on a different type of bird: oystercatchers, petrels, rails, sandpipers, or terns. The lectures must be given in either Gladwyn Hall or Howard Auditorium, in an order that meets the following conditions: The first lecture is in Gladwyn Hall. The fourth lecture is in Howard Auditorium. Exactly three of the lectures are in Gladwyn Hall. The lecture on sandpipers is in Howard Auditorium and is given earlier than the lecture on oystercatchers. The lecture on terns is given earlier than the lecture on petrels, which is in Gladwyn Hall.",
    "question": "If the lecture on terns is given in Howard Auditorium, which one of the following could be true of the third lecture?",
    "answer": "A",
    "options": [
      "A) It is on oystercatchers and is in Gladwyn Hall.",
      "B) It is on rails and is in Howard Auditorium.",
      "C) It is on rails and is in Gladwyn Hall.",
      "D) It is on sandpipers and is in Howard Auditorium.",
      "E) It is on terns and is in Howard Auditorium."
    ],
    "raw_logic_programs": [
      "# Declarations\nbirds = EnumSort([oystercatchers, petrels, rails, sandpipers, terns])\nhalls = EnumSort([Gladwyn_Hall, Howard_Auditorium])\nlecture = Function([birds] -> [halls])\norder = Function([birds] -> [int])\nForAll([b:birds], And(1 <= order(b), order(b) <= 5))\n\n# Constraints\nlecture(oystercatchers) != lecture(petrels) ::: each lecture is on a different type of bird\nlecture(oystercatchers) != lecture(rails) ::: each lecture is on a different type of bird\nlecture(oystercatchers) != lecture(sandpipers) ::: each lecture is on a different type of bird\nlecture(oystercatchers) != lecture(terns) ::: each lecture is on a different type of bird\nlecture(petrels) != lecture(rails) ::: each lecture is on a different type of bird\nlecture(petrels) != lecture(sandpipers) ::: each lecture is on a different type of bird\nlecture(petrels) != lecture(terns) ::: each lecture is on a different type of bird\nlecture(rails) != lecture(sandpipers) ::: each lecture is on a different type of bird\nlecture(rails) != lecture(terns) ::: each lecture is on a different type of bird\nlecture(sandpipers) != lecture(terns) ::: each lecture is on a different type of bird\nlecture(oystercatchers) == Gladwyn_Hall ::: The first lecture is in Gladwyn Hall\nlecture(sandpipers) == Howard_Auditorium ::: The lecture on sandpipers is in Howard Auditorium\nCount([b:birds], lecture(b) == Gladwyn_Hall) == 3 ::: Exactly three of the lectures are in Gladwyn Hall\nlecture(petrels) == Gladwyn_Hall ::: The lecture on petrels is in Gladwyn Hall\norder(sandpipers) < order(oystercatchers) ::: The lecture on sandpipers is given earlier than the lecture on oystercatchers\norder(terns) < order(petrels) ::: The lecture on terns is given earlier than the lecture on petrels\nlecture(terns) == Howard_Auditorium ::: If the lecture on terns is given in Howard Auditorium\n\n# Options\nQuestion ::: If the lecture on terns is given in Howard Auditorium, which one of the following could be true of the third lecture?\nis_sat(And(lecture(oystercatchers) == Gladwyn_Hall, order(oystercatchers) == 3)) ::: (A)\nis_sat(And(lecture(rails) == Howard_Auditorium, order(rails) == 3)) ::: (B)\nis_sat(And(lecture(rails) == Gladwyn_Hall, order(rails) == 3)) ::: (C)\nis_sat(And(lecture(sandpipers) == Howard_Auditorium, order(sandpipers) == 3)) ::: (D)\nis_sat(And(lecture(terns) == Howard_Auditorium, order(terns) == 3)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201310_3-G_4_22",
    "context": "A naturalist will give five lectures, each on a different type of bird: oystercatchers, petrels, rails, sandpipers, or terns. The lectures must be given in either Gladwyn Hall or Howard Auditorium, in an order that meets the following conditions: The first lecture is in Gladwyn Hall. The fourth lecture is in Howard Auditorium. Exactly three of the lectures are in Gladwyn Hall. The lecture on sandpipers is in Howard Auditorium and is given earlier than the lecture on oystercatchers. The lecture on terns is given earlier than the lecture on petrels, which is in Gladwyn Hall.",
    "question": "Which one of the following could be true of the fifth lecture?",
    "answer": "A",
    "options": [
      "A) It is on oystercatchers and is in Gladwyn Hall.",
      "B) It is on petrels and is in Howard Auditorium.",
      "C) It is on rails and is in Howard Auditorium.",
      "D) It is on sandpipers and is in Howard Auditorium.",
      "E) It is on terns and is in Gladwyn Hall."
    ],
    "raw_logic_programs": [
      "# Declarations\nbirds = EnumSort([oystercatchers, petrels, rails, sandpipers, terns])\nhalls = EnumSort([Gladwyn_Hall, Howard_Auditorium])\nlecture = Function([birds] -> [halls])\norder = Function([birds] -> [int])\nForAll([b:birds], And(1 <= order(b), order(b) <= 5))\n\n# Constraints\nlecture(oystercatchers) == Gladwyn_Hall ::: The first lecture is in Gladwyn Hall\nlecture(sandpipers) == Howard_Auditorium ::: The fourth lecture is in Howard Auditorium\nCount([b:birds], lecture(b) == Gladwyn_Hall) == 3 ::: Exactly three of the lectures are in Gladwyn Hall\nAnd(order(sandpipers) < order(oystercatchers), lecture(sandpipers) == Howard_Auditorium) ::: The lecture on sandpipers is in Howard Auditorium and is given earlier than the lecture on oystercatchers\nAnd(order(terns) < order(petrels), lecture(petrels) == Gladwyn_Hall) ::: The lecture on terns is given earlier than the lecture on petrels, which is in Gladwyn Hall\n\n# Options\nQuestion ::: Which one of the following could be true of the fifth lecture?\nis_sat(And(order(oystercatchers) == 5, lecture(oystercatchers) == Gladwyn_Hall)) ::: (A)\nis_sat(And(order(petrels) == 5, lecture(petrels) == Howard_Auditorium)) ::: (B)\nis_sat(And(order(rails) == 5, lecture(rails) == Howard_Auditorium)) ::: (C)\nis_sat(And(order(sandpipers) == 5, lecture(sandpipers) == Howard_Auditorium)) ::: (D)\nis_sat(And(order(terns) == 5, lecture(terns) == Gladwyn_Hall)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201310_3-G_4_23",
    "context": "A naturalist will give five lectures, each on a different type of bird: oystercatchers, petrels, rails, sandpipers, or terns. The lectures must be given in either Gladwyn Hall or Howard Auditorium, in an order that meets the following conditions: The first lecture is in Gladwyn Hall. The fourth lecture is in Howard Auditorium. Exactly three of the lectures are in Gladwyn Hall. The lecture on sandpipers is in Howard Auditorium and is given earlier than the lecture on oystercatchers. The lecture on terns is given earlier than the lecture on petrels, which is in Gladwyn Hall.",
    "question": "If the third lecture is on sandpipers, which one of the following could be true?",
    "answer": "D",
    "options": [
      "A) The second lecture is on oystercatchers and is in Gladwyn Hall.",
      "B) The fifth lecture is on oystercatchers and is in Howard Auditorium.",
      "C) The second lecture is on rails and is in Howard Auditorium.",
      "D) The second lecture is on terns and is in Gladwyn Hall.",
      "E) The fourth lecture is on terns and is in Howard Auditorium."
    ],
    "raw_logic_programs": [
      "# Declarations\nbirds = EnumSort([oystercatchers, petrels, rails, sandpipers, terns])\nlocations = EnumSort([Gladwyn_Hall, Howard_Auditorium])\nlecture = Function([int] -> [birds])\nlocation = Function([int] -> [locations])\n\n# Constraints\nlocation(1) == Gladwyn_Hall ::: The first lecture is in Gladwyn Hall\nlocation(4) == Howard_Auditorium ::: The fourth lecture is in Howard Auditorium\nCount([i:int], location(i) == Gladwyn_Hall) == 3 ::: Exactly three of the lectures are in Gladwyn Hall\nAnd(location(i_sandpipers) == Howard_Auditorium, i_sandpipers < i_oystercatchers) ::: The lecture on sandpipers is in Howard Auditorium and is given earlier than the lecture on oystercatchers\nAnd(i_terns < i_petrels, location(i_petrels) == Gladwyn_Hall) ::: The lecture on terns is given earlier than the lecture on petrels, which is in Gladwyn Hall\nlecture(3) == sandpipers ::: If the third lecture is on sandpipers\n\n# Options\nQuestion ::: Which one of the following could be true?\nis_sat(And(lecture(2) == oystercatchers, location(2) == Gladwyn_Hall)) ::: (A)\nis_sat(And(lecture(5) == oystercatchers, location(5) == Howard_Auditorium)) ::: (B)\nis_sat(And(lecture(2) == rails, location(2) == Howard_Auditorium)) ::: (C)\nis_sat(And(lecture(2) == terns, location(2) == Gladwyn_Hall)) ::: (D)\nis_sat(And(lecture(4) == terns, location(4) == Howard_Auditorium)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201412_2-G_1_1",
    "context": "A concert is given by a six-member band—guitarist, keyboard player, percussionist, saxophonist, trumpeter, violinist. During the concert, each member performs exactly one solo. The following restrictions apply: The guitarist does not perform the fourth solo. The percussionist performs a solo at some time before the keyboard player does. The keyboard player performs a solo at some time after the violinist does and at some time before the guitarist does. The saxophonist performs a solo at some time after either the percussionist does or the trumpeter does, but not both.",
    "question": "Which one of the following is an acceptable ordering of solos from first to last?",
    "answer": "C",
    "options": [
      "A) violinist, percussionist, saxophonist, guitarist, trumpeter, keyboard player",
      "B) percussionist, violinist, keyboard player, trumpeter, saxophonist, guitarist",
      "C) violinist, trumpeter, saxophonist, percussionist, keyboard player, guitarist",
      "D) keyboard player, trumpeter, violinist, saxophonist, guitarist, percussionist",
      "E) guitarist, violinist, keyboard player, percussionist, saxophonist, trumpeter"
    ],
    "raw_logic_programs": [
      "# Declarations\nmembers = EnumSort([guitarist, keyboard_player, percussionist, saxophonist, trumpeter, violinist])\nsolo_order = Function([members] -> [int])\nForAll([m:members], And(1 <= solo_order(m), solo_order(m) <= 6))\n\n# Constraints\nDistinct([m:members], solo_order(m)) ::: each member performs exactly one solo\nsolo_order(guitarist) != 4 ::: The guitarist does not perform the fourth solo\nsolo_order(percussionist) < solo_order(keyboard_player) ::: The percussionist performs a solo at some time before the keyboard player does\nAnd(solo_order(keyboard_player) > solo_order(violinist), solo_order(keyboard_player) < solo_order(guitarist)) ::: The keyboard player performs a solo at some time after the violinist does and at some time before the guitarist does\nOr(And(solo_order(saxophonist) > solo_order(percussionist), solo_order(saxophonist) <= solo_order(trumpeter)), And(solo_order(saxophonist) > solo_order(trumpeter), solo_order(saxophonist) <= solo_order(percussionist))) ::: The saxophonist performs a solo at some time after either the percussionist does or the trumpeter does, but not both\n\n# Options\nQuestion ::: Which one of the following is an acceptable ordering of solos from first to last?\nis_valid(And(solo_order(violinist) == 1, solo_order(percussionist) == 2, solo_order(saxophonist) == 3, solo_order(guitarist) == 4, solo_order(trumpeter) == 5, solo_order(keyboard_player) == 6)) ::: (A)\nis_valid(And(solo_order(percussionist) == 1, solo_order(violinist) == 2, solo_order(keyboard_player) == 3, solo_order(trumpeter) == 4, solo_order(saxophonist) == 5, solo_order(guitarist) == 6)) ::: (B)\nis_valid(And(solo_order(violinist) == 1, solo_order(trumpeter) == 2, solo_order(saxophonist) == 3, solo_order(percussionist) == 4, solo_order(keyboard_player) == 5, solo_order(guitarist) == 6)) ::: (C)\nis_valid(And(solo_order(keyboard_player) == 1, solo_order(trumpeter) == 2, solo_order(violinist) == 3, solo_order(saxophonist) == 4, solo_order(guitarist) == 5, solo_order(percussionist) == 6)) ::: (D)\nis_valid(And(solo_order(guitarist) == 1, solo_order(violinist) == 2, solo_order(keyboard_player) == 3, solo_order(percussionist) == 4, solo_order(saxophonist) == 5, solo_order(trumpeter) == 6)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201412_2-G_1_2",
    "context": "A concert is given by a six-member band—guitarist, keyboard player, percussionist, saxophonist, trumpeter, violinist. During the concert, each member performs exactly one solo. The following restrictions apply: The guitarist does not perform the fourth solo. The percussionist performs a solo at some time before the keyboard player does. The keyboard player performs a solo at some time after the violinist does and at some time before the guitarist does. The saxophonist performs a solo at some time after either the percussionist does or the trumpeter does, but not both.",
    "question": "If the percussionist performs a solo at some time before the saxophonist does, then which one of the following must be true?",
    "answer": "D",
    "options": [
      "A) The percussionist performs the first solo.",
      "B) The percussionist performs the second solo.",
      "C) The violinist performs a solo at some time before the saxophonist does.",
      "D) The percussionist performs a solo at some time before the trumpeter does.",
      "E) The saxophonist performs a solo at some time before the keyboard player does."
    ],
    "raw_logic_programs": [
      "# Declarations\nmembers = EnumSort([guitarist, keyboard_player, percussionist, saxophonist, trumpeter, violinist])\nsolo_order = Function([members] -> [int])\nForAll([m:members], And(1 <= solo_order(m), solo_order(m) <= 6))\n\n# Constraints\nsolo_order(guitarist) != 4 ::: The guitarist does not perform the fourth solo\nsolo_order(percussionist) < solo_order(keyboard_player) ::: The percussionist performs a solo at some time before the keyboard player does\nAnd(solo_order(keyboard_player) > solo_order(violinist), solo_order(keyboard_player) < solo_order(guitarist)) ::: The keyboard player performs a solo at some time after the violinist does and at some time before the guitarist does\nOr(And(solo_order(saxophonist) > solo_order(percussionist), solo_order(saxophonist) <= solo_order(trumpeter)), And(solo_order(saxophonist) > solo_order(trumpeter), solo_order(saxophonist) <= solo_order(percussionist))) ::: The saxophonist performs a solo at some time after either the percussionist does or the trumpeter does, but not both\n\n# Options\nQuestion ::: If the percussionist performs a solo at some time before the saxophonist does, then which one of the following must be true?\nis_valid(Implies(solo_order(percussionist) < solo_order(saxophonist), solo_order(percussionist) == 1)) ::: (A)\nis_valid(Implies(solo_order(percussionist) < solo_order(saxophonist), solo_order(percussionist) == 2)) ::: (B)\nis_valid(Implies(solo_order(percussionist) < solo_order(saxophonist), solo_order(violinist) < solo_order(saxophonist))) ::: (C)\nis_valid(Implies(solo_order(percussionist) < solo_order(saxophonist), solo_order(percussionist) < solo_order(trumpeter))) ::: (D)\nis_valid(Implies(solo_order(percussionist) < solo_order(saxophonist), solo_order(saxophonist) < solo_order(keyboard_player))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201412_2-G_1_3",
    "context": "A concert is given by a six-member band—guitarist, keyboard player, percussionist, saxophonist, trumpeter, violinist. During the concert, each member performs exactly one solo. The following restrictions apply: The guitarist does not perform the fourth solo. The percussionist performs a solo at some time before the keyboard player does. The keyboard player performs a solo at some time after the violinist does and at some time before the guitarist does. The saxophonist performs a solo at some time after either the percussionist does or the trumpeter does, but not both.",
    "question": "Each of the following must be false EXCEPT:",
    "answer": "E",
    "options": [
      "A) The keyboard player performs the first solo.",
      "B) The guitarist performs the second solo.",
      "C) The guitarist performs a solo at some time before the saxophonist does.",
      "D) The guitarist performs a solo at some time before the percussionist does.",
      "E) The keyboard player performs a solo at some time before the saxophonist does."
    ],
    "raw_logic_programs": [
      "# Declarations\nband_members = EnumSort([guitarist, keyboard_player, percussionist, saxophonist, trumpeter, violinist])\nsolo_order = Function([band_members] -> [int])\nForAll([b:band_members], And(1 <= solo_order(b), solo_order(b) <= 6))\n\n# Constraints\nsolo_order(guitarist) != 4 ::: The guitarist does not perform the fourth solo\nsolo_order(percussionist) < solo_order(keyboard_player) ::: The percussionist performs a solo at some time before the keyboard player does\nAnd(solo_order(violinist) < solo_order(keyboard_player), solo_order(keyboard_player) < solo_order(guitarist)) ::: The keyboard player performs a solo at some time after the violinist does and at some time before the guitarist does\nOr(And(solo_order(percussionist) < solo_order(saxophonist), solo_order(trumpeter) >= solo_order(saxophonist)), And(solo_order(trumpeter) < solo_order(saxophonist), solo_order(percussionist) >= solo_order(saxophonist))) ::: The saxophonist performs a solo at some time after either the percussionist does or the trumpeter does, but not both\n\n# Options\nQuestion ::: Each of the following must be false EXCEPT:\nis_exception(is_unsat(solo_order(keyboard_player) == 1)) ::: (A)\nis_exception(is_unsat(solo_order(guitarist) == 2)) ::: (B)\nis_exception(is_unsat(solo_order(guitarist) < solo_order(saxophonist))) ::: (C)\nis_exception(is_unsat(solo_order(guitarist) < solo_order(percussionist))) ::: (D)\nis_exception(is_unsat(solo_order(keyboard_player) < solo_order(saxophonist))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201412_2-G_1_4",
    "context": "A concert is given by a six-member band—guitarist, keyboard player, percussionist, saxophonist, trumpeter, violinist. During the concert, each member performs exactly one solo. The following restrictions apply: The guitarist does not perform the fourth solo. The percussionist performs a solo at some time before the keyboard player does. The keyboard player performs a solo at some time after the violinist does and at some time before the guitarist does. The saxophonist performs a solo at some time after either the percussionist does or the trumpeter does, but not both.",
    "question": "Which one of the following CANNOT perform the third",
    "answer": "A",
    "options": [
      "A) guitarist",
      "B) keyboard player",
      "C) saxophonist",
      "D) trumpeter",
      "E) violinist"
    ],
    "raw_logic_programs": [
      "# Declarations\nmembers = EnumSort([guitarist, keyboard_player, percussionist, saxophonist, trumpeter, violinist])\nsolo_order = Function([members] -> [int])\nForAll([m:members], And(1 <= solo_order(m), solo_order(m) <= 6))\n\n# Constraints\nsolo_order(guitarist) != 4 ::: The guitarist does not perform the fourth solo\nsolo_order(percussionist) < solo_order(keyboard_player) ::: The percussionist performs a solo at some time before the keyboard player does\nAnd(solo_order(violinist) < solo_order(keyboard_player), solo_order(keyboard_player) < solo_order(guitarist)) ::: The keyboard player performs a solo at some time after the violinist does and at some time before the guitarist does\nOr(solo_order(saxophonist) > solo_order(percussionist), solo_order(saxophonist) > solo_order(trumpeter)) ::: The saxophonist performs a solo at some time after either the percussionist does or the trumpeter does\nNot(And(solo_order(saxophonist) > solo_order(percussionist), solo_order(saxophonist) > solo_order(trumpeter))) ::: but not both\n\n# Options\nQuestion ::: Which one of the following CANNOT perform the third solo?\nis_unsat(solo_order(guitarist) == 3) ::: (A)\nis_unsat(solo_order(keyboard_player) == 3) ::: (B)\nis_unsat(solo_order(saxophonist) == 3) ::: (C)\nis_unsat(solo_order(trumpeter) == 3) ::: (D)\nis_unsat(solo_order(violinist) == 3) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201412_2-G_1_5",
    "context": "A concert is given by a six-member band—guitarist, keyboard player, percussionist, saxophonist, trumpeter, violinist. During the concert, each member performs exactly one solo. The following restrictions apply: The guitarist does not perform the fourth solo. The percussionist performs a solo at some time before the keyboard player does. The keyboard player performs a solo at some time after the violinist does and at some time before the guitarist does. The saxophonist performs a solo at some time after either the percussionist does or the trumpeter does, but not both.",
    "question": "If the violinist performs the fourth solo, then each of the following must be true EXCEPT:",
    "answer": "E",
    "options": [
      "A) The percussionist performs a solo at some time before the violinist does.",
      "B) The trumpeter performs a solo at some time before the violinist does.",
      "C) The trumpeter performs a solo at some time before the guitarist does.",
      "D) The saxophonist performs a solo at some time before the violinist does.",
      "E) The trumpeter performs a solo at some time before the saxophonist does."
    ],
    "raw_logic_programs": [
      "# Declarations\nband_members = EnumSort([guitarist, keyboard_player, percussionist, saxophonist, trumpeter, violinist])\nsolo_order = Function([band_members] -> [int])\nForAll([m:band_members], And(1 <= solo_order(m), solo_order(m) <= 6))\n\n# Constraints\nsolo_order(guitarist) != 4 ::: The guitarist does not perform the fourth solo\nsolo_order(percussionist) < solo_order(keyboard_player) ::: The percussionist performs a solo at some time before the keyboard player does\nAnd(solo_order(keyboard_player) > solo_order(violinist), solo_order(keyboard_player) < solo_order(guitarist)) ::: The keyboard player performs a solo at some time after the violinist does and at some time before the guitarist does\nOr(And(solo_order(saxophonist) > solo_order(percussionist), solo_order(saxophonist) <= solo_order(trumpeter)), And(solo_order(saxophonist) > solo_order(trumpeter), solo_order(saxophonist) <= solo_order(percussionist))) ::: The saxophonist performs a solo at some time after either the percussionist does or the trumpeter does, but not both\nsolo_order(violinist) == 4 ::: If the violinist performs the fourth solo\n\n# Options\nQuestion ::: If the violinist performs the fourth solo, then each of the following must be true EXCEPT:\nis_unsat(solo_order(percussionist) < solo_order(violinist)) ::: (A)\nis_unsat(solo_order(trumpeter) < solo_order(violinist)) ::: (B)\nis_unsat(solo_order(trumpeter) < solo_order(guitarist)) ::: (C)\nis_unsat(solo_order(saxophonist) < solo_order(violinist)) ::: (D)\nis_unsat(solo_order(trumpeter) < solo_order(saxophonist)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201412_2-G_2_6",
    "context": "Four art historians—Farley, Garcia, Holden, and Jiang—will give a series of four public lectures, each lecture on a different topic—lithographs, oil paintings, sculptures, and watercolors. The lectures will be given one at a time, with each art historian giving a lecture on a different one of the topics. The schedule of the lectures is subject to the following constraints: The oil paintings lecture and the watercolors lecture must both be earlier than the lithographs lecture. Farley's lecture must be earlier than the oil paintings lecture. Holden's lecture must be earlier than both Garcia's lecture and Jiang's lecture.",
    "question": "Which one of the following is an acceptable ordering of the lectures, from first to fourth?",
    "answer": "E",
    "options": [
      "A) Farley: sculptures; Holden: lithographs; Garcia: oil paintings; Jiang: watercolors",
      "B) Farley: watercolors; Jiang: oil paintings; Holden: sculptures; Garcia: lithographs",
      "C) Garcia: sculptures; Farley: watercolors; Holden: oil paintings; Jiang: lithographs",
      "D) Holden: oil paintings; Jiang: watercolors; Farley: lithographs; Garcia: sculptures",
      "E) Holden: sculptures; Farley: watercolors; Jiang: oil paintings; Garcia: lithographs"
    ],
    "raw_logic_programs": [
      "# Declarations\nart_historians = EnumSort([Farley, Garcia, Holden, Jiang])\ntopics = EnumSort([lithographs, oil_paintings, sculptures, watercolors])\ngives_lecture = Function([art_historians, topics] -> [int])\nForAll([h:art_historians], And(1 <= gives_lecture(h, topics), gives_lecture(h, topics) <= 4))\n\n# Constraints\nAnd(gives_lecture(art_historians, oil_paintings) < gives_lecture(art_historians, lithographs), gives_lecture(art_historians, watercolors) < gives_lecture(art_historians, lithographs)) ::: The oil paintings lecture and the watercolors lecture must both be earlier than the lithographs lecture\ngives_lecture(Farley, topics) < gives_lecture(art_historians, oil_paintings) ::: Farley's lecture must be earlier than the oil paintings lecture\nAnd(gives_lecture(Holden, topics) < gives_lecture(Garcia, topics), gives_lecture(Holden, topics) < gives_lecture(Jiang, topics)) ::: Holden's lecture must be earlier than both Garcia's lecture and Jiang's lecture\n\n# Options\nQuestion ::: Which one of the following is an acceptable ordering of the lectures, from first to fourth?\nis_valid(And(gives_lecture(Farley, sculptures) == 1, gives_lecture(Holden, lithographs) == 2, gives_lecture(Garcia, oil_paintings) == 3, gives_lecture(Jiang, watercolors) == 4)) ::: (A)\nis_valid(And(gives_lecture(Farley, watercolors) == 1, gives_lecture(Jiang, oil_paintings) == 2, gives_lecture(Holden, sculptures) == 3, gives_lecture(Garcia, lithographs) == 4)) ::: (B)\nis_valid(And(gives_lecture(Garcia, sculptures) == 1, gives_lecture(Farley, watercolors) == 2, gives_lecture(Holden, oil_paintings) == 3, gives_lecture(Jiang, lithographs) == 4)) ::: (C)\nis_valid(And(gives_lecture(Holden, oil_paintings) == 1, gives_lecture(Jiang, watercolors) == 2, gives_lecture(Farley, lithographs) == 3, gives_lecture(Garcia, sculptures) == 4)) ::: (D)\nis_valid(And(gives_lecture(Holden, sculptures) == 1, gives_lecture(Farley, watercolors) == 2, gives_lecture(Jiang, oil_paintings) == 3, gives_lecture(Garcia, lithographs) == 4)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201412_2-G_2_7",
    "context": "Four art historians—Farley, Garcia, Holden, and Jiang—will give a series of four public lectures, each lecture on a different topic—lithographs, oil paintings, sculptures, and watercolors. The lectures will be given one at a time, with each art historian giving a lecture on a different one of the topics. The schedule of the lectures is subject to the following constraints: The oil paintings lecture and the watercolors lecture must both be earlier than the lithographs lecture. Farley's lecture must be earlier than the oil paintings lecture. Holden's lecture must be earlier than both Garcia's lecture and Jiang's lecture.",
    "question": "Which one of the following must be true?",
    "answer": "B",
    "options": [
      "A) Farley's lecture is earlier than the sculptures lecture.",
      "B) Holden's lecture is earlier than the lithographs lecture.",
      "C) The sculptures lecture is earlier than Garcia's lecture.",
      "D) The sculptures lecture is earlier than Jiang's lecture.",
      "E) The watercolors lecture is earlier than Garcia's lecture."
    ],
    "raw_logic_programs": [
      "# Declarations\nart_historians = EnumSort([Farley, Garcia, Holden, Jiang])\ntopics = EnumSort([lithographs, oil_paintings, sculptures, watercolors])\ngives_lecture = Function([art_historians, topics] -> [int])\nForAll([h:art_historians], Exists([t:topics], gives_lecture(h, t) == 1))\nForAll([t:topics], Exists([h:art_historians], gives_lecture(h, t) == 1))\n\n# Constraints\nAnd(gives_lecture(Farley, oil_paintings) < gives_lecture(Farley, lithographs), gives_lecture(Farley, watercolors) < gives_lecture(Farley, lithographs)) ::: The oil paintings lecture and the watercolors lecture must both be earlier than the lithographs lecture\ngives_lecture(Farley, oil_paintings) > gives_lecture(Farley, Farley) ::: Farley's lecture must be earlier than the oil paintings lecture\nAnd(gives_lecture(Holden, Holden) < gives_lecture(Holden, Garcia), gives_lecture(Holden, Holden) < gives_lecture(Holden, Jiang)) ::: Holden's lecture must be earlier than both Garcia's lecture and Jiang's lecture\n\n# Options\nQuestion ::: Which one of the following must be true?\nis_valid(gives_lecture(Farley, sculptures) > gives_lecture(Farley, Farley)) ::: (A)\nis_valid(gives_lecture(Holden, lithographs) > gives_lecture(Holden, Holden)) ::: (B)\nis_valid(gives_lecture(Garcia, sculptures) > gives_lecture(Garcia, Garcia)) ::: (C)\nis_valid(gives_lecture(Jiang, sculptures) > gives_lecture(Jiang, Jiang)) ::: (D)\nis_valid(gives_lecture(Garcia, watercolors) > gives_lecture(Garcia, Garcia)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201412_2-G_2_8",
    "context": "Four art historians—Farley, Garcia, Holden, and Jiang—will give a series of four public lectures, each lecture on a different topic—lithographs, oil paintings, sculptures, and watercolors. The lectures will be given one at a time, with each art historian giving a lecture on a different one of the topics. The schedule of the lectures is subject to the following constraints: The oil paintings lecture and the watercolors lecture must both be earlier than the lithographs lecture. Farley's lecture must be earlier than the oil paintings lecture. Holden's lecture must be earlier than both Garcia's lecture and Jiang's lecture.",
    "question": "If the watercolors lecture is third, which one of the following could be true?",
    "answer": "E",
    "options": [
      "A) Farley gives the watercolors lecture.",
      "B) Garcia gives the oil paintings lecture.",
      "C) Garcia gives the sculptures lecture.",
      "D) Holden gives the sculptures lecture.",
      "E) Jiang gives the lithographs lecture."
    ],
    "raw_logic_programs": [
      "# Declarations\nart_historians = EnumSort([Farley, Garcia, Holden, Jiang])\ntopics = EnumSort([lithographs, oil_paintings, sculptures, watercolors])\ngives = Function([art_historians, topics] -> [int])\nForAll([h:art_historians, t:topics], And(1 <= gives(h, t), gives(h, t) <= 4))\n\n# Constraints\nAnd(gives(h, oil_paintings) < gives(h, lithographs), gives(h, watercolors) < gives(h, lithographs)) ::: The oil paintings lecture and the watercolors lecture must both be earlier than the lithographs lecture\ngives(Farley, oil_paintings) > gives(Farley, watercolors) ::: Farley's lecture must be earlier than the oil paintings lecture\nAnd(gives(Holden, oil_paintings) > gives(Holden, watercolors), gives(Holden, sculptures) > gives(Holden, watercolors)) ::: Holden's lecture must be earlier than both Garcia's lecture and Jiang's lecture\nForAll([h:art_historians], Count([t:topics], gives(h, t)) == 1) ::: each art historian giving a lecture on a different one of the topics\nExists([h:art_historians], gives(h, watercolors) == 3) ::: If the watercolors lecture is third\n\n# Options\nQuestion ::: If the watercolors lecture is third, which one of the following could be true?\nis_sat(gives(Farley, watercolors) == 3) ::: (A)\nis_sat(gives(Garcia, oil_paintings) == 3) ::: (B)\nis_sat(gives(Garcia, sculptures) == 3) ::: (C)\nis_sat(gives(Holden, sculptures) == 3) ::: (D)\nis_sat(gives(Jiang, lithographs) == 3) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201412_2-G_2_9",
    "context": "Four art historians—Farley, Garcia, Holden, and Jiang—will give a series of four public lectures, each lecture on a different topic—lithographs, oil paintings, sculptures, and watercolors. The lectures will be given one at a time, with each art historian giving a lecture on a different one of the topics. The schedule of the lectures is subject to the following constraints: The oil paintings lecture and the watercolors lecture must both be earlier than the lithographs lecture. Farley's lecture must be earlier than the oil paintings lecture. Holden's lecture must be earlier than both Garcia's lecture and Jiang's lecture.",
    "question": "Which one of the following CANNOT be true?",
    "answer": "A",
    "options": [
      "A) Farley gives the lithographs lecture.",
      "B) Garcia gives the sculptures lecture.",
      "C) Garcia gives the watercolors lecture.",
      "D) Holden gives the oil paintings lecture.",
      "E) Jiang gives the watercolors lecture."
    ],
    "raw_logic_programs": [
      "# Declarations\nart_historians = EnumSort([Farley, Garcia, Holden, Jiang])\ntopics = EnumSort([lithographs, oil_paintings, sculptures, watercolors])\ngives = Function([art_historians, topics] -> [bool])\n\n# Constraints\nForAll([h:art_historians], Exists([t:topics], gives(h, t))) ::: each art historian gives a lecture on a different one of the topics\nForAll([t:topics], Exists([h:art_historians], gives(h, t))) ::: each lecture is given by a different art historian\nAnd(gives(Farley, oil_paintings) == False, gives(Farley, watercolors) == False) ::: Farley's lecture must be earlier than the oil paintings lecture\nAnd(gives(Holden, oil_paintings) == False, gives(Holden, watercolors) == False) ::: Holden's lecture must be earlier than both Garcia's lecture and Jiang's lecture\nAnd(gives(Garcia, lithographs) == False, gives(Jiang, lithographs) == False) ::: The oil paintings lecture and the watercolors lecture must both be earlier than the lithographs lecture\n\n# Options\nQuestion ::: Which one of the following CANNOT be true?\nis_unsat(gives(Farley, lithographs)) ::: (A)\nis_unsat(gives(Garcia, sculptures)) ::: (B)\nis_unsat(gives(Garcia, watercolors)) ::: (C)\nis_unsat(gives(Holden, oil_paintings)) ::: (D)\nis_unsat(gives(Jiang, watercolors)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201412_2-G_2_10",
    "context": "Four art historians—Farley, Garcia, Holden, and Jiang—will give a series of four public lectures, each lecture on a different topic—lithographs, oil paintings, sculptures, and watercolors. The lectures will be given one at a time, with each art historian giving a lecture on a different one of the topics. The schedule of the lectures is subject to the following constraints: The oil paintings lecture and the watercolors lecture must both be earlier than the lithographs lecture. Farley's lecture must be earlier than the oil paintings lecture. Holden's lecture must be earlier than both Garcia's lecture and Jiang's lecture.",
    "question": "If Garcia gives the sculptures lecture, which one of the following could be true?",
    "answer": "A",
    "options": [
      "A) The lithographs lecture is third.",
      "B) The oil paintings lecture is third.",
      "C) The sculptures lecture is first.",
      "D) The sculptures lecture is second.",
      "E) The watercolors lecture is second."
    ],
    "raw_logic_programs": [
      "# Declarations\nart_historians = EnumSort([Farley, Garcia, Holden, Jiang])\ntopics = EnumSort([lithographs, oil_paintings, sculptures, watercolors])\ngives = Function([art_historians, topics] -> [int])\nForAll([h:art_historians], And(1 <= gives(h, topics), gives(h, topics) <= 4))\n\n# Constraints\nAnd(gives(art_historians, oil_paintings) < gives(art_historians, lithographs), gives(art_historians, watercolors) < gives(art_historians, lithographs)) ::: The oil paintings lecture and the watercolors lecture must both be earlier than the lithographs lecture\ngives(Farley, topics) < gives(art_historians, oil_paintings) ::: Farley's lecture must be earlier than the oil paintings lecture\nAnd(gives(Holden, topics) < gives(Garcia, topics), gives(Holden, topics) < gives(Jiang, topics)) ::: Holden's lecture must be earlier than both Garcia's lecture and Jiang's lecture\ngives(Garcia, sculptures) == 1 ::: If Garcia gives the sculptures lecture\n\n# Options\nQuestion ::: Which one of the following could be true?\nis_sat(gives(art_historians, lithographs) == 3) ::: (A)\nis_sat(gives(art_historians, oil_paintings) == 3) ::: (B)\nis_sat(gives(Garcia, sculptures) == 1) ::: (C)\nis_sat(gives(Garcia, sculptures) == 2) ::: (D)\nis_sat(gives(art_historians, watercolors) == 2) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201412_2-G_3_11",
    "context": "Three rugs will be woven out of colored thread. Six colors of thread are available—forest, olive, peach, turquoise, white, and yellow—exactly five of which will be used to weave the rugs. Each color that is used will be used in only one of the rugs. The rugs are either solid—woven in a single color—or multicolored. The rugs must be woven according to the following rules: In any rug in which white is used, two other colors are also used. In any rug in which olive is used, peach is also used. Forest and turquoise are not used together in a rug. Peach and turquoise are not used together in a rug. Peach and yellow are not used together in a rug.",
    "question": "Which one of the following could be the colors of the three rugs?",
    "answer": "A",
    "options": [
      "A) forest only; turquoise only; olive, peach, and white",
      "B) forest only; turquoise only; olive, peach, and yellow",
      "C) peach only; turquoise only; forest, olive, and white",
      "D) yellow only; forest and turquoise; olive and peach",
      "E) yellow only; olive and peach; turquoise and white"
    ],
    "raw_logic_programs": [
      "# Declarations\ncolors = EnumSort([forest, olive, peach, turquoise, white, yellow])\nrugs = EnumSort([rug1, rug2, rug3])\nused = Function([colors, rugs] -> [bool])\n\n# Constraints\nCount([c:colors], used(c, rug1) == True) + Count([c:colors], used(c, rug2) == True) + Count([c:colors], used(c, rug3) == True) == 5 ::: exactly five of which will be used to weave the rugs\nForAll([c:colors], Count([r:rugs], used(c, r) == True) <= 1) ::: Each color that is used will be used in only one of the rugs\nForAll([r:rugs], Implies(used(white, r) == True, And(Count([c:colors], used(c, r) == True) == 3, used(white, r) == True))) ::: In any rug in which white is used, two other colors are also used\nForAll([r:rugs], Implies(used(olive, r) == True, used(peach, r) == True)) ::: In any rug in which olive is used, peach is also used\nForAll([r:rugs], Not(And(used(forest, r) == True, used(turquoise, r) == True))) ::: Forest and turquoise are not used together in a rug\nForAll([r:rugs], Not(And(used(peach, r) == True, used(turquoise, r) == True))) ::: Peach and turquoise are not used together in a rug\nForAll([r:rugs], Not(And(used(peach, r) == True, used(yellow, r) == True))) ::: Peach and yellow are not used together in a rug\n\n# Options\nQuestion ::: Which one of the following could be the colors of the three rugs?\nis_sat(And(And(used(forest, rug1) == True, used(forest, rug2) == False, used(forest, rug3) == False), And(And(used(turquoise, rug1) == False, used(turquoise, rug2) == True, used(turquoise, rug3) == False), And(And(used(olive, rug1) == False, used(olive, rug2) == False, used(olive, rug3) == True), And(And(used(peach, rug1) == False, used(peach, rug2) == False, used(peach, rug3) == True), And(And(used(white, rug1) == False, used(white, rug2) == False, used(white, rug3) == True), And(And(used(yellow, rug1) == False, used(yellow, rug2) == False, used(yellow, rug3) == False)))))) ::: (A)\nis_sat(And(And(used(forest, rug1) == True, used(forest, rug2) == False, used(forest, rug3) == False), And(And(used(turquoise, rug1) == False, used(turquoise, rug2) == True, used(turquoise, rug3) == False), And(And(used(olive, rug1) == False, used(olive, rug2) == False, used(olive, rug3) == True), And(And(used(peach, rug1) == False, used(peach, rug2) == False, used(peach, rug3) == True), And(And(used(white, rug1) == False, used(white, rug2) == False, used(white, rug3) == False), And(And(used(yellow, rug1) == False, used(yellow, rug2) == False, used(yellow, rug3) == True)))))) ::: (B)\nis_sat(And(And(used(forest, rug1) == False, used(forest, rug2) == False, used(forest, rug3) == True), And(And(used(turquoise, rug1) == False, used(turquoise, rug2) == True, used(turquoise, rug3) == False), And(And(used(olive, rug1) == False, used(olive, rug2) == True, used(olive, rug3) == True), And(And(used(peach, rug1) == True, used(peach, rug2) == False, used(peach, rug3) == False), And(And(used(white, rug1) == True, used(white, rug2) == False, used(white, rug3) == False), And(And(used(yellow, rug1) == False, used("
    ]
  },
  {
    "id": "ar_lsat_201412_2-G_3_12",
    "context": "Three rugs will be woven out of colored thread. Six colors of thread are available—forest, olive, peach, turquoise, white, and yellow—exactly five of which will be used to weave the rugs. Each color that is used will be used in only one of the rugs. The rugs are either solid—woven in a single color—or multicolored. The rugs must be woven according to the following rules: In any rug in which white is used, two other colors are also used. In any rug in which olive is used, peach is also used. Forest and turquoise are not used together in a rug. Peach and turquoise are not used together in a rug. Peach and yellow are not used together in a rug.",
    "question": "Which one of the following must be true?",
    "answer": "C",
    "options": [
      "A) There are no multicolored rugs in which forest is used.",
      "B) There are no multicolored rugs in which turquoise is used.",
      "C) Peach is used in one of the rugs.",
      "D) Turquoise is used in one of the rugs.",
      "E) Yellow is used in one of the rugs."
    ],
    "raw_logic_programs": [
      "# Declarations\ncolors = EnumSort([forest, olive, peach, turquoise, white, yellow])\nrugs = EnumSort([rug1, rug2, rug3])\nused = Function([colors, rugs] -> [bool])\n\n# Constraints\nCount([c:colors], used(c, rug1) or used(c, rug2) or used(c, rug3)) == 5 ::: exactly five of which will be used to weave the rugs\nForAll([c:colors], Count([r:rugs], used(c, r)) <= 1) ::: Each color that is used will be used in only one of the rugs\nForAll([r:rugs], Implies(used(white, r), And(Count([c:colors], used(c, r)) == 3, used(white, r)))) ::: In any rug in which white is used, two other colors are also used\nForAll([r:rugs], Implies(used(olive, r), used(peach, r))) ::: In any rug in which olive is used, peach is also used\nForAll([r:rugs], Not(And(used(forest, r), used(turquoise, r)))) ::: Forest and turquoise are not used together in a rug\nForAll([r:rugs], Not(And(used(peach, r), used(turquoise, r)))) ::: Peach and turquoise are not used together in a rug\nForAll([r:rugs], Not(And(used(peach, r), used(yellow, r)))) ::: Peach and yellow are not used together in a rug\n\n# Options\nQuestion ::: Which one of the following must be true?\nis_valid(ForAll([r:rugs], Implies(used(forest, r), Count([c:colors], used(c, r)) == 1))) ::: (A)\nis_valid(ForAll([r:rugs], Implies(used(turquoise, r), Count([c:colors], used(c, r)) == 1))) ::: (B)\nis_valid(Exists([r:rugs], used(peach, r))) ::: (C)\nis_valid(Exists([r:rugs], used(turquoise, r))) ::: (D)\nis_valid(Exists([r:rugs], used(yellow, r))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201412_2-G_3_13",
    "context": "Three rugs will be woven out of colored thread. Six colors of thread are available—forest, olive, peach, turquoise, white, and yellow—exactly five of which will be used to weave the rugs. Each color that is used will be used in only one of the rugs. The rugs are either solid—woven in a single color—or multicolored. The rugs must be woven according to the following rules: In any rug in which white is used, two other colors are also used. In any rug in which olive is used, peach is also used. Forest and turquoise are not used together in a rug. Peach and turquoise are not used together in a rug. Peach and yellow are not used together in a rug.",
    "question": "If one of the rugs is solid peach, which one of the following must be true?",
    "answer": "E",
    "options": [
      "A) One of the rugs is solid forest.",
      "B) One of the rugs is solid turquoise.",
      "C) One of the rugs is solid yellow.",
      "D) Forest and white are used together in a rug.",
      "E) White and yellow are used together in a rug."
    ],
    "raw_logic_programs": [
      "# Declarations\ncolors = EnumSort([forest, olive, peach, turquoise, white, yellow])\nrugs = EnumSort([rug1, rug2, rug3])\nused = Function([colors, rugs] -> [bool])\n\n# Constraints\nCount([c:colors], used(c, rug1) or used(c, rug2) or used(c, rug3)) == 5 ::: exactly five of which will be used to weave the rugs\nForAll([c:colors], Count([r:rugs], used(c, r)) <= 1) ::: Each color that is used will be used in only one of the rugs\nForAll([r:rugs], Implies(used(white, r), And(Count([c:colors], used(c, r)) == 3, used(white, r)))) ::: In any rug in which white is used, two other colors are also used\nForAll([r:rugs], Implies(used(olive, r), used(peach, r))) ::: In any rug in which olive is used, peach is also used\nForAll([r:rugs], Not(And(used(forest, r), used(turquoise, r)))) ::: Forest and turquoise are not used together in a rug\nForAll([r:rugs], Not(And(used(peach, r), used(turquoise, r)))) ::: Peach and turquoise are not used together in a rug\nForAll([r:rugs], Not(And(used(peach, r), used(yellow, r)))) ::: Peach and yellow are not used together in a rug\nExists([r:rugs], And(used(peach, r), Count([c:colors], used(c, r)) == 1)) ::: If one of the rugs is solid peach\n\n# Options\nQuestion ::: If one of the rugs is solid peach, which one of the following must be true?\nis_valid(Exists([r:rugs], And(used(forest, r), Count([c:colors], used(c, r)) == 1))) ::: (A)\nis_valid(Exists([r:rugs], And(used(turquoise, r), Count([c:colors], used(c, r)) == 1))) ::: (B)\nis_valid(Exists([r:rugs], And(used(yellow, r), Count([c:colors], used(c, r)) == 1))) ::: (C)\nis_valid(Exists([r:rugs], And(used(forest, r), used(white, r)))) ::: (D)\nis_valid(Exists([r:rugs], And(used(white, r), used(yellow, r)))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201412_2-G_3_14",
    "context": "Three rugs will be woven out of colored thread. Six colors of thread are available—forest, olive, peach, turquoise, white, and yellow—exactly five of which will be used to weave the rugs. Each color that is used will be used in only one of the rugs. The rugs are either solid—woven in a single color—or multicolored. The rugs must be woven according to the following rules: In any rug in which white is used, two other colors are also used. In any rug in which olive is used, peach is also used. Forest and turquoise are not used together in a rug. Peach and turquoise are not used together in a rug. Peach and yellow are not used together in a rug.",
    "question": "If there are exactly two solid rugs, then the colors of those two rugs CANNOT be",
    "answer": "D",
    "options": [
      "A) forest and peach",
      "B) forest and yellow",
      "C) peach and turquoise",
      "D) peach and yellow",
      "E) turquoise and yellow"
    ],
    "raw_logic_programs": [
      "# Declarations\ncolors = EnumSort([forest, olive, peach, turquoise, white, yellow])\nrugs = EnumSort([rug1, rug2, rug3])\nused = Function([colors, rugs] -> [bool])\n\n# Constraints\nCount([c:colors], used(c, rug1) or used(c, rug2) or used(c, rug3)) == 5 ::: exactly five of which will be used to weave the rugs\nForAll([c:colors], Count([r:rugs], used(c, r)) <= 1) ::: Each color that is used will be used in only one of the rugs\nForAll([r:rugs], Implies(used(white, r), And(Count([c:colors], used(c, r)) == 3, used(white, r)))) ::: In any rug in which white is used, two other colors are also used\nForAll([r:rugs], Implies(used(olive, r), used(peach, r))) ::: In any rug in which olive is used, peach is also used\nForAll([r:rugs], Not(And(used(forest, r), used(turquoise, r)))) ::: Forest and turquoise are not used together in a rug\nForAll([r:rugs], Not(And(used(peach, r), used(turquoise, r)))) ::: Peach and turquoise are not used together in a rug\nForAll([r:rugs], Not(And(used(peach, r), used(yellow, r)))) ::: Peach and yellow are not used together in a rug\nCount([r:rugs], Count([c:colors], used(c, r)) == 1) == 2 ::: If there are exactly two solid rugs\n\n# Options\nQuestion ::: If there are exactly two solid rugs, then the colors of those two rugs CANNOT be\nis_unsat(And(used(forest, rug1), used(peach, rug2), Count([c:colors], used(c, rug1)) == 1, Count([c:colors], used(c, rug2)) == 1)) ::: (A)\nis_unsat(And(used(forest, rug1), used(yellow, rug2), Count([c:colors], used(c, rug1)) == 1, Count([c:colors], used(c, rug2)) == 1)) ::: (B)\nis_unsat(And(used(peach, rug1), used(turquoise, rug2), Count([c:colors], used(c, rug1)) == 1, Count([c:colors], used(c, rug2)) == 1)) ::: (C)\nis_unsat(And(used(peach, rug1), used(yellow, rug2), Count([c:colors], used(c, rug1)) == 1, Count([c:colors], used(c, rug2)) == 1)) ::: (D)\nis_unsat(And(used(turquoise, rug1), used(yellow, rug2), Count([c:colors], used(c, rug1)) == 1, Count([c:colors], used(c, rug2)) == 1)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201412_2-G_3_15",
    "context": "Three rugs will be woven out of colored thread. Six colors of thread are available—forest, olive, peach, turquoise, white, and yellow—exactly five of which will be used to weave the rugs. Each color that is used will be used in only one of the rugs. The rugs are either solid—woven in a single color—or multicolored. The rugs must be woven according to the following rules: In any rug in which white is used, two other colors are also used. In any rug in which olive is used, peach is also used. Forest and turquoise are not used together in a rug. Peach and turquoise are not used together in a rug. Peach and yellow are not used together in a rug.",
    "question": "If forest and peach are used together in a rug, which one of the following could be true?",
    "answer": "B",
    "options": [
      "A) There is exactly one solid rug.",
      "B) White is not used in any of the rugs.",
      "C) Yellow is not used in any of the rugs.",
      "D) Turquoise and white are used together in a rug.",
      "E) Turquoise and yellow are used together in a rug."
    ],
    "raw_logic_programs": [
      "# Declarations\ncolors = EnumSort([forest, olive, peach, turquoise, white, yellow])\nrugs = EnumSort([rug1, rug2, rug3])\nused = Function([colors, rugs] -> [bool])\n\n# Constraints\nCount([c:colors], used(c, rug1) or used(c, rug2) or used(c, rug3)) == 5 ::: exactly five of which will be used to weave the rugs\nForAll([c:colors], Count([r:rugs], used(c, r)) <= 1) ::: Each color that is used will be used in only one of the rugs\nForAll([r:rugs], Implies(used(white, r), And(Count([c:colors], used(c, r)) == 3, used(white, r)))) ::: In any rug in which white is used, two other colors are also used\nForAll([r:rugs], Implies(used(olive, r), used(peach, r))) ::: In any rug in which olive is used, peach is also used\nForAll([r:rugs], Not(And(used(forest, r), used(turquoise, r)))) ::: Forest and turquoise are not used together in a rug\nForAll([r:rugs], Not(And(used(peach, r), used(turquoise, r)))) ::: Peach and turquoise are not used together in a rug\nForAll([r:rugs], Not(And(used(peach, r), used(yellow, r)))) ::: Peach and yellow are not used together in a rug\nAnd(used(forest, rug1), used(peach, rug1)) ::: If forest and peach are used together in a rug\n\n# Options\nQuestion ::: If forest and peach are used together in a rug, which one of the following could be true?\nis_sat(And(Count([r:rugs], Count([c:colors], used(c, r)) == 1) == 1, Count([r:rugs], Count([c:colors], used(c, r)) > 1) == 2)) ::: (A)\nis_sat(Not(used(white, rug1) or used(white, rug2) or used(white, rug3))) ::: (B)\nis_sat(Not(used(yellow, rug1) or used(yellow, rug2) or used(yellow, rug3))) ::: (C)\nis_sat(And(used(turquoise, rug1), used(white, rug1))) ::: (D)\nis_sat(And(used(turquoise, rug1), used(yellow, rug1))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201412_2-G_3_16",
    "context": "Three rugs will be woven out of colored thread. Six colors of thread are available—forest, olive, peach, turquoise, white, and yellow—exactly five of which will be used to weave the rugs. Each color that is used will be used in only one of the rugs. The rugs are either solid—woven in a single color—or multicolored. The rugs must be woven according to the following rules: In any rug in which white is used, two other colors are also used. In any rug in which olive is used, peach is also used. Forest and turquoise are not used together in a rug. Peach and turquoise are not used together in a rug. Peach and yellow are not used together in a rug.",
    "question": "If one of the rugs is solid yellow, then any of the following could be true EXCEPT:",
    "answer": "A",
    "options": [
      "A) There is exactly one solid color rug.",
      "B) One of the rugs is solid forest.",
      "C) Turquoise is not used in any of the rugs.",
      "D) Forest and olive are used together in a rug.",
      "E) Peach and white are used together in a rug."
    ],
    "raw_logic_programs": [
      "# Declarations\ncolors = EnumSort([forest, olive, peach, turquoise, white, yellow])\nrugs = EnumSort([rug1, rug2, rug3])\nused = Function([colors, rugs] -> [bool])\n\n# Constraints\nCount([c:colors], used(c, rug1) or used(c, rug2) or used(c, rug3)) == 5 ::: exactly five of which will be used to weave the rugs\nForAll([c:colors], Count([r:rugs], used(c, r)) <= 1) ::: Each color that is used will be used in only one of the rugs\nForAll([r:rugs], Implies(used(white, r), And(Count([c:colors], used(c, r)) == 3, used(white, r)))) ::: In any rug in which white is used, two other colors are also used\nForAll([r:rugs], Implies(used(olive, r), used(peach, r))) ::: In any rug in which olive is used, peach is also used\nForAll([r:rugs], Not(And(used(forest, r), used(turquoise, r)))) ::: Forest and turquoise are not used together in a rug\nForAll([r:rugs], Not(And(used(peach, r), used(turquoise, r)))) ::: Peach and turquoise are not used together in a rug\nForAll([r:rugs], Not(And(used(peach, r), used(yellow, r)))) ::: Peach and yellow are not used together in a rug\nused(yellow, rug1) ::: If one of the rugs is solid yellow\n\n# Options\nQuestion ::: If one of the rugs is solid yellow, then any of the following could be true EXCEPT:\nis_unsat(And(Count([r:rugs], Count([c:colors], used(c, r)) == 1) == 1, used(yellow, rug1))) ::: (A)\nis_sat(And(used(forest, rug2), used(yellow, rug1))) ::: (B)\nis_sat(And(used(yellow, rug1), Not(used(turquoise, rug1)) and Not(used(turquoise, rug2)) and Not(used(turquoise, rug3)))) ::: (C)\nis_sat(And(used(forest, rug2), used(olive, rug2), used(yellow, rug1))) ::: (D)\nis_unsat(And(used(peach, rug2), used(white, rug2), used(yellow, rug1))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201412_2-G_4_17",
    "context": "The manager of a photography business must assign at least two photographers to each of two graduation ceremonies—one at Silva University and the other at Thorne University. Exactly six photographers are available—Frost, Gonzalez, Heideck, Knutson, Lai, and Mays—but not all have to be assigned. No photographer can be assigned to both ceremonies. The following constraints apply: Frost must be assigned together with Heideck to one of the graduation ceremonies. If Lai and Mays are both assigned, it must be to different ceremonies. If Gonzalez is assigned to the Silva University ceremony, then Lai must be assigned to the Thorne University ceremony. If Knutson is not assigned to the Thorne University ceremony, then both Heideck and Mays must be assigned to it.",
    "question": "Which one of the following is an acceptable assignment of photographers to the two graduation ceremonies?",
    "answer": "E",
    "options": [
      "A) Silva University: Gonzalez, Lai Thorne University: Frost, Heideck, Mays",
      "B) Silva University: Gonzalez, Mays Thorne University: Knutson, Lai",
      "C) Silva University: Frost, Gonzalez, Heideck Thorne University: Knutson, Lai, Mays",
      "D) Silva University: Frost, Heideck, Mays Thorne University: Gonzalez, Lai",
      "E) Silva University: Frost, Heideck, Mays Thorne University: Gonzalez, Knutson, Lai"
    ],
    "raw_logic_programs": [
      "# Declarations\nphotographers = EnumSort([Frost, Gonzalez, Heideck, Knutson, Lai, Mays])\nceremonies = EnumSort([Silva_University, Thorne_University])\nassigned = Function([photographers, ceremonies] -> [bool])\n\n# Constraints\nForAll([c:ceremonies], Count([p:photographers], assigned(p, c)) >= 2) ::: The manager of a photography business must assign at least two photographers to each of two graduation ceremonies\nForAll([p:photographers], Count([c:ceremonies], assigned(p, c)) <= 1) ::: No photographer can be assigned to both ceremonies\nAnd(assigned(Frost, Silva_University) == assigned(Heideck, Silva_University), assigned(Frost, Thorne_University) == assigned(Heideck, Thorne_University)) ::: Frost must be assigned together with Heideck to one of the graduation ceremonies\nImplies(And(assigned(Lai, Silva_University), assigned(Mays, Silva_University)), assigned(Lai, Thorne_University) == assigned(Mays, Thorne_University)) ::: If Lai and Mays are both assigned, it must be to different ceremonies\nImplies(assigned(Gonzalez, Silva_University), assigned(Lai, Thorne_University)) ::: If Gonzalez is assigned to the Silva University ceremony, then Lai must be assigned to the Thorne University ceremony\nImplies(Not(assigned(Knutson, Thorne_University)), And(assigned(Heideck, Thorne_University), assigned(Mays, Thorne_University))) ::: If Knutson is not assigned to the Thorne University ceremony, then both Heideck and Mays must be assigned to it\n\n# Options\nQuestion ::: Which one of the following is an acceptable assignment of photographers to the two graduation ceremonies?\nis_valid(And(assigned(Gonzalez, Silva_University), assigned(Lai, Silva_University), assigned(Frost, Thorne_University), assigned(Heideck, Thorne_University), assigned(Mays, Thorne_University))) ::: (A)\nis_valid(And(assigned(Gonzalez, Silva_University), assigned(Mays, Silva_University), assigned(Knutson, Thorne_University), assigned(Lai, Thorne_University))) ::: (B)\nis_valid(And(assigned(Frost, Silva_University), assigned(Gonzalez, Silva_University), assigned(Heideck, Silva_University), assigned(Knutson, Thorne_University), assigned(Lai, Thorne_University), assigned(Mays, Thorne_University))) ::: (C)\nis_valid(And(assigned(Frost, Silva_University), assigned(Heideck, Silva_University), assigned(Mays, Silva_University), assigned(Gonzalez, Thorne_University), assigned(Lai, Thorne_University))) ::: (D)\nis_valid(And(assigned(Frost, Silva_University), assigned(Heideck, Silva_University), assigned(Mays, Silva_University), assigned(Gonzalez, Thorne_University), assigned(Knutson, Thorne_University), assigned(Lai, Thorne_University))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201412_2-G_4_18",
    "context": "The manager of a photography business must assign at least two photographers to each of two graduation ceremonies—one at Silva University and the other at Thorne University. Exactly six photographers are available—Frost, Gonzalez, Heideck, Knutson, Lai, and Mays—but not all have to be assigned. No photographer can be assigned to both ceremonies. The following constraints apply: Frost must be assigned together with Heideck to one of the graduation ceremonies. If Lai and Mays are both assigned, it must be to different ceremonies. If Gonzalez is assigned to the Silva University ceremony, then Lai must be assigned to the Thorne University ceremony. If Knutson is not assigned to the Thorne University ceremony, then both Heideck and Mays must be assigned to it.",
    "question": "If Heideck is assigned to the same graduation ceremony as Lai, then which one of the following must be true?",
    "answer": "D",
    "options": [
      "A) Frost is assigned to the Thorne University ceremony.",
      "B) Gonzalez is assigned to the Silva University ceremony.",
      "C) Gonzalez is assigned to neither graduation ceremony.",
      "D) Knutson is assigned to the Thorne University ceremony.",
      "E) Lai is assigned to the Thorne University ceremony."
    ],
    "raw_logic_programs": [
      "# Declarations\nphotographers = EnumSort([Frost, Gonzalez, Heideck, Knutson, Lai, Mays])\nceremonies = EnumSort([Silva, Thorne])\nassigned = Function([photographers, ceremonies] -> [bool])\n\n# Constraints\nForAll([c:ceremonies], Count([p:photographers], assigned(p, c)) >= 2) ::: The manager of a photography business must assign at least two photographers to each of two graduation ceremonies\nForAll([p:photographers], Count([c:ceremonies], assigned(p, c)) <= 1) ::: No photographer can be assigned to both ceremonies\nAnd(assigned(Frost, Silva), assigned(Heideck, Silva)) \\/ And(assigned(Frost, Thorne), assigned(Heideck, Thorne)) ::: Frost must be assigned together with Heideck to one of the graduation ceremonies\nImplies(And(assigned(Lai, Silva), assigned(Mays, Thorne)), assigned(Lai, Thorne) != assigned(Mays, Thorne)) ::: If Lai and Mays are both assigned, it must be to different ceremonies\nImplies(assigned(Gonzalez, Silva), assigned(Lai, Thorne)) ::: If Gonzalez is assigned to the Silva University ceremony, then Lai must be assigned to the Thorne University ceremony\nImplies(Not(assigned(Knutson, Thorne)), And(assigned(Heideck, Thorne), assigned(Mays, Thorne))) ::: If Knutson is not assigned to the Thorne University ceremony, then both Heideck and Mays must be assigned to it\nAnd(assigned(Heideck, Silva), assigned(Lai, Silva)) \\/ And(assigned(Heideck, Thorne), assigned(Lai, Thorne)) ::: Heideck is assigned to the same graduation ceremony as Lai\n\n# Options\nQuestion ::: If Heideck is assigned to the same graduation ceremony as Lai, then which one of the following must be true?\nis_valid(assigned(Frost, Thorne)) ::: (A)\nis_valid(assigned(Gonzalez, Silva)) ::: (B)\nis_valid(Not(assigned(Gonzalez, Silva)) And Not(assigned(Gonzalez, Thorne))) ::: (C)\nis_valid(assigned(Knutson, Thorne)) ::: (D)\nis_valid(assigned(Lai, Thorne)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201412_2-G_4_19",
    "context": "The manager of a photography business must assign at least two photographers to each of two graduation ceremonies—one at Silva University and the other at Thorne University. Exactly six photographers are available—Frost, Gonzalez, Heideck, Knutson, Lai, and Mays—but not all have to be assigned. No photographer can be assigned to both ceremonies. The following constraints apply: Frost must be assigned together with Heideck to one of the graduation ceremonies. If Lai and Mays are both assigned, it must be to different ceremonies. If Gonzalez is assigned to the Silva University ceremony, then Lai must be assigned to the Thorne University ceremony. If Knutson is not assigned to the Thorne University ceremony, then both Heideck and Mays must be assigned to it.",
    "question": "Which one of the following could be the complete assignment of photographers to the Silva University ceremony?",
    "answer": "B",
    "options": [
      "A) Frost, Gonzalez, Heideck, Knutson",
      "B) Frost, Gonzalez, Heideck",
      "C) Gonzalez, Knutson",
      "D) Heideck, Lai",
      "E) Knutson, Mays"
    ],
    "raw_logic_programs": [
      "# Declarations\nphotographers = EnumSort([Frost, Gonzalez, Heideck, Knutson, Lai, Mays])\nceremonies = EnumSort([Silva, Thorne])\nassigned = Function([photographers, ceremonies] -> [bool])\n\n# Constraints\nForAll([c:ceremonies], Count([p:photographers], assigned(p, c)) >= 2) ::: The manager of a photography business must assign at least two photographers to each of two graduation ceremonies\nForAll([p:photographers], Count([c:ceremonies], assigned(p, c)) <= 1) ::: No photographer can be assigned to both ceremonies\nAnd(assigned(Frost, Silva), assigned(Heideck, Silva)) ::: Frost must be assigned together with Heideck to one of the graduation ceremonies\nImplies(And(assigned(Lai, Silva), assigned(Mays, Silva)), assigned(Lai, Thorne) != assigned(Mays, Thorne)) ::: If Lai and Mays are both assigned, it must be to different ceremonies\nImplies(assigned(Gonzalez, Silva), assigned(Lai, Thorne)) ::: If Gonzalez is assigned to the Silva University ceremony, then Lai must be assigned to the Thorne University ceremony\nImplies(Not(assigned(Knutson, Thorne)), And(assigned(Heideck, Thorne), assigned(Mays, Thorne))) ::: If Knutson is not assigned to the Thorne University ceremony, then both Heideck and Mays must be assigned to it\n\n# Options\nQuestion ::: Which one of the following could be the complete assignment of photographers to the Silva University ceremony?\nis_sat(And(assigned(Frost, Silva), assigned(Gonzalez, Silva), assigned(Heideck, Silva), assigned(Knutson, Silva))) ::: (A)\nis_sat(And(assigned(Frost, Silva), assigned(Gonzalez, Silva), assigned(Heideck, Silva))) ::: (B)\nis_sat(And(assigned(Gonzalez, Silva), assigned(Knutson, Silva))) ::: (C)\nis_sat(And(assigned(Heideck, Silva), assigned(Lai, Silva))) ::: (D)\nis_sat(And(assigned(Knutson, Silva), assigned(Mays, Silva))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201412_2-G_4_20",
    "context": "The manager of a photography business must assign at least two photographers to each of two graduation ceremonies—one at Silva University and the other at Thorne University. Exactly six photographers are available—Frost, Gonzalez, Heideck, Knutson, Lai, and Mays—but not all have to be assigned. No photographer can be assigned to both ceremonies. The following constraints apply: Frost must be assigned together with Heideck to one of the graduation ceremonies. If Lai and Mays are both assigned, it must be to different ceremonies. If Gonzalez is assigned to the Silva University ceremony, then Lai must be assigned to the Thorne University ceremony. If Knutson is not assigned to the Thorne University ceremony, then both Heideck and Mays must be assigned to it.",
    "question": "Which one of the following is a complete and accurate list of all of the photographers who must be assigned?",
    "answer": "B",
    "options": [
      "A) Frost, Heideck",
      "B) Frost, Heideck, Knutson",
      "C) Frost, Heideck, Knutson, Lai",
      "D) Frost, Gonzalez, Heideck",
      "E) Frost, Gonzalez, Heideck, Mays"
    ],
    "raw_logic_programs": [
      "# Declarations\nphotographers = EnumSort([Frost, Gonzalez, Heideck, Knutson, Lai, Mays])\nceremonies = EnumSort([Silva, Thorne])\nassigned = Function([photographers, ceremonies] -> [bool])\n\n# Constraints\nForAll([c:ceremonies], Count([p:photographers], assigned(p, c)) >= 2) ::: The manager of a photography business must assign at least two photographers to each of two graduation ceremonies\nForAll([p:photographers], Count([c:ceremonies], assigned(p, c)) <= 1) ::: No photographer can be assigned to both ceremonies\nAnd(assigned(Frost, Silva), assigned(Heideck, Silva)) ::: Frost must be assigned together with Heideck to one of the graduation ceremonies\nOr(Not(assigned(Lai, Silva)), Not(assigned(Mays, Silva))) ::: If Lai and Mays are both assigned, it must be to different ceremonies\nImplies(assigned(Gonzalez, Silva), assigned(Lai, Thorne)) ::: If Gonzalez is assigned to the Silva University ceremony, then Lai must be assigned to the Thorne University ceremony\nImplies(Not(assigned(Knutson, Thorne)), And(assigned(Heideck, Thorne), assigned(Mays, Thorne))) ::: If Knutson is not assigned to the Thorne University ceremony, then both Heideck and Mays must be assigned to it\n\n# Options\nQuestion ::: Which one of the following is a complete and accurate list of all of the photographers who must be assigned?\nis_accurate_list([assigned(Frost, Silva), assigned(Heideck, Silva)]) ::: (A)\nis_accurate_list([assigned(Frost, Silva), assigned(Heideck, Silva), assigned(Knutson, Silva)]) ::: (B)\nis_accurate_list([assigned(Frost, Silva), assigned(Heideck, Silva), assigned(Knutson, Silva), assigned(Lai, Thorne)]) ::: (C)\nis_accurate_list([assigned(Frost, Silva), assigned(Gonzalez, Silva), assigned(Heideck, Silva)]) ::: (D)\nis_accurate_list([assigned(Frost, Silva), assigned(Gonzalez, Silva), assigned(Heideck, Silva), assigned(Mays, Thorne)]) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201412_2-G_4_21",
    "context": "The manager of a photography business must assign at least two photographers to each of two graduation ceremonies—one at Silva University and the other at Thorne University. Exactly six photographers are available—Frost, Gonzalez, Heideck, Knutson, Lai, and Mays—but not all have to be assigned. No photographer can be assigned to both ceremonies. The following constraints apply: Frost must be assigned together with Heideck to one of the graduation ceremonies. If Lai and Mays are both assigned, it must be to different ceremonies. If Gonzalez is assigned to the Silva University ceremony, then Lai must be assigned to the Thorne University ceremony. If Knutson is not assigned to the Thorne University ceremony, then both Heideck and Mays must be assigned to it.",
    "question": "If exactly four of the photographers are assigned to the graduation ceremonies, then which one of the following must be assigned to the Silva University ceremony?",
    "answer": "A",
    "options": [
      "A) Frost",
      "B) Gonzalez",
      "C) Knutson",
      "D) Lai",
      "E) Mays"
    ],
    "raw_logic_programs": [
      "# Declarations\nphotographers = EnumSort([Frost, Gonzalez, Heideck, Knutson, Lai, Mays])\nceremonies = EnumSort([Silva, Thorne])\nassigned = Function([photographers, ceremonies] -> [bool])\n\n# Constraints\nForAll([c:ceremonies], Count([p:photographers], assigned(p, c)) >= 2) ::: The manager of a photography business must assign at least two photographers to each of two graduation ceremonies\nForAll([p:photographers], Count([c:ceremonies], assigned(p, c)) <= 1) ::: No photographer can be assigned to both ceremonies\nAnd(assigned(Frost, Silva), assigned(Heideck, Silva)) ::: Frost must be assigned together with Heideck to one of the graduation ceremonies\nOr(Not(assigned(Lai, Silva)), Not(assigned(Mays, Silva))) ::: If Lai and Mays are both assigned, it must be to different ceremonies\nImplies(assigned(Gonzalez, Silva), assigned(Lai, Thorne)) ::: If Gonzalez is assigned to the Silva University ceremony, then Lai must be assigned to the Thorne University ceremony\nImplies(Not(assigned(Knutson, Thorne)), And(assigned(Heideck, Thorne), assigned(Mays, Thorne))) ::: If Knutson is not assigned to the Thorne University ceremony, then both Heideck and Mays must be assigned to it\nCount([p:photographers, c:ceremonies], assigned(p, c)) == 4 ::: If exactly four of the photographers are assigned to the graduation ceremonies\n\n# Options\nQuestion ::: If exactly four of the photographers are assigned to the graduation ceremonies, then which one of the following must be assigned to the Silva University ceremony?\nis_valid(assigned(Frost, Silva)) ::: (A)\nis_valid(assigned(Gonzalez, Silva)) ::: (B)\nis_valid(assigned(Knutson, Silva)) ::: (C)\nis_valid(assigned(Lai, Silva)) ::: (D)\nis_valid(assigned(Mays, Silva)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201412_2-G_4_22",
    "context": "The manager of a photography business must assign at least two photographers to each of two graduation ceremonies—one at Silva University and the other at Thorne University. Exactly six photographers are available—Frost, Gonzalez, Heideck, Knutson, Lai, and Mays—but not all have to be assigned. No photographer can be assigned to both ceremonies. The following constraints apply: Frost must be assigned together with Heideck to one of the graduation ceremonies. If Lai and Mays are both assigned, it must be to different ceremonies. If Gonzalez is assigned to the Silva University ceremony, then Lai must be assigned to the Thorne University ceremony. If Knutson is not assigned to the Thorne University ceremony, then both Heideck and Mays must be assigned to it.",
    "question": "Which one of the following CANNOT be the complete assignment of photographers to the Thorne University ceremony?",
    "answer": "B",
    "options": [
      "A) Frost, Gonzalez, Heideck, Mays",
      "B) Frost, Heideck, Knutson, Mays",
      "C) Gonzalez, Knutson, Lai",
      "D) Gonzalez, Knutson, Mays",
      "E) Knutson, Mays"
    ],
    "raw_logic_programs": [
      "# Declarations\nphotographers = EnumSort([Frost, Gonzalez, Heideck, Knutson, Lai, Mays])\nceremonies = EnumSort([Silva, Thorne])\nassigned = Function([photographers, ceremonies] -> [bool])\n\n# Constraints\nForAll([c:ceremonies], Count([p:photographers], assigned(p, c)) >= 2) ::: The manager of a photography business must assign at least two photographers to each of two graduation ceremonies\nForAll([p:photographers], Count([c:ceremonies], assigned(p, c)) <= 1) ::: No photographer can be assigned to both ceremonies\nAnd(assigned(Frost, Silva), assigned(Heideck, Silva)) ::: Frost must be assigned together with Heideck to one of the graduation ceremonies\nOr(Not(assigned(Lai, Silva)), Not(assigned(Mays, Silva))) ::: If Lai and Mays are both assigned, it must be to different ceremonies\nImplies(assigned(Gonzalez, Silva), assigned(Lai, Thorne)) ::: If Gonzalez is assigned to the Silva University ceremony, then Lai must be assigned to the Thorne University ceremony\nImplies(Not(assigned(Knutson, Thorne)), And(assigned(Heideck, Thorne), assigned(Mays, Thorne))) ::: If Knutson is not assigned to the Thorne University ceremony, then both Heideck and Mays must be assigned to it\n\n# Options\nQuestion ::: Which one of the following CANNOT be the complete assignment of photographers to the Thorne University ceremony?\nis_unsat(And(assigned(Frost, Thorne), assigned(Gonzalez, Thorne), assigned(Heideck, Thorne), assigned(Mays, Thorne))) ::: (A)\nis_unsat(And(assigned(Frost, Thorne), assigned(Heideck, Thorne), assigned(Knutson, Thorne), assigned(Mays, Thorne))) ::: (B)\nis_unsat(And(assigned(Gonzalez, Thorne), assigned(Knutson, Thorne), assigned(Lai, Thorne))) ::: (C)\nis_unsat(And(assigned(Gonzalez, Thorne), assigned(Knutson, Thorne), assigned(Mays, Thorne))) ::: (D)\nis_unsat(And(assigned(Knutson, Thorne), assigned(Mays, Thorne))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201412_2-G_4_23",
    "context": "The manager of a photography business must assign at least two photographers to each of two graduation ceremonies—one at Silva University and the other at Thorne University. Exactly six photographers are available—Frost, Gonzalez, Heideck, Knutson, Lai, and Mays—but not all have to be assigned. No photographer can be assigned to both ceremonies. The following constraints apply: Frost must be assigned together with Heideck to one of the graduation ceremonies. If Lai and Mays are both assigned, it must be to different ceremonies. If Gonzalez is assigned to the Silva University ceremony, then Lai must be assigned to the Thorne University ceremony. If Knutson is not assigned to the Thorne University ceremony, then both Heideck and Mays must be assigned to it.",
    "question": "Which one of the following, if substituted for the constraint that if Knutson is not assigned to the Thorne University ceremony, then both Heideck and Mays must be assigned to it, would have the same effect in determining the assignment of photographers to the graduation ceremonies?",
    "answer": "C",
    "options": [
      "A) If Knutson is assigned to the Silva University ceremony, then Heideck and Mays cannot both be assigned to that ceremony.",
      "B) If Knutson is assigned to the Silva University ceremony, then Lai must also be assigned to that ceremony.",
      "C) Unless Knutson is assigned to the Thorne University ceremony, both Frost and Mays must be assigned to that ceremony.",
      "D) Unless Knutson is assigned to the Thorne University ceremony, Heideck cannot be assigned to the same ceremony as Lai.",
      "E) Unless either Heideck or Mays is assigned to the Thorne University ceremony, Knutson must be assigned to that ceremony."
    ],
    "raw_logic_programs": [
      "# Declarations\nphotographers = EnumSort([Frost, Gonzalez, Heideck, Knutson, Lai, Mays])\nceremonies = EnumSort([Silva, Thorne])\nassigned = Function([photographers, ceremonies] -> [bool])\n\n# Constraints\nForAll([c:ceremonies], Count([p:photographers], assigned(p, c)) >= 2) ::: The manager of a photography business must assign at least two photographers to each of two graduation ceremonies\nForAll([p:photographers], Count([c:ceremonies], assigned(p, c)) <= 1) ::: No photographer can be assigned to both ceremonies\nAnd(assigned(Frost, Silva), assigned(Heideck, Silva)) ::: Frost must be assigned together with Heideck to one of the graduation ceremonies\nOr(Not(assigned(Lai, Silva)), Not(assigned(Mays, Silva))) ::: If Lai and Mays are both assigned, it must be to different ceremonies\nImplies(assigned(Gonzalez, Silva), assigned(Lai, Thorne)) ::: If Gonzalez is assigned to the Silva University ceremony, then Lai must be assigned to the Thorne University ceremony\n# Options\nQuestion ::: Which one of the following, if substituted for the constraint that if Knutson is not assigned to the Thorne University ceremony, then both Heideck and Mays must be assigned to it, would have the same effect in determining the assignment of photographers to the graduation ceremonies?\nis_equivalent(Implies(Not(assigned(Knutson, Thorne)), And(assigned(Heideck, Thorne), assigned(Mays, Thorne))), Implies(assigned(Knutson, Silva), Not(And(assigned(Heideck, Silva), assigned(Mays, Silva))))) ::: (A)\nis_equivalent(Implies(Not(assigned(Knutson, Thorne)), And(assigned(Heideck, Thorne), assigned(Mays, Thorne))), Implies(assigned(Knutson, Silva), assigned(Lai, Silva))) ::: (B)\nis_equivalent(Implies(Not(assigned(Knutson, Thorne)), And(assigned(Heideck, Thorne), assigned(Mays, Thorne))), Implies(Not(assigned(Knutson, Thorne)), And(assigned(Frost, Thorne), assigned(Mays, Thorne)))) ::: (C)\nis_equivalent(Implies(Not(assigned(Knutson, Thorne)), And(assigned(Heideck, Thorne), assigned(Mays, Thorne))), Implies(Not(assigned(Knutson, Thorne)), Not(And(assigned(Heideck, Thorne), assigned(Lai, Thorne))))) ::: (D)\nis_equivalent(Implies(Not(assigned(Knutson, Thorne)), And(assigned(Heideck, Thorne), assigned(Mays, Thorne))), Implies(Not(And(assigned(Heideck, Thorne), assigned(Mays, Thorne))), assigned(Knutson, Thorne))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201510_3-G_1_1",
    "context": "A detective is trying to determine the order in which a criminal recruited seven accomplices—Peters, Quinn, Rovero, Stanton, Tao, Villas, and White. In addition to discovering that the suspect recruited the accomplices one at a time, the detective has established the following: Stanton was recruited neither immediately before nor immediately after Tao. Quinn was recruited earlier than Rovero. Villas was recruited immediately before White. Peters was recruited fourth.",
    "question": "Which one of the following could be the order in which the accomplices were recruited, from first to last?",
    "answer": "D",
    "options": [
      "A) Quinn, Tao, Stanton, Peters, Villas, White, Rovero",
      "B) Quinn, White, Rovero, Peters, Stanton, Villas, Tao",
      "C) Villas, White, Quinn, Stanton, Peters, Tao, Rovero",
      "D) Villas, White, Stanton, Peters, Quinn, Tao, Rovero",
      "E) Villas, White, Stanton, Peters, Rovero, Tao, Quinn"
    ],
    "raw_logic_programs": [
      "# Declarations\naccomplices = EnumSort([Peters, Quinn, Rovero, Stanton, Tao, Villas, White])\nrecruited = Function([accomplices] -> [int])\nForAll([a:accomplices], And(1 <= recruited(a), recruited(a) <= 7))\n\n# Constraints\nDistinct([a:accomplices], recruited(a)) ::: the suspect recruited the accomplices one at a time\nNot(And(recruited(Stanton) == recruited(Tao) + 1, recruited(Stanton) == recruited(Tao) - 1)) ::: Stanton was recruited neither immediately before nor immediately after Tao\nrecruited(Quinn) < recruited(Rovero) ::: Quinn was recruited earlier than Rovero\nrecruited(Villas) == recruited(White) - 1 ::: Villas was recruited immediately before White\nrecruited(Peters) == 4 ::: Peters was recruited fourth\n\n# Options\nQuestion ::: Which one of the following could be the order in which the accomplices were recruited, from first to last?\nis_sat(And(recruited(Quinn) == 1, recruited(Tao) == 2, recruited(Stanton) == 3, recruited(Peters) == 4, recruited(Villas) == 5, recruited(White) == 6, recruited(Rovero) == 7)) ::: (A)\nis_sat(And(recruited(Quinn) == 1, recruited(White) == 2, recruited(Rovero) == 3, recruited(Peters) == 4, recruited(Stanton) == 5, recruited(Villas) == 6, recruited(Tao) == 7)) ::: (B)\nis_sat(And(recruited(Villas) == 1, recruited(White) == 2, recruited(Quinn) == 3, recruited(Stanton) == 4, recruited(Peters) == 5, recruited(Tao) == 6, recruited(Rovero) == 7)) ::: (C)\nis_sat(And(recruited(Villas) == 1, recruited(White) == 2, recruited(Stanton) == 3, recruited(Peters) == 4, recruited(Quinn) == 5, recruited(Tao) == 6, recruited(Rovero) == 7)) ::: (D)\nis_sat(And(recruited(Villas) == 1, recruited(White) == 2, recruited(Stanton) == 3, recruited(Peters) == 4, recruited(Rovero) == 5, recruited(Tao) == 6, recruited(Quinn) == 7)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201510_3-G_1_2",
    "context": "A detective is trying to determine the order in which a criminal recruited seven accomplices—Peters, Quinn, Rovero, Stanton, Tao, Villas, and White. In addition to discovering that the suspect recruited the accomplices one at a time, the detective has established the following: Stanton was recruited neither immediately before nor immediately after Tao. Quinn was recruited earlier than Rovero. Villas was recruited immediately before White. Peters was recruited fourth.",
    "question": "Which one of the following could be the list of the middle five accomplices, in the order in which they were recruited, from second to sixth?",
    "answer": "C",
    "options": [
      "A) Quinn, Stanton, Peters, Tao, Villas",
      "B) Quinn, Stanton, Peters, Tao, White",
      "C) Villas, White, Peters, Quinn, Stanton",
      "D) Villas, White, Peters, Rovero, Stanton",
      "E) Villas, White, Quinn, Rovero, Stanton"
    ],
    "raw_logic_programs": [
      "# Declarations\naccomplices = EnumSort([Peters, Quinn, Rovero, Stanton, Tao, Villas, White])\nrecruited = Function([accomplices] -> [int])\nForAll([a:accomplices], And(1 <= recruited(a), recruited(a) <= 7))\n\n# Constraints\nDistinct([a:accomplices], recruited(a)) ::: the suspect recruited the accomplices one at a time\nNot(Or(recruited(Stanton) == recruited(Tao) + 1, recruited(Stanton) == recruited(Tao) - 1)) ::: Stanton was recruited neither immediately before nor immediately after Tao\nrecruited(Quinn) < recruited(Rovero) ::: Quinn was recruited earlier than Rovero\nrecruited(Villas) == recruited(White) - 1 ::: Villas was recruited immediately before White\nrecruited(Peters) == 4 ::: Peters was recruited fourth\n\n# Options\nQuestion ::: Which one of the following could be the list of the middle five accomplices, in the order in which they were recruited, from second to sixth?\nis_sat(And(recruited(Quinn) == 2, recruited(Stanton) == 3, recruited(Peters) == 4, recruited(Tao) == 5, recruited(Villas) == 6)) ::: (A)\nis_sat(And(recruited(Quinn) == 2, recruited(Stanton) == 3, recruited(Peters) == 4, recruited(Tao) == 5, recruited(White) == 6)) ::: (B)\nis_sat(And(recruited(Villas) == 2, recruited(White) == 3, recruited(Peters) == 4, recruited(Quinn) == 5, recruited(Stanton) == 6)) ::: (C)\nis_sat(And(recruited(Villas) == 2, recruited(White) == 3, recruited(Peters) == 4, recruited(Rovero) == 5, recruited(Stanton) == 6)) ::: (D)\nis_sat(And(recruited(Villas) == 2, recruited(White) == 3, recruited(Quinn) == 4, recruited(Rovero) == 5, recruited(Stanton) == 6)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201510_3-G_1_3",
    "context": "A detective is trying to determine the order in which a criminal recruited seven accomplices—Peters, Quinn, Rovero, Stanton, Tao, Villas, and White. In addition to discovering that the suspect recruited the accomplices one at a time, the detective has established the following: Stanton was recruited neither immediately before nor immediately after Tao. Quinn was recruited earlier than Rovero. Villas was recruited immediately before White. Peters was recruited fourth.",
    "question": "If Tao was recruited second, which one of the following could be true?",
    "answer": "D",
    "options": [
      "A) Quinn was recruited third.",
      "B) Rovero was recruited fifth.",
      "C) Stanton was recruited sixth.",
      "D) Villas was recruited sixth.",
      "E) White was recruited third."
    ],
    "raw_logic_programs": [
      "# Declarations\naccomplices = EnumSort([Peters, Quinn, Rovero, Stanton, Tao, Villas, White])\nrecruited = Function([accomplices] -> [int])\nForAll([a:accomplices], And(1 <= recruited(a), recruited(a) <= 7))\n\n# Constraints\nDistinct([a:accomplices], recruited(a)) ::: the suspect recruited the accomplices one at a time\nAnd(recruited(Stanton) != recruited(Tao) + 1, recruited(Stanton) != recruited(Tao) - 1) ::: Stanton was recruited neither immediately before nor immediately after Tao\nrecruited(Quinn) < recruited(Rovero) ::: Quinn was recruited earlier than Rovero\nrecruited(Villas) + 1 == recruited(White) ::: Villas was recruited immediately before White\nrecruited(Peters) == 4 ::: Peters was recruited fourth\nrecruited(Tao) == 2 ::: Tao was recruited second\n\n# Options\nQuestion ::: If Tao was recruited second, which one of the following could be true?\nis_sat(recruited(Quinn) == 3) ::: (A)\nis_sat(recruited(Rovero) == 5) ::: (B)\nis_sat(recruited(Stanton) == 6) ::: (C)\nis_sat(recruited(Villas) == 6) ::: (D)\nis_sat(recruited(White) == 3) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201510_3-G_1_4",
    "context": "A detective is trying to determine the order in which a criminal recruited seven accomplices—Peters, Quinn, Rovero, Stanton, Tao, Villas, and White. In addition to discovering that the suspect recruited the accomplices one at a time, the detective has established the following: Stanton was recruited neither immediately before nor immediately after Tao. Quinn was recruited earlier than Rovero. Villas was recruited immediately before White. Peters was recruited fourth.",
    "question": "f Quinn was recruited immediately before Rovero, then Stanton CANNOT have been recruited",
    "answer": "B",
    "options": [
      "A) first",
      "B) second",
      "C) third",
      "D) fifth",
      "E) seventh"
    ],
    "raw_logic_programs": [
      "# Declarations\naccomplices = EnumSort([Peters, Quinn, Rovero, Stanton, Tao, Villas, White])\nrecruited = Function([accomplices] -> [int])\nForAll([a:accomplices], And(1 <= recruited(a), recruited(a) <= 7))\n\n# Constraints\nDistinct([a:accomplices], recruited(a)) ::: the suspect recruited the accomplices one at a time\nAnd(recruited(Stanton) != recruited(Tao) + 1, recruited(Stanton) != recruited(Tao) - 1) ::: Stanton was recruited neither immediately before nor immediately after Tao\nrecruited(Quinn) < recruited(Rovero) ::: Quinn was recruited earlier than Rovero\nrecruited(Villas) + 1 == recruited(White) ::: Villas was recruited immediately before White\nrecruited(Peters) == 4 ::: Peters was recruited fourth\nAnd(recruited(Quinn) + 1 == recruited(Rovero), recruited(Stanton) != 1) ::: if Quinn was recruited immediately before Rovero\n\n# Options\nQuestion ::: then Stanton CANNOT have been recruited\nis_unsat(recruited(Stanton) == 1) ::: (A)\nis_unsat(recruited(Stanton) == 2) ::: (B)\nis_unsat(recruited(Stanton) == 3) ::: (C)\nis_unsat(recruited(Stanton) == 5) ::: (D)\nis_unsat(recruited(Stanton) == 7) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201510_3-G_1_5",
    "context": "A detective is trying to determine the order in which a criminal recruited seven accomplices—Peters, Quinn, Rovero, Stanton, Tao, Villas, and White. In addition to discovering that the suspect recruited the accomplices one at a time, the detective has established the following: Stanton was recruited neither immediately before nor immediately after Tao. Quinn was recruited earlier than Rovero. Villas was recruited immediately before White. Peters was recruited fourth.",
    "question": "If White was recruited earlier than Rovero and if Rovero was recruited earlier than Tao, then which one of the following could be true?",
    "answer": "A",
    "options": [
      "A) Quinn was recruited first.",
      "B) Rovero was recruited third.",
      "C) Stanton was recruited second.",
      "D) Tao was recruited sixth.",
      "E) Villas was recruited sixth."
    ],
    "raw_logic_programs": [
      "# Declarations\naccomplices = EnumSort([Peters, Quinn, Rovero, Stanton, Tao, Villas, White])\nrecruited = Function([accomplices] -> [int])\nForAll([a:accomplices], And(1 <= recruited(a), recruited(a) <= 7))\n\n# Constraints\nDistinct([a:accomplices], recruited(a)) ::: the suspect recruited the accomplices one at a time\nAnd(recruited(Stanton) != recruited(Tao) + 1, recruited(Stanton) != recruited(Tao) - 1) ::: Stanton was recruited neither immediately before nor immediately after Tao\nrecruited(Quinn) < recruited(Rovero) ::: Quinn was recruited earlier than Rovero\nrecruited(Villas) + 1 == recruited(White) ::: Villas was recruited immediately before White\nrecruited(Peters) == 4 ::: Peters was recruited fourth\nAnd(recruited(White) < recruited(Rovero), recruited(Rovero) < recruited(Tao)) ::: If White was recruited earlier than Rovero and if Rovero was recruited earlier than Tao\n\n# Options\nQuestion ::: If White was recruited earlier than Rovero and if Rovero was recruited earlier than Tao, then which one of the following could be true?\nis_sat(recruited(Quinn) == 1) ::: (A)\nis_sat(recruited(Rovero) == 3) ::: (B)\nis_sat(recruited(Stanton) == 2) ::: (C)\nis_sat(recruited(Tao) == 6) ::: (D)\nis_sat(recruited(Villas) == 6) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201510_3-G_1_6",
    "context": "A detective is trying to determine the order in which a criminal recruited seven accomplices—Peters, Quinn, Rovero, Stanton, Tao, Villas, and White. In addition to discovering that the suspect recruited the accomplices one at a time, the detective has established the following: Stanton was recruited neither immediately before nor immediately after Tao. Quinn was recruited earlier than Rovero. Villas was recruited immediately before White. Peters was recruited fourth.",
    "question": "If White was recruited immediately before Quinn, which one of the following must have been recruited sixth?",
    "answer": "B",
    "options": [
      "A) Quinn",
      "B) Rovero",
      "C) Stanton",
      "D) Villas",
      "E) White"
    ],
    "raw_logic_programs": [
      "# Declarations\naccomplices = EnumSort([Peters, Quinn, Rovero, Stanton, Tao, Villas, White])\nrecruited = Function([accomplices] -> [int])\nForAll([a:accomplices], And(1 <= recruited(a), recruited(a) <= 7))\n\n# Constraints\nDistinct([a:accomplices], recruited(a)) ::: the suspect recruited the accomplices one at a time\nNot(And(recruited(Stanton) == recruited(Tao) + 1, recruited(Stanton) == recruited(Tao) - 1)) ::: Stanton was recruited neither immediately before nor immediately after Tao\nrecruited(Quinn) < recruited(Rovero) ::: Quinn was recruited earlier than Rovero\nrecruited(Villas) == recruited(White) - 1 ::: Villas was recruited immediately before White\nrecruited(Peters) == 4 ::: Peters was recruited fourth\nrecruited(White) == recruited(Quinn) - 1 ::: White was recruited immediately before Quinn\n\n# Options\nQuestion ::: If White was recruited immediately before Quinn, which one of the following must have been recruited sixth?\nis_valid(recruited(Quinn) == 6) ::: (A)\nis_valid(recruited(Rovero) == 6) ::: (B)\nis_valid(recruited(Stanton) == 6) ::: (C)\nis_valid(recruited(Villas) == 6) ::: (D)\nis_valid(recruited(White) == 6) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201510_3-G_2_7",
    "context": "In the Lifestyle, Metro, and Sports sections of tomorrow's newspaper, a total of six different photographs are to appear, exactly two photographs per section. Each of the available photographs was taken by one of three photographers: Fuentes, Gagnon, and Hue. Selection of the photographs is constrained by the following conditions: For each photographer, at least one but no more than three of that photographers photographs must appear. At least one photograph in the Lifestyle section must be by a photographer who has at least one photograph in the Metro section. The number of Hue's photographs in the Lifestyle section must be the same as the number of Fuentes photographs in the Sports section. None of Gagnon's photographs can be in the Sports section.",
    "question": "which one of the following could be an acceptable selection of the photographs to appear?",
    "answer": "B",
    "options": [
      "A) Lifestyle: both photographs by Fuentes Metro: one photograph by Fuentes and one by Hue Sports: one photograph by Gagnon and one by Hue",
      "B) Lifestyle: one photograph by Fuentes and one by Gagnon Metro: one photograph by Fuentes and one by Gagnon Sports: both photographs by Hue",
      "C) Lifestyle: both photographs by Fuentes Metro: both photographs by Gagnon Sports: both photographs by Hue",
      "D) Lifestyle: both photographs by Gagnon Metro: one photograph by Fuentes and one by Gagnon Sports: one photograph by Fuentes and one by Hue",
      "E) Lifestyle: one photograph by Gagnon and one by Hue Metro: both photographs by Hue Sports: one photograph by Fuentes and one by Hue"
    ],
    "raw_logic_programs": [
      "# Declarations\nphotographers = EnumSort([Fuentes, Gagnon, Hue])\nsections = EnumSort([Lifestyle, Metro, Sports])\nphotographs = EnumSort([1, 2, 3, 4, 5, 6])\ntaken_by = Function([photographs] -> [photographers])\nappears_in = Function([photographs, sections] -> [bool])\n\n# Constraints\nForAll([p:photographers], And(1 <= Count([ph:photographs], taken_by(ph) == p), Count([ph:photographs], taken_by(ph) == p) <= 3)) ::: For each photographer, at least one but no more than three of that photographers photographs must appear\nForAll([s:sections], Count([ph:photographs], appears_in(ph, s)) == 2) ::: exactly two photographs per section\nExists([ph:photographs], And(appears_in(ph, Lifestyle), appears_in(ph, Metro))) ::: At least one photograph in the Lifestyle section must be by a photographer who has at least one photograph in the Metro section\nCount([ph:photographs], And(appears_in(ph, Lifestyle), taken_by(ph) == Hue)) == Count([ph:photographs], And(appears_in(ph, Sports), taken_by(ph) == Fuentes)) ::: The number of Hue's photographs in the Lifestyle section must be the same as the number of Fuentes photographs in the Sports section\nForAll([ph:photographs], Not(And(appears_in(ph, Sports), taken_by(ph) == Gagnon))) ::: None of Gagnon's photographs can be in the Sports section\n\n# Options\nQuestion ::: which one of the following could be an acceptable selection of the photographs to appear?\nis_sat(And(And(And(appears_in(1, Lifestyle), taken_by(1) == Fuentes), appears_in(2, Lifestyle), taken_by(2) == Fuentes), And(And(appears_in(3, Metro), taken_by(3) == Fuentes), appears_in(4, Metro), taken_by(4) == Hue), And(And(appears_in(5, Sports), taken_by(5) == Gagnon), appears_in(6, Sports), taken_by(6) == Hue)))) ::: (A)\nis_sat(And(And(And(appears_in(1, Lifestyle), taken_by(1) == Fuentes), appears_in(2, Lifestyle), taken_by(2) == Gagnon), And(And(appears_in(3, Metro), taken_by(3) == Fuentes), appears_in(4, Metro), taken_by(4) == Gagnon), And(And(appears_in(5, Sports), taken_by(5) == Hue), appears_in(6, Sports), taken_by(6) == Hue)))) ::: (B)\nis_sat(And(And(And(appears_in(1, Lifestyle), taken_by(1) == Fuentes), appears_in(2, Lifestyle), taken_by(2) == Fuentes), And(And(appears_in(3, Metro), taken_by(3) == Gagnon), appears_in(4, Metro), taken_by(4) == Gagnon), And(And(appears_in(5, Sports), taken_by(5) == Hue), appears_in(6, Sports), taken_by(6) == Hue)))) ::: (C)\nis_sat(And(And(And(appears_in(1, Lifestyle), taken_by(1) == Gagnon), appears_in(2, Lifestyle), taken_by(2) == Gagnon), And(And(appears_in(3, Metro), taken_by(3) == Fuentes), appears_in(4, Metro), taken_by(4) == Gagnon), And(And(appears_in(5, Sports), taken_by(5) == Fuentes), appears_in(6, Sports), taken_by(6) == Hue)))) ::: (D)\nis_sat(And(And(And(appears_in(1, Lifestyle), taken_by(1) == Gagnon), appears_in(2, Lifestyle), taken_by(2) == Hue), And(And(appears_in(3, Metro), taken_by(3) == Hue), appears_in(4, Metro), taken_by(4) == Hue), And(And(appears_in(5, Sports), taken_by(5) == Fuentes), appears_in(6, Sports), taken_by(6) == Hue)))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201510_3-G_2_8",
    "context": "In the Lifestyle, Metro, and Sports sections of tomorrow's newspaper, a total of six different photographs are to appear, exactly two photographs per section. Each of the available photographs was taken by one of three photographers: Fuentes, Gagnon, and Hue. Selection of the photographs is constrained by the following conditions: For each photographer, at least one but no more than three of that photographers photographs must appear. At least one photograph in the Lifestyle section must be by a photographer who has at least one photograph in the Metro section. The number of Hue's photographs in the Lifestyle section must be the same as the number of Fuentes photographs in the Sports section. None of Gagnon's photographs can be in the Sports section.",
    "question": "If both photographs in the Lifestyle section are by Hue, then which one of the following must be true of the six photographs?",
    "answer": "C",
    "options": [
      "A) Exactly one is by Fuentes.",
      "B) Exactly three are by Fuentes.",
      "C) Exactly one is by Gagnon.",
      "D) Exactly two are by Gagnon.",
      "E) Exactly two are by Hue."
    ],
    "raw_logic_programs": [
      "# Declarations\nphotographers = EnumSort([Fuentes, Gagnon, Hue])\nsections = EnumSort([Lifestyle, Metro, Sports])\nphotographs = EnumSort([1, 2, 3, 4, 5, 6])\ntaken_by = Function([photographs] -> [photographers])\nin_section = Function([photographs, sections] -> [bool])\n\n# Constraints\nForAll([p:photographers], And(1 <= Count([ph:photographs], taken_by(ph) == p), Count([ph:photographs], taken_by(ph) == p) <= 3)) ::: For each photographer, at least one but no more than three of that photographers photographs must appear\nForAll([s:sections], Count([ph:photographs], in_section(ph, s)) == 2) ::: exactly two photographs per section\nExists([ph:photographs], And(in_section(ph, Lifestyle), Exists([ph2:photographs], And(taken_by(ph) == taken_by(ph2), in_section(ph2, Metro))))) ::: At least one photograph in the Lifestyle section must be by a photographer who has at least one photograph in the Metro section\nCount([ph:photographs], And(in_section(ph, Lifestyle), taken_by(ph) == Hue)) == Count([ph:photographs], And(in_section(ph, Sports), taken_by(ph) == Fuentes)) ::: The number of Hue's photographs in the Lifestyle section must be the same as the number of Fuentes photographs in the Sports section\nForAll([ph:photographs], Implies(in_section(ph, Sports), taken_by(ph) != Gagnon)) ::: None of Gagnon's photographs can be in the Sports section\n\n# Options\nQuestion ::: If both photographs in the Lifestyle section are by Hue, then which one of the following must be true of the six photographs?\nis_valid(And(Count([ph:photographs], taken_by(ph) == Fuentes) == 1, Count([ph:photographs], taken_by(ph) == Gagnon) == 2, Count([ph:photographs], taken_by(ph) == Hue) == 3)) ::: (A)\nis_valid(And(Count([ph:photographs], taken_by(ph) == Fuentes) == 3, Count([ph:photographs], taken_by(ph) == Gagnon) == 1, Count([ph:photographs], taken_by(ph) == Hue) == 2)) ::: (B)\nis_valid(And(Count([ph:photographs], taken_by(ph) == Fuentes) == 2, Count([ph:photographs], taken_by(ph) == Gagnon) == 1, Count([ph:photographs], taken_by(ph) == Hue) == 3)) ::: (C)\nis_valid(And(Count([ph:photographs], taken_by(ph) == Fuentes) == 1, Count([ph:photographs], taken_by(ph) == Gagnon) == 2, Count([ph:photographs], taken_by(ph) == Hue) == 3)) ::: (D)\nis_valid(And(Count([ph:photographs], taken_by(ph) == Fuentes) == 1, Count([ph:photographs], taken_by(ph) == Gagnon) == 3, Count([ph:photographs], taken_by(ph) == Hue) == 2)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201510_3-G_2_9",
    "context": "In the Lifestyle, Metro, and Sports sections of tomorrow's newspaper, a total of six different photographs are to appear, exactly two photographs per section. Each of the available photographs was taken by one of three photographers: Fuentes, Gagnon, and Hue. Selection of the photographs is constrained by the following conditions: For each photographer, at least one but no more than three of that photographers photographs must appear. At least one photograph in the Lifestyle section must be by a photographer who has at least one photograph in the Metro section. The number of Hue's photographs in the Lifestyle section must be the same as the number of Fuentes photographs in the Sports section. None of Gagnon's photographs can be in the Sports section.",
    "question": "If one photograph in the Lifestyle section is by Gagnon and one is by Hue, then which one of the following must be true?",
    "answer": "D",
    "options": [
      "A) Exactly one photograph in the Metro section is by Fuentes.",
      "B) Exactly one photograph in the Metro section is by Gagnon.",
      "C) Both photographs in the Metro section are by Gagnon.",
      "D) Exactly one photograph in the Sports section is by Hue.",
      "E) Both photographs in the Sports section are by Hue."
    ],
    "raw_logic_programs": [
      "# Declarations\nsections = EnumSort([Lifestyle, Metro, Sports])\nphotographers = EnumSort([Fuentes, Gagnon, Hue])\nphotographs = EnumSort([1, 2, 3, 4, 5, 6])\ntaken_by = Function([photographs] -> [photographers])\nappears_in = Function([photographs, sections] -> [bool])\n\n# Constraints\nForAll([p:photographers], And(1 <= Count([ph:photographs], And(taken_by(ph) == p, Exists([s:sections], appears_in(ph, s)))), Count([ph:photographs], And(taken_by(ph) == p, Exists([s:sections], appears_in(ph, s)))) <= 3)) ::: For each photographer, at least one but no more than three of that photographers photographs must appear\nExists([ph:photographs], And(appears_in(ph, Lifestyle), Exists([ph2:photographs], And(taken_by(ph) == taken_by(ph2), appears_in(ph2, Metro))))) ::: At least one photograph in the Lifestyle section must be by a photographer who has at least one photograph in the Metro section\nCount([ph:photographs], And(taken_by(ph) == Hue, appears_in(ph, Lifestyle))) == Count([ph:photographs], And(taken_by(ph) == Fuentes, appears_in(ph, Sports))) ::: The number of Hue's photographs in the Lifestyle section must be the same as the number of Fuentes photographs in the Sports section\nForAll([ph:photographs], Implies(taken_by(ph) == Gagnon, Not(appears_in(ph, Sports)))) ::: None of Gagnon's photographs can be in the Sports section\nForAll([s:sections], Count([ph:photographs], appears_in(ph, s)) == 2) ::: exactly two photographs per section\n\n# Options\nQuestion ::: If one photograph in the Lifestyle section is by Gagnon and one is by Hue, then which one of the following must be true?\nAnd(Exists([ph:photographs], And(taken_by(ph) == Gagnon, appears_in(ph, Lifestyle))), Exists([ph:photographs], And(taken_by(ph) == Hue, appears_in(ph, Lifestyle)))) ::: If one photograph in the Lifestyle section is by Gagnon and one is by Hue\nis_valid(Count([ph:photographs], And(taken_by(ph) == Fuentes, appears_in(ph, Metro))) == 1) ::: (A)\nis_valid(Count([ph:photographs], And(taken_by(ph) == Gagnon, appears_in(ph, Metro))) == 1) ::: (B)\nis_valid(Count([ph:photographs], And(taken_by(ph) == Gagnon, appears_in(ph, Metro))) == 2) ::: (C)\nis_valid(Count([ph:photographs], And(taken_by(ph) == Hue, appears_in(ph, Sports))) == 1) ::: (D)\nis_valid(Count([ph:photographs], And(taken_by(ph) == Hue, appears_in(ph, Sports))) == 2) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201510_3-G_2_10",
    "context": "In the Lifestyle, Metro, and Sports sections of tomorrow's newspaper, a total of six different photographs are to appear, exactly two photographs per section. Each of the available photographs was taken by one of three photographers: Fuentes, Gagnon, and Hue. Selection of the photographs is constrained by the following conditions: For each photographer, at least one but no more than three of that photographers photographs must appear. At least one photograph in the Lifestyle section must be by a photographer who has at least one photograph in the Metro section. The number of Hue's photographs in the Lifestyle section must be the same as the number of Fuentes photographs in the Sports section. None of Gagnon's photographs can be in the Sports section.",
    "question": "Which one of the following could be true of the photographs by Fuentes appearing in tomorrows paper?",
    "answer": "A",
    "options": [
      "A) One is in the Lifestyle section, one is in the Metro section, and one is in the Sports section.",
      "B) One is in the Lifestyle section, and two are in the Sports section.",
      "C) Two are in the Lifestyle section, and one is in the Sports section.",
      "D) One is in the Metro section, and two are in the Sports section.",
      "E) Two are in the Metro section, and one is in the Sports section."
    ],
    "raw_logic_programs": [
      "# Declarations\nphotographers = EnumSort([Fuentes, Gagnon, Hue])\nsections = EnumSort([Lifestyle, Metro, Sports])\nphotographs = EnumSort([1, 2, 3, 4, 5, 6])\nin_section = Function([photographers, photographs, sections] -> [bool])\n\n# Constraints\nForAll([p:photographers], And(Count([ph:photographs, s:sections], in_section(p, ph, s)) >= 1, Count([ph:photographs, s:sections], in_section(p, ph, s)) <= 3)) ::: For each photographer, at least one but no more than three of that photographers photographs must appear\nExists([ph:photographs], And(in_section(Fuentes, ph, Lifestyle), Exists([ph2:photographs], in_section(Fuentes, ph2, Metro)))) ::: At least one photograph in the Lifestyle section must be by a photographer who has at least one photograph in the Metro section\nCount([ph:photographs], in_section(Hue, ph, Lifestyle)) == Count([ph:photographs], in_section(Fuentes, ph, Sports)) ::: The number of Hue's photographs in the Lifestyle section must be the same as the number of Fuentes photographs in the Sports section\nForAll([ph:photographs], Not(in_section(Gagnon, ph, Sports))) ::: None of Gagnon's photographs can be in the Sports section\nForAll([s:sections], Count([ph:photographs], in_section(Fuentes, ph, s)) <= 2) ::: Each section has exactly two photographs\nForAll([s:sections], Count([ph:photographs], in_section(Gagnon, ph, s)) <= 2) ::: Each section has exactly two photographs\nForAll([s:sections], Count([ph:photographs], in_section(Hue, ph, s)) <= 2) ::: Each section has exactly two photographs\n\n# Options\nQuestion ::: Which one of the following could be true of the photographs by Fuentes appearing in tomorrows paper?\nis_sat(And(Count([ph:photographs], in_section(Fuentes, ph, Lifestyle)) == 1, Count([ph:photographs], in_section(Fuentes, ph, Metro)) == 1, Count([ph:photographs], in_section(Fuentes, ph, Sports)) == 1)) ::: (A)\nis_sat(And(Count([ph:photographs], in_section(Fuentes, ph, Lifestyle)) == 1, Count([ph:photographs], in_section(Fuentes, ph, Sports)) == 2)) ::: (B)\nis_sat(And(Count([ph:photographs], in_section(Fuentes, ph, Lifestyle)) == 2, Count([ph:photographs], in_section(Fuentes, ph, Sports)) == 1)) ::: (C)\nis_sat(And(Count([ph:photographs], in_section(Fuentes, ph, Metro)) == 1, Count([ph:photographs], in_section(Fuentes, ph, Sports)) == 2)) ::: (D)\nis_sat(And(Count([ph:photographs], in_section(Fuentes, ph, Metro)) == 2, Count([ph:photographs], in_section(Fuentes, ph, Sports)) == 1)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201510_3-G_2_11",
    "context": "In the Lifestyle, Metro, and Sports sections of tomorrow's newspaper, a total of six different photographs are to appear, exactly two photographs per section. Each of the available photographs was taken by one of three photographers: Fuentes, Gagnon, and Hue. Selection of the photographs is constrained by the following conditions: For each photographer, at least one but no more than three of that photographers photographs must appear. At least one photograph in the Lifestyle section must be by a photographer who has at least one photograph in the Metro section. The number of Hue's photographs in the Lifestyle section must be the same as the number of Fuentes photographs in the Sports section. None of Gagnon's photographs can be in the Sports section.",
    "question": "If one photograph in the Lifestyle section is by Fuentes and one is by Hue, then which one of the following could be true?",
    "answer": "C",
    "options": [
      "A) Both photographs in the Metro section are by Fuentes.",
      "B) Both photographs in the Metro section are by Gagnon.",
      "C) Exactly one photograph in the Metro section is by Hue.",
      "D) Both photographs in the Sports section are by Hue.",
      "E) Neither photograph in the Sports section is by Hue."
    ],
    "raw_logic_programs": [
      "# Declarations\nphotographers = EnumSort([Fuentes, Gagnon, Hue])\nsections = EnumSort([Lifestyle, Metro, Sports])\nphotographs = EnumSort([1, 2, 3, 4, 5, 6])\nin_section = Function([photographers, sections, photographs] -> [bool])\n\n# Constraints\nForAll([p:photographers], And(Count([s:sections, ph:photographs], in_section(p, s, ph)) >= 1, Count([s:sections, ph:photographs], in_section(p, s, ph)) <= 3)) ::: For each photographer, at least one but no more than three of that photographers photographs must appear\nForAll([s:sections], Count([ph:photographs], Exists([p:photographers], in_section(p, s, ph))) == 2) ::: exactly two photographs per section\nExists([p:photographers, ph:photographs], And(in_section(p, Lifestyle, ph), in_section(p, Metro, ph))) ::: At least one photograph in the Lifestyle section must be by a photographer who has at least one photograph in the Metro section\nCount([ph:photographs], in_section(Hue, Lifestyle, ph)) == Count([ph:photographs], in_section(Fuentes, Sports, ph)) ::: The number of Hue's photographs in the Lifestyle section must be the same as the number of Fuentes photographs in the Sports section\nForAll([ph:photographs], Not(in_section(Gagnon, Sports, ph))) ::: None of Gagnon's photographs can be in the Sports section\nAnd(in_section(Fuentes, Lifestyle, 1), in_section(Hue, Lifestyle, 2)) ::: If one photograph in the Lifestyle section is by Fuentes and one is by Hue\n\n# Options\nQuestion ::: If one photograph in the Lifestyle section is by Fuentes and one is by Hue, then which one of the following could be true?\nis_sat(And(in_section(Fuentes, Metro, 3), in_section(Fuentes, Metro, 4))) ::: (A)\nis_sat(And(in_section(Gagnon, Metro, 3), in_section(Gagnon, Metro, 4))) ::: (B)\nis_sat(Or(in_section(Hue, Metro, 3), in_section(Hue, Metro, 4))) ::: (C)\nis_sat(And(in_section(Hue, Sports, 3), in_section(Hue, Sports, 4))) ::: (D)\nis_sat(And(Not(in_section(Hue, Sports, 3)), Not(in_section(Hue, Sports, 4)))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201510_3-G_2_12",
    "context": "In the Lifestyle, Metro, and Sports sections of tomorrow's newspaper, a total of six different photographs are to appear, exactly two photographs per section. Each of the available photographs was taken by one of three photographers: Fuentes, Gagnon, and Hue. Selection of the photographs is constrained by the following conditions: For each photographer, at least one but no more than three of that photographers photographs must appear. At least one photograph in the Lifestyle section must be by a photographer who has at least one photograph in the Metro section. The number of Hue's photographs in the Lifestyle section must be the same as the number of Fuentes photographs in the Sports section. None of Gagnon's photographs can be in the Sports section.",
    "question": "If both photographs in one of the three sections are by Gagnon, then which one of the following could be true?",
    "answer": "E",
    "options": [
      "A) Both photographs in the Lifestyle section are by Hue.",
      "B) One photograph in the Lifestyle section is by Fuentes and one is by Hue.",
      "C) Both photographs in the Metro section are by Fuentes.",
      "D) One photograph in the Metro section is by Gagnon and one is by Hue.",
      "E) Both photographs in the Sports section are by Hue."
    ],
    "raw_logic_programs": [
      "# Declarations\nsections = EnumSort([Lifestyle, Metro, Sports])\nphotographers = EnumSort([Fuentes, Gagnon, Hue])\nphotographs = EnumSort([1, 2, 3, 4, 5, 6])\nin_section = Function([photographers, sections, photographs] -> [bool])\n\n# Constraints\nForAll([p:photographers], And(Count([s:sections, ph:photographs], in_section(p, s, ph)) >= 1, Count([s:sections, ph:photographs], in_section(p, s, ph)) <= 3)) ::: For each photographer, at least one but no more than three of that photographers photographs must appear\nForAll([s:sections], Count([ph:photographs], Exists([p:photographers], in_section(p, s, ph))) == 2) ::: exactly two photographs per section\nExists([p:photographers, ph:photographs], And(in_section(p, Lifestyle, ph), in_section(p, Metro, ph))) ::: At least one photograph in the Lifestyle section must be by a photographer who has at least one photograph in the Metro section\nCount([ph:photographs], in_section(Hue, Lifestyle, ph)) == Count([ph:photographs], in_section(Fuentes, Sports, ph)) ::: The number of Hue's photographs in the Lifestyle section must be the same as the number of Fuentes photographs in the Sports section\nForAll([ph:photographs], Not(in_section(Gagnon, Sports, ph))) ::: None of Gagnon's photographs can be in the Sports section\n\n# Options\nQuestion ::: If both photographs in one of the three sections are by Gagnon, then which one of the following could be true?\nis_sat(And(ForAll([ph:photographs], Implies(in_section(Gagnon, Lifestyle, ph), True)), And(in_section(Hue, Lifestyle, 1), in_section(Hue, Lifestyle, 2)))) ::: (A)\nis_sat(And(ForAll([ph:photographs], Implies(in_section(Gagnon, Lifestyle, ph), True)), And(in_section(Fuentes, Lifestyle, 1), in_section(Hue, Lifestyle, 2)))) ::: (B)\nis_sat(And(ForAll([ph:photographs], Implies(in_section(Gagnon, Metro, ph), True)), And(in_section(Fuentes, Metro, 1), in_section(Fuentes, Metro, 2)))) ::: (C)\nis_sat(And(ForAll([ph:photographs], Implies(in_section(Gagnon, Metro, ph), True)), And(in_section(Gagnon, Metro, 1), in_section(Hue, Metro, 2)))) ::: (D)\nis_sat(And(ForAll([ph:photographs], Implies(in_section(Gagnon, Sports, ph), True)), And(in_section(Hue, Sports, 1), in_section(Hue, Sports, 2)))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201510_3-G_2_13",
    "context": "In the Lifestyle, Metro, and Sports sections of tomorrow's newspaper, a total of six different photographs are to appear, exactly two photographs per section. Each of the available photographs was taken by one of three photographers: Fuentes, Gagnon, and Hue. Selection of the photographs is constrained by the following conditions: For each photographer, at least one but no more than three of that photographers photographs must appear. At least one photograph in the Lifestyle section must be by a photographer who has at least one photograph in the Metro section. The number of Hue's photographs in the Lifestyle section must be the same as the number of Fuentes photographs in the Sports section. None of Gagnon's photographs can be in the Sports section.",
    "question": "If one photograph in the Metro section is by Fuentes and one is by Hue, then which one of the following could be true?",
    "answer": "C",
    "options": [
      "A) Both photographs in the Lifestyle section are by Fuentes.",
      "B) Both photographs in the Lifestyle section are by Gagnon.",
      "C) One photograph in the Lifestyle section is by Gagnon and one is by Hue.",
      "D) Both photographs in the Lifestyle section are by Hue.",
      "E) Both photographs in the Sports section are by Fuentes."
    ],
    "raw_logic_programs": [
      "# Declarations\nphotographers = EnumSort([Fuentes, Gagnon, Hue])\nsections = EnumSort([Lifestyle, Metro, Sports])\nphotographs = EnumSort([1, 2, 3, 4, 5, 6])\nin_section = Function([photographers, sections, photographs] -> [bool])\n\n# Constraints\nForAll([p:photographers], And(Count([s:sections, ph:photographs], in_section(p, s, ph)) >= 1, Count([s:sections, ph:photographs], in_section(p, s, ph)) <= 3)) ::: For each photographer, at least one but no more than three of that photographers photographs must appear\nExists([p:photographers, ph:photographs], And(in_section(p, Lifestyle, ph), in_section(p, Metro, ph))) ::: At least one photograph in the Lifestyle section must be by a photographer who has at least one photograph in the Metro section\nCount([ph:photographs], in_section(Hue, Lifestyle, ph)) == Count([ph:photographs], in_section(Fuentes, Sports, ph)) ::: The number of Hue's photographs in the Lifestyle section must be the same as the number of Fuentes photographs in the Sports section\nForAll([ph:photographs], Not(in_section(Gagnon, Sports, ph))) ::: None of Gagnon's photographs can be in the Sports section\nAnd(Count([ph:photographs], in_section(Fuentes, Metro, ph)) == 1, Count([ph:photographs], in_section(Hue, Metro, ph)) == 1) ::: If one photograph in the Metro section is by Fuentes and one is by Hue\n\n# Options\nQuestion ::: If one photograph in the Metro section is by Fuentes and one is by Hue, then which one of the following could be true?\nis_sat(And(Count([ph:photographs], in_section(Fuentes, Lifestyle, ph)) == 2, Count([ph:photographs], in_section(Gagnon, Lifestyle, ph)) == 0)) ::: (A)\nis_sat(And(Count([ph:photographs], in_section(Gagnon, Lifestyle, ph)) == 2, Count([ph:photographs], in_section(Fuentes, Lifestyle, ph)) == 0)) ::: (B)\nis_sat(And(Count([ph:photographs], in_section(Gagnon, Lifestyle, ph)) == 1, Count([ph:photographs], in_section(Hue, Lifestyle, ph)) == 1)) ::: (C)\nis_sat(And(Count([ph:photographs], in_section(Hue, Lifestyle, ph)) == 2, Count([ph:photographs], in_section(Gagnon, Lifestyle, ph)) == 0)) ::: (D)\nis_sat(And(Count([ph:photographs], in_section(Fuentes, Sports, ph)) == 2, Count([ph:photographs], in_section(Gagnon, Sports, ph)) == 0)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201510_3-G_3_14",
    "context": "Exactly five students—Grecia, Hakeem, Joe, Katya, and Louise—are to work at a campus art gallery during a special exhibit that runs for exactly five days, Monday through Friday. Each day is divided into two nonoverlapping shifts—first and second—with each student working exactly two shifts. Each shift is worked by exactly one of the students according to the following scheduling restrictions: No student works both shifts of any day. On two consecutive days, Louise works the second shift. On two nonconsecutive days, Grecia works the first shift. Katya works on Tuesday and Friday. Hakeem and Joe work on the same day as each other at least once. Grecia and Louise never work on the same day as each other.",
    "question": "Which one of the following could be the list of the students who work the second shifts at the gallery, in order from Monday through Friday?",
    "answer": "A",
    "options": [
      "A) Hakeem, Louise, Louise, Hakeem, Katya",
      "B) Joe, Hakeem, Grecia, Louise, Louise",
      "C) Joe, Katya, Hakeem, Louise, Katya",
      "D) Louise, Katya, Joe, Louise, Katya",
      "E) Louise, Louise, Hakeem, Joe, Joe"
    ],
    "raw_logic_programs": [
      "# Declarations\nstudents = EnumSort([Grecia, Hakeem, Joe, Katya, Louise])\ndays = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday])\nshifts = EnumSort([first, second])\nworks = Function([students, days, shifts] -> [bool])\n\n# Constraints\nForAll([s:students], Count([d:days, sh:shifts], works(s, d, sh)) == 2) ::: Each student works exactly two shifts\nForAll([d:days], Distinct([s:students], works(s, d, second))) ::: Each shift is worked by exactly one of the students\nForAll([s:students, d:days], Not(And(works(s, d, first), works(s, d, second)))) ::: No student works both shifts of any day\nExists([d1:days, d2:days], And(d1 != d2, And(works(Louise, d1, second), works(Louise, d2, second)))) ::: On two consecutive days, Louise works the second shift\nExists([d1:days, d2:days], And(d1 != d2, And(works(Grecia, d1, first), works(Grecia, d2, first)))) ::: On two nonconsecutive days, Grecia works the first shift\nAnd(works(Katya, Tuesday, first), works(Katya, Friday, first)) ::: Katya works on Tuesday and Friday\nExists([d:days], And(works(Hakeem, d, first), works(Joe, d, first))) ::: Hakeem and Joe work on the same day as each other at least once\nForAll([d:days], Not(And(works(Grecia, d, first), works(Louise, d, first)))) ::: Grecia and Louise never work on the same day as each other\n\n# Options\nQuestion ::: Which one of the following could be the list of the students who work the second shifts at the gallery, in order from Monday through Friday?\nis_valid(And(works(Hakeem, Monday, second), works(Louise, Tuesday, second), works(Louise, Wednesday, second), works(Hakeem, Thursday, second), works(Katya, Friday, second))) ::: (A)\nis_valid(And(works(Joe, Monday, second), works(Hakeem, Tuesday, second), works(Grecia, Wednesday, second), works(Louise, Thursday, second), works(Louise, Friday, second))) ::: (B)\nis_valid(And(works(Joe, Monday, second), works(Katya, Tuesday, second), works(Hakeem, Wednesday, second), works(Louise, Thursday, second), works(Katya, Friday, second))) ::: (C)\nis_valid(And(works(Louise, Monday, second), works(Katya, Tuesday, second), works(Joe, Wednesday, second), works(Louise, Thursday, second), works(Katya, Friday, second))) ::: (D)\nis_valid(And(works(Louise, Monday, second), works(Louise, Tuesday, second), works(Hakeem, Wednesday, second), works(Joe, Thursday, second), works(Joe, Friday, second))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201510_3-G_3_15",
    "context": "Exactly five students—Grecia, Hakeem, Joe, Katya, and Louise—are to work at a campus art gallery during a special exhibit that runs for exactly five days, Monday through Friday. Each day is divided into two nonoverlapping shifts—first and second—with each student working exactly two shifts. Each shift is worked by exactly one of the students according to the following scheduling restrictions: No student works both shifts of any day. On two consecutive days, Louise works the second shift. On two nonconsecutive days, Grecia works the first shift. Katya works on Tuesday and Friday. Hakeem and Joe work on the same day as each other at least once. Grecia and Louise never work on the same day as each other.",
    "question": "Which one of the following must be true?",
    "answer": "C",
    "options": [
      "A) Grecia does not work at the gallery on Tuesday.",
      "B) Hakeem does not work at the gallery on Wednesday.",
      "C) Joe does not work at the gallery on Tuesday.",
      "D) Joe does not work at the gallery on Thursday.",
      "E) Louise does not work at the gallery on Tuesday."
    ],
    "raw_logic_programs": [
      "# Declarations\nstudents = EnumSort([Grecia, Hakeem, Joe, Katya, Louise])\ndays = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday])\nshifts = EnumSort([first, second])\nworks = Function([students, days, shifts] -> [bool])\n\n# Constraints\nForAll([s:students], Count([d:days, sh:shifts], works(s, d, sh)) == 2) ::: Each student works exactly two shifts\nForAll([d:days], Distinct([s:students], Exists([sh:shifts], works(s, d, sh)))) ::: Each shift is worked by exactly one of the students\nForAll([s:students, d:days], Not(And(works(s, d, first), works(s, d, second)))) ::: No student works both shifts of any day\nExists([d:days], And(works(Louise, d, second), works(Louise, d + 1, second))) ::: On two consecutive days, Louise works the second shift\nExists([d1:days, d2:days], And(d1 != d2, And(works(Grecia, d1, first), works(Grecia, d2, first)))) ::: On two nonconsecutive days, Grecia works the first shift\nAnd(works(Katya, Tuesday, first), works(Katya, Friday, first)) ::: Katya works on Tuesday and Friday\nExists([d:days], And(works(Hakeem, d, first), works(Joe, d, first))) ::: Hakeem and Joe work on the same day as each other at least once\nForAll([d:days], Not(And(works(Grecia, d, first), works(Louise, d, first)))) ::: Grecia and Louise never work on the same day as each other\n\n# Options\nQuestion ::: Which one of the following must be true?\nis_valid(Not(works(Grecia, Tuesday, first))) ::: (A)\nis_valid(Not(works(Hakeem, Wednesday, first))) ::: (B)\nis_valid(Not(works(Joe, Tuesday, first))) ::: (C)\nis_valid(Not(works(Joe, Thursday, first))) ::: (D)\nis_valid(Not(works(Louise, Tuesday, first))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201510_3-G_3_16",
    "context": "Exactly five students—Grecia, Hakeem, Joe, Katya, and Louise—are to work at a campus art gallery during a special exhibit that runs for exactly five days, Monday through Friday. Each day is divided into two nonoverlapping shifts—first and second—with each student working exactly two shifts. Each shift is worked by exactly one of the students according to the following scheduling restrictions: No student works both shifts of any day. On two consecutive days, Louise works the second shift. On two nonconsecutive days, Grecia works the first shift. Katya works on Tuesday and Friday. Hakeem and Joe work on the same day as each other at least once. Grecia and Louise never work on the same day as each other.",
    "question": "If Hakeem works at the gallery on Wednesday, then Joe must work at the gallery on which one of the following pairs of days?",
    "answer": "B",
    "options": [
      "A) Monday and Wednesday",
      "B) Monday and Thursday",
      "C) Tuesday and Wednesday",
      "D) Tuesday and Thursday",
      "E) Wednesday and Thursday"
    ],
    "raw_logic_programs": [
      "# Declarations\nstudents = EnumSort([Grecia, Hakeem, Joe, Katya, Louise])\ndays = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday])\nshifts = EnumSort([first, second])\nworks = Function([students, days, shifts] -> [bool])\n\n# Constraints\nForAll([d:days], Count([s:students], Exists([sh:shifts], works(s, d, sh))) == 1) ::: Each shift is worked by exactly one of the students\nForAll([s:students], Count([d:days], Exists([sh:shifts], works(s, d, sh))) == 2) ::: Each student works exactly two shifts\nForAll([s:students, d:days], Implies(works(s, d, first), Not(works(s, d, second)))) ::: No student works both shifts of any day\nExists([d1:days, d2:days], And(d1 != d2, And(works(Louise, d1, second), works(Louise, d2, second)))) ::: On two consecutive days, Louise works the second shift\nExists([d1:days, d2:days], And(d1 != d2, And(works(Grecia, d1, first), works(Grecia, d2, first)))) ::: On two nonconsecutive days, Grecia works the first shift\nAnd(works(Katya, Tuesday, first), works(Katya, Friday, first)) ::: Katya works on Tuesday and Friday\nExists([d:days], And(works(Hakeem, d, first), works(Joe, d, first))) ::: Hakeem and Joe work on the same day as each other at least once\nForAll([d:days], Implies(works(Grecia, d, first), Not(works(Louise, d, first)))) ::: Grecia and Louise never work on the same day as each other\nworks(Hakeem, Wednesday, first) ::: If Hakeem works at the gallery on Wednesday\n\n# Options\nQuestion ::: If Hakeem works at the gallery on Wednesday, then Joe must work at the gallery on which one of the following pairs of days?\nis_valid(And(works(Joe, Monday, first), works(Joe, Wednesday, first))) ::: (A)\nis_valid(And(works(Joe, Monday, first), works(Joe, Thursday, first))) ::: (B)\nis_valid(And(works(Joe, Tuesday, first), works(Joe, Wednesday, first))) ::: (C)\nis_valid(And(works(Joe, Tuesday, first), works(Joe, Thursday, first))) ::: (D)\nis_valid(And(works(Joe, Wednesday, first), works(Joe, Thursday, first))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201510_3-G_3_17",
    "context": "Exactly five students—Grecia, Hakeem, Joe, Katya, and Louise—are to work at a campus art gallery during a special exhibit that runs for exactly five days, Monday through Friday. Each day is divided into two nonoverlapping shifts—first and second—with each student working exactly two shifts. Each shift is worked by exactly one of the students according to the following scheduling restrictions: No student works both shifts of any day. On two consecutive days, Louise works the second shift. On two nonconsecutive days, Grecia works the first shift. Katya works on Tuesday and Friday. Hakeem and Joe work on the same day as each other at least once. Grecia and Louise never work on the same day as each other.",
    "question": "If there is at least one day on which Grecia and Joe both work at the gallery, then which one of the following could be true?",
    "answer": "E",
    "options": [
      "A) Grecia works the first shift on Tuesday.",
      "B) Hakeem works the second shift on Monday.",
      "C) Hakeem works the second shift on Wednesday.",
      "D) Joe works the first shift on Wednesday.",
      "E) Joe works the first shift on Thursday."
    ],
    "raw_logic_programs": [
      "# Declarations\nstudents = EnumSort([Grecia, Hakeem, Joe, Katya, Louise])\ndays = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday])\nshifts = EnumSort([first, second])\nworks = Function([students, days, shifts] -> [bool])\n\n# Constraints\nForAll([d:days], Count([s:students], Exists([sh:shifts], works(s, d, sh))) == 1) ::: Each shift is worked by exactly one of the students\nForAll([s:students], Count([d:days], Exists([sh:shifts], works(s, d, sh))) == 2) ::: Each student works exactly two shifts\nForAll([s:students, d:days], Implies(works(s, d, first), Not(works(s, d, second)))) ::: No student works both shifts of any day\nExists([d1:days, d2:days], And(d1 != d2, And(works(Louise, d1, second), works(Louise, d2, second)))) ::: On two consecutive days, Louise works the second shift\nExists([d1:days, d2:days], And(d1 != d2, And(works(Grecia, d1, first), works(Grecia, d2, first)))) ::: On two nonconsecutive days, Grecia works the first shift\nAnd(works(Katya, Tuesday, first), works(Katya, Friday, first)) ::: Katya works on Tuesday and Friday\nExists([d:days], And(works(Hakeem, d, first), works(Joe, d, first))) ::: Hakeem and Joe work on the same day as each other at least once\nForAll([d:days], Implies(works(Grecia, d, first), Not(works(Louise, d, first)))) ::: Grecia and Louise never work on the same day as each other\nExists([d:days], And(works(Grecia, d, first), works(Joe, d, first))) ::: If there is at least one day on which Grecia and Joe both work at the gallery\n\n# Options\nQuestion ::: If there is at least one day on which Grecia and Joe both work at the gallery, then which one of the following could be true?\nis_sat(works(Grecia, Tuesday, first)) ::: (A)\nis_sat(works(Hakeem, Monday, second)) ::: (B)\nis_sat(works(Hakeem, Wednesday, second)) ::: (C)\nis_sat(works(Joe, Wednesday, first)) ::: (D)\nis_sat(works(Joe, Thursday, first)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201510_3-G_3_18",
    "context": "Exactly five students—Grecia, Hakeem, Joe, Katya, and Louise—are to work at a campus art gallery during a special exhibit that runs for exactly five days, Monday through Friday. Each day is divided into two nonoverlapping shifts—first and second—with each student working exactly two shifts. Each shift is worked by exactly one of the students according to the following scheduling restrictions: No student works both shifts of any day. On two consecutive days, Louise works the second shift. On two nonconsecutive days, Grecia works the first shift. Katya works on Tuesday and Friday. Hakeem and Joe work on the same day as each other at least once. Grecia and Louise never work on the same day as each other.",
    "question": "If Katya works the second shift on Tuesday at the gallery, then which one of the following could be true?",
    "answer": "B",
    "options": [
      "A) Grecia works the first shift on Monday.",
      "B) Hakeem works the first shift on Monday.",
      "C) Hakeem works the second shift on Wednesday.",
      "D) Joe works the second shift on Thursday.",
      "E) Louise works the second shift on Monday"
    ],
    "raw_logic_programs": [
      "# Declarations\nstudents = EnumSort([Grecia, Hakeem, Joe, Katya, Louise])\ndays = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday])\nshifts = EnumSort([first, second])\nworks = Function([students, days, shifts] -> [bool])\n\n# Constraints\nForAll([s:students], Count([d:days, sh:shifts], works(s, d, sh)) == 2) ::: Each student works exactly two shifts\nForAll([d:days], Distinct([s:students], works(s, d, first))) ::: No student works both shifts of any day\nForAll([d:days], Distinct([s:students], works(s, d, second))) ::: No student works both shifts of any day\nExists([d1:days, d2:days], And(d1 != d2, And(works(Louise, d1, second), works(Louise, d2, second)))) ::: On two consecutive days, Louise works the second shift\nExists([d1:days, d2:days], And(d1 != d2, And(works(Grecia, d1, first), works(Grecia, d2, first)))) ::: On two nonconsecutive days, Grecia works the first shift\nAnd(works(Katya, Tuesday, first), works(Katya, Friday, first)) ::: Katya works on Tuesday and Friday\nExists([d:days], And(works(Hakeem, d, first), works(Joe, d, first))) ::: Hakeem and Joe work on the same day as each other at least once\nForAll([d:days], Implies(works(Grecia, d, first), Not(works(Louise, d, first)))) ::: Grecia and Louise never work on the same day as each other\nForAll([d:days], Implies(works(Grecia, d, second), Not(works(Louise, d, second)))) ::: Grecia and Louise never work on the same day as each other\nworks(Katya, Tuesday, second) ::: If Katya works the second shift on Tuesday at the gallery\n\n# Options\nQuestion ::: If Katya works the second shift on Tuesday at the gallery, then which one of the following could be true?\nis_sat(works(Grecia, Monday, first)) ::: (A)\nis_sat(works(Hakeem, Monday, first)) ::: (B)\nis_sat(works(Hakeem, Wednesday, second)) ::: (C)\nis_sat(works(Joe, Thursday, second)) ::: (D)\nis_sat(works(Louise, Monday, second)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201510_3-G_3_19",
    "context": "Exactly five students—Grecia, Hakeem, Joe, Katya, and Louise—are to work at a campus art gallery during a special exhibit that runs for exactly five days, Monday through Friday. Each day is divided into two nonoverlapping shifts—first and second—with each student working exactly two shifts. Each shift is worked by exactly one of the students according to the following scheduling restrictions: No student works both shifts of any day. On two consecutive days, Louise works the second shift. On two nonconsecutive days, Grecia works the first shift. Katya works on Tuesday and Friday. Hakeem and Joe work on the same day as each other at least once. Grecia and Louise never work on the same day as each other.",
    "question": "Which one of the following is an acceptable schedule for the publication of the cookbooks?",
    "answer": "E",
    "options": [
      "A) fall: K, L, M, and O spring: N and P",
      "B) fall: K, L, N, and O spring: M and P",
      "C) fall: K, L, N, and P spring: M and O",
      "D) fall: K, M, N, and O spring: L and P",
      "E) fall: M and O spring: K, L, N, and P"
    ],
    "raw_logic_programs": [
      "# Declarations\nstudents = EnumSort([Grecia, Hakeem, Joe, Katya, Louise])\ndays = EnumSort([Monday, Tuesday, Wednesday, Thursday, Friday])\nshifts = EnumSort([first, second])\nworks = Function([students, days, shifts] -> [bool])\n\n# Constraints\nForAll([d:days], Count([s:students], works(s, d, first)) == 1) ::: Each shift is worked by exactly one of the students\nForAll([d:days], Count([s:students], works(s, d, second)) == 1) ::: Each shift is worked by exactly one of the students\nForAll([s:students, d:days], Not(And(works(s, d, first), works(s, d, second)))) ::: No student works both shifts of any day\nExists([d1:days, d2:days], And(d1 != d2, And(works(Louise, d1, second), works(Louise, d2, second)))) ::: On two consecutive days, Louise works the second shift\nExists([d1:days, d2:days], And(d1 != d2, And(works(Grecia, d1, first), works(Grecia, d2, first)))) ::: On two nonconsecutive days, Grecia works the first shift\nAnd(works(Katya, Tuesday, first), works(Katya, Friday, first)) ::: Katya works on Tuesday and Friday\nExists([d:days], And(works(Hakeem, d, first), works(Joe, d, first))) ::: Hakeem and Joe work on the same day as each other at least once\nForAll([d:days], Not(And(works(Grecia, d, first), works(Louise, d, first)))) ::: Grecia and Louise never work on the same day as each other\n\n# Options\nQuestion ::: Which one of the following is an acceptable schedule for the publication of the cookbooks?\nis_sat(And(works(Katya, Monday, first), works(Louise, Tuesday, second), works(Grecia, Wednesday, first), works(Joe, Thursday, first), works(Hakeem, Friday, first))) ::: (A)\nis_sat(And(works(Katya, Monday, first), works(Louise, Tuesday, second), works(Hakeem, Wednesday, first), works(Joe, Thursday, first), works(Grecia, Friday, first))) ::: (B)\nis_sat(And(works(Katya, Monday, first), works(Louise, Tuesday, second), works(Hakeem, Wednesday, first), works(Grecia, Thursday, first), works(Joe, Friday, first))) ::: (C)\nis_sat(And(works(Katya, Monday, first), works(Grecia, Tuesday, first), works(Hakeem, Wednesday, first), works(Joe, Thursday, first), works(Louise, Friday, first))) ::: (D)\nis_sat(And(works(Grecia, Monday, first), works(Joe, Tuesday, first), works(Hakeem, Wednesday, first), works(Louise, Thursday, second), works(Katya, Friday, first))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201510_3-G_4_20",
    "context": "A publisher is planning to publish six cookbooks—K, L, M, N, O, and P—over the course of the next year. Each cookbook will be published in one of two seasons—fall or spring—subject to the following conditions: M and P cannot be published in the same season as each other. K and N must be published in the same season as each other. If K is published in the fall, O must also be published in the fall. If M is published in the fall, N must be published in the spring",
    "question": "If M is published in the fall, which one of the following is a pair of cookbooks that could both be published in the fall along with M?",
    "answer": "C",
    "options": [
      "A) K and 0",
      "B) L and N",
      "C) L and 0",
      "D) N and P",
      "E) 0 and P"
    ],
    "raw_logic_programs": [
      "# Declarations\ncookbooks = EnumSort([K, L, M, N, O, P])\nseasons = EnumSort([fall, spring])\npublished = Function([cookbooks] -> [seasons])\n\n# Constraints\nNot(published(M) == published(P)) ::: M and P cannot be published in the same season as each other\npublished(K) == published(N) ::: K and N must be published in the same season as each other\nImplies(published(K) == fall, published(O) == fall) ::: If K is published in the fall, O must also be published in the fall\nImplies(published(M) == fall, published(N) == spring) ::: If M is published in the fall, N must be published in the spring\npublished(M) == fall ::: M is published in the fall\n\n# Options\nQuestion ::: If M is published in the fall, which one of the following is a pair of cookbooks that could both be published in the fall along with M?\nis_sat(And(published(K) == fall, published(O) == fall)) ::: (A)\nis_sat(And(published(L) == fall, published(N) == fall)) ::: (B)\nis_sat(And(published(L) == fall, published(O) == fall)) ::: (C)\nis_sat(And(published(N) == fall, published(P) == fall)) ::: (D)\nis_sat(And(published(O) == fall, published(P) == fall)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201510_3-G_4_21",
    "context": "A publisher is planning to publish six cookbooks—K, L, M, N, O, and P—over the course of the next year. Each cookbook will be published in one of two seasons—fall or spring—subject to the following conditions: M and P cannot be published in the same season as each other. K and N must be published in the same season as each other. If K is published in the fall, O must also be published in the fall. If M is published in the fall, N must be published in the spring",
    "question": "If N is published in the fall, which one of the following could be true",
    "answer": "B",
    "options": [
      "A) K is published in the spring.",
      "B) L is published in the fall.",
      "C) M is published in the fall.",
      "D) 0 is published in the spring.",
      "E) P is published in the spring."
    ],
    "raw_logic_programs": [
      "# Declarations\ncookbooks = EnumSort([K, L, M, N, O, P])\nseasons = EnumSort([fall, spring])\npublished = Function([cookbooks] -> [seasons])\n\n# Constraints\nNot(published(M) == published(P)) ::: M and P cannot be published in the same season as each other\npublished(K) == published(N) ::: K and N must be published in the same season as each other\nImplies(published(K) == fall, published(O) == fall) ::: If K is published in the fall, O must also be published in the fall\nImplies(published(M) == fall, published(N) == spring) ::: If M is published in the fall, N must be published in the spring\npublished(N) == fall ::: If N is published in the fall\n\n# Options\nQuestion ::: If N is published in the fall, which one of the following could be true\nis_sat(published(K) == spring) ::: (A)\nis_sat(published(L) == fall) ::: (B)\nis_sat(published(M) == fall) ::: (C)\nis_sat(published(O) == spring) ::: (D)\nis_sat(published(P) == spring) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201510_3-G_4_22",
    "context": "A publisher is planning to publish six cookbooks—K, L, M, N, O, and P—over the course of the next year. Each cookbook will be published in one of two seasons—fall or spring—subject to the following conditions: M and P cannot be published in the same season as each other. K and N must be published in the same season as each other. If K is published in the fall, O must also be published in the fall. If M is published in the fall, N must be published in the spring",
    "question": "The schedule for the publication of the cookbooks is fully determined if which one of the following is true?",
    "answer": "A",
    "options": [
      "A) K is published in the fall and L is published in the spring.",
      "B) 0 is published in the fall and P is published in the spring.",
      "C) P is published in the fall and L is published in the spring.",
      "D) Both K and L are published in the spring.",
      "E) Both M and L are published in the fall."
    ],
    "raw_logic_programs": [
      "# Declarations\ncookbooks = EnumSort([K, L, M, N, O, P])\nseasons = EnumSort([fall, spring])\npublished = Function([cookbooks] -> [seasons])\n\n# Constraints\nNot(published(M) == published(P)) ::: M and P cannot be published in the same season as each other\npublished(K) == published(N) ::: K and N must be published in the same season as each other\nImplies(published(K) == fall, published(O) == fall) ::: If K is published in the fall, O must also be published in the fall\nImplies(published(M) == fall, published(N) == spring) ::: If M is published in the fall, N must be published in the spring\n\n# Options\nQuestion ::: The schedule for the publication of the cookbooks is fully determined if which one of the following is true?\nis_determined(And(published(K) == fall, published(L) == spring)) ::: (A)\nis_determined(And(published(O) == fall, published(P) == spring)) ::: (B)\nis_determined(And(published(P) == fall, published(L) == spring)) ::: (C)\nis_determined(And(published(K) == spring, published(L) == spring)) ::: (D)\nis_determined(And(published(M) == fall, published(L) == fall)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201510_3-G_4_23",
    "context": "A publisher is planning to publish six cookbooks—K, L, M, N, O, and P—over the course of the next year. Each cookbook will be published in one of two seasons—fall or spring—subject to the following conditions: M and P cannot be published in the same season as each other. K and N must be published in the same season as each other. If K is published in the fall, O must also be published in the fall. If M is published in the fall, N must be published in the spring",
    "question": "Which one of the following, if substituted for the condition that if M is published in the fall, N must be published in the spring, would have the same effect in determining the schedule for the publication of the cookbooks?",
    "answer": "B",
    "options": [
      "A) If L is published in the fall, M must be published in the spring.",
      "B) If N is published in the fall, P must also be published in the fall.",
      "C) If M is published in the spring, P must be published in the fall.",
      "D) If N is published in the spring, M must also be published in the spring.",
      "E) If 0 is published in the spring, N must also be published in the spring."
    ],
    "raw_logic_programs": [
      "# Declarations\ncookbooks = EnumSort([K, L, M, N, O, P])\nseasons = EnumSort([fall, spring])\npublished = Function([cookbooks] -> [seasons])\n\n# Constraints\nNot(published(M) == published(P)) ::: M and P cannot be published in the same season as each other\npublished(K) == published(N) ::: K and N must be published in the same season as each other\nImplies(published(K) == fall, published(O) == fall) ::: If K is published in the fall, O must also be published in the fall\nImplies(published(M) == fall, published(N) == spring) ::: If M is published in the fall, N must be published in the spring\n\n# Options\nQuestion ::: Which one of the following, if substituted for the condition that if M is published in the fall, N must be published in the spring, would have the same effect in determining the schedule for the publication of the cookbooks?\nis_equivalent(Implies(published(L) == fall, published(M) == spring), Implies(published(M) == fall, published(N) == spring)) ::: (A)\nis_equivalent(Implies(published(N) == fall, published(P) == fall), Implies(published(M) == fall, published(N) == spring)) ::: (B)\nis_equivalent(Implies(published(M) == spring, published(P) == fall), Implies(published(M) == fall, published(N) == spring)) ::: (C)\nis_equivalent(Implies(published(N) == spring, published(M) == spring), Implies(published(M) == fall, published(N) == spring)) ::: (D)\nis_equivalent(Implies(published(O) == spring, published(N) == spring), Implies(published(M) == fall, published(N) == spring)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201606_2-G_1_1",
    "context": "Seven workers—Quinn, Ruiz, Smith, Taylor, Verma, Wells, and Xue—are being considered for a special project. Exactly three of the workers will be selected to be project members, and exactly one of these project members will be the project leader. The selection is subject to the following constraints: Quinn or Ruiz can be a project member only if leading the project. If Smith is a project member, Taylor must also be. If Wells is a project member, neither Ruiz nor Verma can be.",
    "question": "Which one of the following is an acceptable selection for the project?",
    "answer": "C",
    "options": [
      "A) Ruiz (leader), Taylor, Wells",
      "B) Verma (leader), Quinn, Taylor",
      "C) Verma (leader), Smith, Taylor",
      "D) Verma (leader), Smith, Xue",
      "E) Xue (leader), Verma, Wells"
    ],
    "raw_logic_programs": [
      "# Declarations\nworkers = EnumSort([Quinn, Ruiz, Smith, Taylor, Verma, Wells, Xue])\nproject_member = Function([workers] -> [bool])\nproject_leader = Function([workers] -> [bool])\n\n# Constraints\nCount([w:workers], project_member(w)) == 3 ::: Exactly three of the workers will be selected to be project members\nCount([w:workers], project_leader(w)) == 1 ::: Exactly one of these project members will be the project leader\nForAll([w:workers], Implies(project_member(w), project_leader(w))) ::: If a worker is a project member, they are also the project leader\nImplies(project_member(Quinn), project_leader(Quinn)) ::: Quinn or Ruiz can be a project member only if leading the project\nImplies(project_member(Ruiz), project_leader(Ruiz)) ::: Quinn or Ruiz can be a project member only if leading the project\nImplies(project_member(Smith), project_member(Taylor)) ::: If Smith is a project member, Taylor must also be\nImplies(project_member(Wells), Not(project_member(Ruiz))) ::: If Wells is a project member, neither Ruiz nor Verma can be\nImplies(project_member(Wells), Not(project_member(Verma))) ::: If Wells is a project member, neither Ruiz nor Verma can be\n\n# Options\nQuestion ::: Which one of the following is an acceptable selection for the project?\nis_sat(And(project_leader(Ruiz), project_member(Taylor), project_member(Wells))) ::: (A)\nis_sat(And(project_leader(Verma), project_member(Quinn), project_member(Taylor))) ::: (B)\nis_sat(And(project_leader(Verma), project_member(Smith), project_member(Taylor))) ::: (C)\nis_sat(And(project_leader(Verma), project_member(Smith), project_member(Xue))) ::: (D)\nis_sat(And(project_leader(Xue), project_member(Verma), project_member(Wells))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201606_2-G_1_2",
    "context": "Seven workers—Quinn, Ruiz, Smith, Taylor, Verma, Wells, and Xue—are being considered for a special project. Exactly three of the workers will be selected to be project members, and exactly one of these project members will be the project leader. The selection is subject to the following constraints: Quinn or Ruiz can be a project member only if leading the project. If Smith is a project member, Taylor must also be. If Wells is a project member, neither Ruiz nor Verma can be.",
    "question": "If Taylor is the project leader and Wells is a project member, then the third project member must be either",
    "answer": "D",
    "options": [
      "A) Quinn or Smith",
      "B) Quinn or Xue",
      "C) Ruiz or Verma",
      "D) Smith or Xue",
      "E) Verma or Xue"
    ],
    "raw_logic_programs": [
      "# Declarations\nworkers = EnumSort([Quinn, Ruiz, Smith, Taylor, Verma, Wells, Xue])\nproject_member = Function([workers] -> [bool])\nproject_leader = Function([workers] -> [bool])\n\n# Constraints\nCount([w:workers], project_member(w)) == 3 ::: Exactly three of the workers will be selected to be project members\nCount([w:workers], project_leader(w)) == 1 ::: Exactly one of these project members will be the project leader\nForAll([w:workers], Implies(Or(w == Quinn, w == Ruiz), Implies(project_member(w), project_leader(w)))) ::: Quinn or Ruiz can be a project member only if leading the project\nForAll([w:workers], Implies(project_member(Smith), project_member(Taylor))) ::: If Smith is a project member, Taylor must also be\nForAll([w:workers], Implies(project_member(Wells), Not(Or(project_member(Ruiz), project_member(Verma))))) ::: If Wells is a project member, neither Ruiz nor Verma can be\nproject_leader(Taylor) ::: Taylor is the project leader\nproject_member(Wells) ::: Wells is a project member\n\n# Options\nQuestion ::: If Taylor is the project leader and Wells is a project member, then the third project member must be either\nis_valid(Or(project_member(Quinn), project_member(Smith))) ::: (A)\nis_valid(Or(project_member(Quinn), project_member(Xue))) ::: (B)\nis_valid(Or(project_member(Ruiz), project_member(Verma))) ::: (C)\nis_valid(Or(project_member(Smith), project_member(Xue))) ::: (D)\nis_valid(Or(project_member(Verma), project_member(Xue))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201606_2-G_1_3",
    "context": "Seven workers—Quinn, Ruiz, Smith, Taylor, Verma, Wells, and Xue—are being considered for a special project. Exactly three of the workers will be selected to be project members, and exactly one of these project members will be the project leader. The selection is subject to the following constraints: Quinn or Ruiz can be a project member only if leading the project. If Smith is a project member, Taylor must also be. If Wells is a project member, neither Ruiz nor Verma can be.",
    "question": "Verma could be the project leader if which one of the following is true?",
    "answer": "A",
    "options": [
      "A) Neither Quinn nor Smith is selected.",
      "B) Neither Ruiz nor Taylor is selected.",
      "C) Neither Smith nor Taylor is selected.",
      "D) Neither Smith nor Xue is selected.",
      "E) Neither Taylor nor Wells is selected."
    ],
    "raw_logic_programs": [
      "# Declarations\nworkers = EnumSort([Quinn, Ruiz, Smith, Taylor, Verma, Wells, Xue])\nproject_member = Function([workers] -> [bool])\nproject_leader = Function([workers] -> [bool])\n\n# Constraints\nCount([w:workers], project_member(w)) == 3 ::: Exactly three of the workers will be selected to be project members\nCount([w:workers], project_leader(w)) == 1 ::: Exactly one of these project members will be the project leader\nForAll([w:workers], Implies(project_member(w), project_leader(w))) ::: If a worker is a project member, they are also the project leader\nImplies(Or(project_member(Quinn), project_member(Ruiz)), And(project_member(Quinn), project_leader(Quinn))) ::: Quinn or Ruiz can be a project member only if leading the project\nImplies(project_member(Smith), project_member(Taylor)) ::: If Smith is a project member, Taylor must also be\nImplies(project_member(Wells), Not(Or(project_member(Ruiz), project_member(Verma)))) ::: If Wells is a project member, neither Ruiz nor Verma can be\n\n# Options\nQuestion ::: Verma could be the project leader if which one of the following is true?\nis_sat(And(project_leader(Verma), Not(project_member(Quinn)), Not(project_member(Smith)))) ::: (A)\nis_sat(And(project_leader(Verma), Not(project_member(Ruiz)), Not(project_member(Taylor)))) ::: (B)\nis_sat(And(project_leader(Verma), Not(project_member(Smith)), Not(project_member(Taylor)))) ::: (C)\nis_sat(And(project_leader(Verma), Not(project_member(Smith)), Not(project_member(Xue)))) ::: (D)\nis_sat(And(project_leader(Verma), Not(project_member(Taylor)), Not(project_member(Wells)))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201606_2-G_1_4",
    "context": "Seven workers—Quinn, Ruiz, Smith, Taylor, Verma, Wells, and Xue—are being considered for a special project. Exactly three of the workers will be selected to be project members, and exactly one of these project members will be the project leader. The selection is subject to the following constraints: Quinn or Ruiz can be a project member only if leading the project. If Smith is a project member, Taylor must also be. If Wells is a project member, neither Ruiz nor Verma can be.",
    "question": "If Taylor is not a project member, which one of the following workers must be a project member?",
    "answer": "E",
    "options": [
      "A) Quinn",
      "B) Ruiz",
      "C) Verma",
      "D) Wells",
      "E) Xue"
    ],
    "raw_logic_programs": [
      "# Declarations\nworkers = EnumSort([Quinn, Ruiz, Smith, Taylor, Verma, Wells, Xue])\nproject_member = Function([workers] -> [bool])\nproject_leader = Function([workers] -> [bool])\n\n# Constraints\nCount([w:workers], project_member(w)) == 3 ::: Exactly three of the workers will be selected to be project members\nCount([w:workers], project_leader(w)) == 1 ::: Exactly one of these project members will be the project leader\nForAll([w:workers], Implies(project_member(w), Or(w == Quinn, w == Ruiz, w == Smith, w == Taylor, w == Verma, w == Wells, w == Xue))) ::: All project members must be one of the seven workers\nForAll([w:workers], Implies(project_leader(w), project_member(w))) ::: The project leader must be a project member\nImplies(Or(project_member(Quinn), project_member(Ruiz)), project_leader(Quinn) == project_member(Quinn)) ::: Quinn or Ruiz can be a project member only if leading the project\nImplies(project_member(Smith), project_member(Taylor)) ::: If Smith is a project member, Taylor must also be\nImplies(project_member(Wells), Not(Or(project_member(Ruiz), project_member(Verma)))) ::: If Wells is a project member, neither Ruiz nor Verma can be\nNot(project_member(Taylor)) ::: Taylor is not a project member\n\n# Options\nQuestion ::: If Taylor is not a project member, which one of the following workers must be a project member?\nis_valid(project_member(Quinn)) ::: (A)\nis_valid(project_member(Ruiz)) ::: (B)\nis_valid(project_member(Verma)) ::: (C)\nis_valid(project_member(Wells)) ::: (D)\nis_valid(project_member(Xue)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201606_2-G_1_5",
    "context": "Seven workers—Quinn, Ruiz, Smith, Taylor, Verma, Wells, and Xue—are being considered for a special project. Exactly three of the workers will be selected to be project members, and exactly one of these project members will be the project leader. The selection is subject to the following constraints: Quinn or Ruiz can be a project member only if leading the project. If Smith is a project member, Taylor must also be. If Wells is a project member, neither Ruiz nor Verma can be.",
    "question": "The selection for the project is completely determined if which one of the following is true?",
    "answer": "B",
    "options": [
      "A) Neither Quinn nor Smith is selected.",
      "B) Neither Quinn nor Taylor is selected.",
      "C) Neither Quinn nor Xue is selected.",
      "D) Neither Ruiz nor Wells is selected.",
      "E) Neither Ruiz nor Verma is selected."
    ],
    "raw_logic_programs": [
      "# Declarations\nworkers = EnumSort([Quinn, Ruiz, Smith, Taylor, Verma, Wells, Xue])\nproject_member = Function([workers] -> [bool])\nproject_leader = Function([workers] -> [bool])\n\n# Constraints\nCount([w:workers], project_member(w)) == 3 ::: Exactly three of the workers will be selected to be project members\nCount([w:workers], project_leader(w)) == 1 ::: Exactly one of these project members will be the project leader\nForAll([w:workers], Implies(project_member(w), project_leader(w))) ::: If a worker is a project member, they are also the project leader\nImplies(Or(project_member(Quinn), project_member(Ruiz)), And(project_leader(Quinn), project_leader(Ruiz))) ::: Quinn or Ruiz can be a project member only if leading the project\nImplies(project_member(Smith), project_member(Taylor)) ::: If Smith is a project member, Taylor must also be\nImplies(project_member(Wells), Not(Or(project_member(Ruiz), project_member(Verma)))) ::: If Wells is a project member, neither Ruiz nor Verma can be\n\n# Options\nQuestion ::: The selection for the project is completely determined if which one of the following is true?\nis_determined(And(Not(project_member(Quinn)), Not(project_member(Smith)))) ::: (A)\nis_determined(And(Not(project_member(Quinn)), Not(project_member(Taylor)))) ::: (B)\nis_determined(And(Not(project_member(Quinn)), Not(project_member(Xue)))) ::: (C)\nis_determined(And(Not(project_member(Ruiz)), Not(project_member(Wells)))) ::: (D)\nis_determined(And(Not(project_member(Ruiz)), Not(project_member(Verma)))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201606_2-G_2_6",
    "context": "Four students will be assigned to a history project in which they will search archives from the years 1921, 1922, 1923, and 1924. Each of the four years will have exactly one student assigned to it. Six students—Louis, Mollie, Onyx, Ryan, Tiffany, and Yoshio—are available for this project. The following conditions apply: Only Louis or Tiffany can be assigned to 1923. If Mollie is assigned to the project, then she must be assigned to either 1921 or 1922. If Tiffany is assigned to the project, then Ryan must be assigned to the project. If Ryan is assigned to the project, then Onyx must be assigned to the year immediately prior to Ryan's.",
    "question": "Which one of the following could be an accurate assignment of students, in order from the earliest year to the latest?",
    "answer": "C",
    "options": [
      "A) Louis, Onyx, Ryan, Yoshio",
      "B) Mollie, Yoshio, Tiffany, Onyx",
      "C) Onyx, Ryan, Louis, Tiffany",
      "D) Tiffany, Onyx, Louis, Ryan",
      "E) Yoshio, Onyx, Louis, Mollie"
    ],
    "raw_logic_programs": [
      "# Declarations\nstudents = EnumSort([Louis, Mollie, Onyx, Ryan, Tiffany, Yoshio])\nyears = EnumSort([1921, 1922, 1923, 1924])\nassigned = Function([students] -> [years])\n\n# Constraints\nForAll([y:years], Exists([s:students], assigned(s) == y)) ::: Each of the four years will have exactly one student assigned to it\nForAll([s:students], Count([y:years], assigned(s) == y) <= 1) ::: Each student will be assigned to at most one year\nOr(assigned(Louis) == 1923, assigned(Tiffany) == 1923) ::: Only Louis or Tiffany can be assigned to 1923\nImplies(assigned(Mollie) != None, Or(assigned(Mollie) == 1921, assigned(Mollie) == 1922)) ::: If Mollie is assigned to the project, then she must be assigned to either 1921 or 1922\nImplies(assigned(Tiffany) != None, assigned(Ryan) != None) ::: If Tiffany is assigned to the project, then Ryan must be assigned to the project\nImplies(assigned(Ryan) != None, Exists([y:years], And(assigned(Ryan) == y, assigned(Onyx) == y - 1))) ::: If Ryan is assigned to the project, then Onyx must be assigned to the year immediately prior to Ryan's\n\n# Options\nQuestion ::: Which one of the following could be an accurate assignment of students, in order from the earliest year to the latest?\nis_sat(And(assigned(Louis) == 1921, assigned(Onyx) == 1922, assigned(Ryan) == 1923, assigned(Yoshio) == 1924)) ::: (A)\nis_sat(And(assigned(Mollie) == 1921, assigned(Yoshio) == 1922, assigned(Tiffany) == 1923, assigned(Onyx) == 1924)) ::: (B)\nis_sat(And(assigned(Onyx) == 1921, assigned(Ryan) == 1922, assigned(Louis) == 1923, assigned(Tiffany) == 1924)) ::: (C)\nis_sat(And(assigned(Tiffany) == 1921, assigned(Onyx) == 1922, assigned(Louis) == 1923, assigned(Ryan) == 1924)) ::: (D)\nis_sat(And(assigned(Yoshio) == 1921, assigned(Onyx) == 1922, assigned(Louis) == 1923, assigned(Mollie) == 1924)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201606_2-G_2_7",
    "context": "Four students will be assigned to a history project in which they will search archives from the years 1921, 1922, 1923, and 1924. Each of the four years will have exactly one student assigned to it. Six students—Louis, Mollie, Onyx, Ryan, Tiffany, and Yoshio—are available for this project. The following conditions apply: Only Louis or Tiffany can be assigned to 1923. If Mollie is assigned to the project, then she must be assigned to either 1921 or 1922. If Tiffany is assigned to the project, then Ryan must be assigned to the project. If Ryan is assigned to the project, then Onyx must be assigned to the year immediately prior to Ryan's.",
    "question": "Mollie must be assigned to 1922 if which one of the following is true?",
    "answer": "E",
    "options": [
      "A) Louis is assigned to 1924.",
      "B) Onyx is assigned to 1921.",
      "C) Onyx is assigned to 1924.",
      "D) Tiffany is assigned to 1923.",
      "E) Yoshio is assigned to 1921."
    ],
    "raw_logic_programs": [
      "# Declarations\nstudents = EnumSort([Louis, Mollie, Onyx, Ryan, Tiffany, Yoshio])\nyears = EnumSort([1921, 1922, 1923, 1924])\nassigned = Function([students] -> [years])\n\n# Constraints\nForAll([y:years], Exists([s:students], assigned(s) == y)) ::: Each of the four years will have exactly one student assigned to it\nOr(assigned(Louis) == 1923, assigned(Tiffany) == 1923) ::: Only Louis or Tiffany can be assigned to 1923\nImplies(assigned(Mollie) != None, Or(assigned(Mollie) == 1921, assigned(Mollie) == 1922)) ::: If Mollie is assigned to the project, then she must be assigned to either 1921 or 1922\nImplies(assigned(Tiffany) != None, assigned(Ryan) != None) ::: If Tiffany is assigned to the project, then Ryan must be assigned to the project\nImplies(assigned(Ryan) != None, Exists([y:years], And(assigned(Onyx) == y, assigned(Ryan) == y + 1))) ::: If Ryan is assigned to the project, then Onyx must be assigned to the year immediately prior to Ryan's\n\n# Options\nQuestion ::: Mollie must be assigned to 1922 if which one of the following is true?\nis_sat(And(assigned(Louis) == 1924, assigned(Mollie) == 1922)) ::: (A)\nis_sat(And(assigned(Onyx) == 1921, assigned(Mollie) == 1922)) ::: (B)\nis_sat(And(assigned(Onyx) == 1924, assigned(Mollie) == 1922)) ::: (C)\nis_sat(And(assigned(Tiffany) == 1923, assigned(Mollie) == 1922)) ::: (D)\nis_sat(And(assigned(Yoshio) == 1921, assigned(Mollie) == 1922)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201606_2-G_2_8",
    "context": "Four students will be assigned to a history project in which they will search archives from the years 1921, 1922, 1923, and 1924. Each of the four years will have exactly one student assigned to it. Six students—Louis, Mollie, Onyx, Ryan, Tiffany, and Yoshio—are available for this project. The following conditions apply: Only Louis or Tiffany can be assigned to 1923. If Mollie is assigned to the project, then she must be assigned to either 1921 or 1922. If Tiffany is assigned to the project, then Ryan must be assigned to the project. If Ryan is assigned to the project, then Onyx must be assigned to the year immediately prior to Ryan's.",
    "question": "If both Ryan and Yoshio are assigned to the project, which one of the following could be true?",
    "answer": "A",
    "options": [
      "A) Louis is assigned to 1923.",
      "B) Mollie is assigned to 1921.",
      "C) Onyx is assigned to 1922.",
      "D) Tiffany is assigned to 1924.",
      "E) Yoshio is assigned to 1922."
    ],
    "raw_logic_programs": [
      "# Declarations\nstudents = EnumSort([Louis, Mollie, Onyx, Ryan, Tiffany, Yoshio])\nyears = EnumSort([1921, 1922, 1923, 1924])\nassigned = Function([students] -> [years])\n\n# Constraints\nForAll([y:years], Exists([s:students], assigned(s) == y)) ::: Each of the four years will have exactly one student assigned to it\nForAll([s:students], Count([y:years], assigned(s) == y) <= 1) ::: Each student will be assigned to at most one year\nOr(assigned(Louis) == 1923, assigned(Tiffany) == 1923) ::: Only Louis or Tiffany can be assigned to 1923\nImplies(assigned(Mollie) != None, Or(assigned(Mollie) == 1921, assigned(Mollie) == 1922)) ::: If Mollie is assigned to the project, then she must be assigned to either 1921 or 1922\nImplies(assigned(Tiffany) != None, assigned(Ryan) != None) ::: If Tiffany is assigned to the project, then Ryan must be assigned to the project\nImplies(assigned(Ryan) != None, Exists([y:years], And(assigned(Ryan) == y, assigned(Onyx) == y - 1))) ::: If Ryan is assigned to the project, then Onyx must be assigned to the year immediately prior to Ryan's\nAnd(assigned(Ryan) != None, assigned(Yoshio) != None) ::: If both Ryan and Yoshio are assigned to the project\n\n# Options\nQuestion ::: Which one of the following could be true?\nis_sat(assigned(Louis) == 1923) ::: (A)\nis_sat(assigned(Mollie) == 1921) ::: (B)\nis_sat(assigned(Onyx) == 1922) ::: (C)\nis_sat(assigned(Tiffany) == 1924) ::: (D)\nis_sat(assigned(Yoshio) == 1922) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201606_2-G_2_9",
    "context": "Four students will be assigned to a history project in which they will search archives from the years 1921, 1922, 1923, and 1924. Each of the four years will have exactly one student assigned to it. Six students—Louis, Mollie, Onyx, Ryan, Tiffany, and Yoshio—are available for this project. The following conditions apply: Only Louis or Tiffany can be assigned to 1923. If Mollie is assigned to the project, then she must be assigned to either 1921 or 1922. If Tiffany is assigned to the project, then Ryan must be assigned to the project. If Ryan is assigned to the project, then Onyx must be assigned to the year immediately prior to Ryan's.",
    "question": "How many of the students are there who could be the one assigned to 1921?",
    "answer": "D",
    "options": [
      "A) six",
      "B) five",
      "C) four",
      "D) three",
      "E) two"
    ],
    "raw_logic_programs": [
      "# Declarations\nstudents = EnumSort([Louis, Mollie, Onyx, Ryan, Tiffany, Yoshio])\nyears = EnumSort([1921, 1922, 1923, 1924])\nassigned = Function([students] -> [years])\n\n# Constraints\nForAll([y:years], Exists([s:students], assigned(s) == y)) ::: Each of the four years will have exactly one student assigned to it\nForAll([s:students], Count([y:years], assigned(s) == y) <= 1) ::: Each student will be assigned to at most one year\nOr(assigned(Louis) == 1923, assigned(Tiffany) == 1923) ::: Only Louis or Tiffany can be assigned to 1923\nImplies(assigned(Mollie) != None, Or(assigned(Mollie) == 1921, assigned(Mollie) == 1922)) ::: If Mollie is assigned to the project, then she must be assigned to either 1921 or 1922\nImplies(assigned(Tiffany) != None, assigned(Ryan) != None) ::: If Tiffany is assigned to the project, then Ryan must be assigned to the project\nImplies(assigned(Ryan) != None, Exists([y:years], And(assigned(Ryan) == y, assigned(Onyx) == y - 1))) ::: If Ryan is assigned to the project, then Onyx must be assigned to the year immediately prior to Ryan's\n\n# Options\nQuestion ::: How many of the students are there who could be the one assigned to 1921?\nis_valid(assigned(Louis) == 1921) ::: Louis\nis_valid(assigned(Mollie) == 1921) ::: Mollie\nis_valid(assigned(Onyx) == 1921) ::: Onyx\nis_valid(assigned(Ryan) == 1921) ::: Ryan\nis_valid(assigned(Tiffany) == 1921) ::: Tiffany\nis_valid(assigned(Yoshio) == 1921) ::: Yoshio\n"
    ]
  },
  {
    "id": "ar_lsat_201606_2-G_2_10",
    "context": "Four students will be assigned to a history project in which they will search archives from the years 1921, 1922, 1923, and 1924. Each of the four years will have exactly one student assigned to it. Six students—Louis, Mollie, Onyx, Ryan, Tiffany, and Yoshio—are available for this project. The following conditions apply: Only Louis or Tiffany can be assigned to 1923. If Mollie is assigned to the project, then she must be assigned to either 1921 or 1922. If Tiffany is assigned to the project, then Ryan must be assigned to the project. If Ryan is assigned to the project, then Onyx must be assigned to the year immediately prior to Ryan's.",
    "question": "If Yoshio is not assigned to the project, which one of the following could be true?",
    "answer": "E",
    "options": [
      "A) Louis is not assigned to the project.",
      "B) Ryan is not assigned to the project.",
      "C) Tiffany is not assigned to the project.",
      "D) Onyx is assigned to 1922.",
      "E) Louis is assigned to 1924."
    ],
    "raw_logic_programs": [
      "# Declarations\nstudents = EnumSort([Louis, Mollie, Onyx, Ryan, Tiffany, Yoshio])\nyears = EnumSort([1921, 1922, 1923, 1924])\nassigned = Function([students, years] -> [bool])\n\n# Constraints\nForAll([y:years], Count([s:students], assigned(s, y)) == 1) ::: Each of the four years will have exactly one student assigned to it\nOr(assigned(Louis, 1923), assigned(Tiffany, 1923)) ::: Only Louis or Tiffany can be assigned to 1923\nImplies(assigned(Mollie, 1921), assigned(Mollie, 1921)) ::: If Mollie is assigned to the project, then she must be assigned to either 1921 or 1922\nImplies(assigned(Mollie, 1922), assigned(Mollie, 1922)) ::: If Mollie is assigned to the project, then she must be assigned to either 1921 or 1922\nImplies(assigned(Tiffany, 1921), assigned(Ryan, 1921)) ::: If Tiffany is assigned to the project, then Ryan must be assigned to the project\nImplies(assigned(Tiffany, 1922), assigned(Ryan, 1922)) ::: If Tiffany is assigned to the project, then Ryan must be assigned to the project\nImplies(assigned(Tiffany, 1923), assigned(Ryan, 1923)) ::: If Tiffany is assigned to the project, then Ryan must be assigned to the project\nImplies(assigned(Tiffany, 1924), assigned(Ryan, 1924)) ::: If Tiffany is assigned to the project, then Ryan must be assigned to the project\nForAll([y:years], Implies(assigned(Ryan, y), Exists([y1:years], And(y1 == y - 1, assigned(Onyx, y1))))) ::: If Ryan is assigned to the project, then Onyx must be assigned to the year immediately prior to Ryan's\nNot(assigned(Yoshio, 1921)) ::: Yoshio is not assigned to the project\nNot(assigned(Yoshio, 1922)) ::: Yoshio is not assigned to the project\nNot(assigned(Yoshio, 1923)) ::: Yoshio is not assigned to the project\nNot(assigned(Yoshio, 1924)) ::: Yoshio is not assigned to the project\n\n# Options\nQuestion ::: If Yoshio is not assigned to the project, which one of the following could be true?\nis_sat(Not(assigned(Louis, 1921))) ::: (A)\nis_sat(Not(assigned(Ryan, 1921))) ::: (B)\nis_sat(Not(assigned(Tiffany, 1921))) ::: (C)\nis_sat(assigned(Onyx, 1922)) ::: (D)\nis_sat(assigned(Louis, 1924)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201606_2-G_2_11",
    "context": "Four students will be assigned to a history project in which they will search archives from the years 1921, 1922, 1923, and 1924. Each of the four years will have exactly one student assigned to it. Six students—Louis, Mollie, Onyx, Ryan, Tiffany, and Yoshio—are available for this project. The following conditions apply: Only Louis or Tiffany can be assigned to 1923. If Mollie is assigned to the project, then she must be assigned to either 1921 or 1922. If Tiffany is assigned to the project, then Ryan must be assigned to the project. If Ryan is assigned to the project, then Onyx must be assigned to the year immediately prior to Ryan's.",
    "question": "Which one of the following students CANNOT be assigned to 1922?",
    "answer": "A",
    "options": [
      "A) Louis",
      "B) Mollie",
      "C) Onyx",
      "D) Ryan",
      "E) Yoshio"
    ],
    "raw_logic_programs": [
      "# Declarations\nstudents = EnumSort([Louis, Mollie, Onyx, Ryan, Tiffany, Yoshio])\nyears = EnumSort([1921, 1922, 1923, 1924])\nassigned = Function([students] -> [years])\n\n# Constraints\nForAll([y:years], Exists([s:students], assigned(s) == y)) ::: Each of the four years will have exactly one student assigned to it\nForAll([s:students], Count([y:years], assigned(s) == y) <= 1) ::: Each student will be assigned to at most one year\nOr(assigned(Louis) == 1923, assigned(Tiffany) == 1923) ::: Only Louis or Tiffany can be assigned to 1923\nImplies(assigned(Mollie) != None, Or(assigned(Mollie) == 1921, assigned(Mollie) == 1922)) ::: If Mollie is assigned to the project, then she must be assigned to either 1921 or 1922\nImplies(assigned(Tiffany) != None, assigned(Ryan) != None) ::: If Tiffany is assigned to the project, then Ryan must be assigned to the project\nImplies(assigned(Ryan) != None, Exists([y:years], And(assigned(Ryan) == y, assigned(Onyx) == y - 1))) ::: If Ryan is assigned to the project, then Onyx must be assigned to the year immediately prior to Ryan's\n\n# Options\nQuestion ::: Which one of the following students CANNOT be assigned to 1922?\nis_unsat(assigned(Louis) == 1922) ::: (A)\nis_unsat(assigned(Mollie) == 1922) ::: (B)\nis_unsat(assigned(Onyx) == 1922) ::: (C)\nis_unsat(assigned(Ryan) == 1922) ::: (D)\nis_unsat(assigned(Yoshio) == 1922) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201606_2-G_3_12",
    "context": "During the weeklong grand opening of a new antique shop, the antique dealer will auction exactly one antique per day for six consecutive days—June 1st through June 6th. The antiques to be auctioned are: a harmonica, a lamp, a mirror, a sundial, a table, and a vase. The following conditions apply: The sundial is not auctioned on June 1st. If the harmonica is auctioned on an earlier date than the lamp, then the mirror is also auctioned on an earlier date than the lamp. The sundial is auctioned on an earlier date than the mirror and also on an earlier date than the vase. The table is auctioned on an earlier date than the harmonica or on an earlier date than the vase, but not both.",
    "question": "Which one of the following could be an accurate list of the six antiques, in the order in which they are auctioned, from June 1st through June 6th?",
    "answer": "C",
    "options": [
      "A) harmonica, table, sundial, lamp, vase, mirror",
      "B) lamp, harmonica, sundial, mirror, vase, table",
      "C) harmonica, sundial, table, mirror, lamp, vase",
      "D) sundial, mirror, harmonica, table, vase, lamp",
      "E) vase, sundial, lamp, harmonica, table, mirror"
    ],
    "raw_logic_programs": [
      "# Declarations\nantiques = EnumSort([harmonica, lamp, mirror, sundial, table, vase])\ndays = EnumSort([1, 2, 3, 4, 5, 6])\nauctioned = Function([antiques] -> [days])\n\n# Constraints\nForAll([a:antiques], And(1 <= auctioned(a), auctioned(a) <= 6)) ::: exactly one antique per day for six consecutive days\nauctioned(sundial) != 1 ::: The sundial is not auctioned on June 1st\nImplies(auctioned(harmonica) < auctioned(lamp), auctioned(mirror) < auctioned(lamp)) ::: If the harmonica is auctioned on an earlier date than the lamp, then the mirror is also auctioned on an earlier date than the lamp\nAnd(auctioned(sundial) < auctioned(mirror), auctioned(sundial) < auctioned(vase)) ::: The sundial is auctioned on an earlier date than the mirror and also on an earlier date than the vase\nAnd(Or(auctioned(table) < auctioned(harmonica), auctioned(table) < auctioned(vase)), Not(And(auctioned(table) < auctioned(harmonica), auctioned(table) < auctioned(vase)))) ::: The table is auctioned on an earlier date than the harmonica or on an earlier date than the vase, but not both\n\n# Options\nQuestion ::: Which one of the following could be an accurate list of the six antiques, in the order in which they are auctioned, from June 1st through June 6th?\nis_accurate_list(And(auctioned(harmonica) == 1, auctioned(table) == 2, auctioned(sundial) == 3, auctioned(lamp) == 4, auctioned(vase) == 5, auctioned(mirror) == 6)) ::: (A)\nis_accurate_list(And(auctioned(lamp) == 1, auctioned(harmonica) == 2, auctioned(sundial) == 3, auctioned(mirror) == 4, auctioned(vase) == 5, auctioned(table) == 6)) ::: (B)\nis_accurate_list(And(auctioned(harmonica) == 1, auctioned(sundial) == 2, auctioned(table) == 3, auctioned(mirror) == 4, auctioned(lamp) == 5, auctioned(vase) == 6)) ::: (C)\nis_accurate_list(And(auctioned(sundial) == 1, auctioned(mirror) == 2, auctioned(harmonica) == 3, auctioned(table) == 4, auctioned(vase) == 5, auctioned(lamp) == 6)) ::: (D)\nis_accurate_list(And(auctioned(vase) == 1, auctioned(sundial) == 2, auctioned(lamp) == 3, auctioned(harmonica) == 4, auctioned(table) == 5, auctioned(mirror) == 6)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201606_2-G_3_13",
    "context": "During the weeklong grand opening of a new antique shop, the antique dealer will auction exactly one antique per day for six consecutive days—June 1st through June 6th. The antiques to be auctioned are: a harmonica, a lamp, a mirror, a sundial, a table, and a vase. The following conditions apply: The sundial is not auctioned on June 1st. If the harmonica is auctioned on an earlier date than the lamp, then the mirror is also auctioned on an earlier date than the lamp. The sundial is auctioned on an earlier date than the mirror and also on an earlier date than the vase. The table is auctioned on an earlier date than the harmonica or on an earlier date than the vase, but not both.",
    "question": "Which one of the following could be true?",
    "answer": "B",
    "options": [
      "A) The table is auctioned on June 2nd and the lamp is auctioned on June 3rd.",
      "B) The sundial is auctioned on June 2nd and the vase is auctioned on June 3rd.",
      "C) The mirror is auctioned on June 3rd and the sundial is auctioned on June 4th.",
      "D) The vase is auctioned on June 4th and the sundial is auctioned on June 5th.",
      "E) The sundial is auctioned on June 4th and the table is auctioned on June 5th."
    ],
    "raw_logic_programs": [
      "# Declarations\nantiques = EnumSort([harmonica, lamp, mirror, sundial, table, vase])\ndays = EnumSort([June_1st, June_2nd, June_3rd, June_4th, June_5th, June_6th])\nauctioned = Function([antiques] -> [days])\n\n# Constraints\nForAll([a:antiques], Exists([d:days], auctioned(a) == d)) ::: exactly one antique per day for six consecutive days\nauctioned(sundial) != June_1st ::: The sundial is not auctioned on June_1st\nImplies(auctioned(harmonica) < auctioned(lamp), auctioned(mirror) < auctioned(lamp)) ::: If the harmonica is auctioned on an earlier date than the lamp, then the mirror is also auctioned on an earlier date than the lamp\nAnd(auctioned(sundial) < auctioned(mirror), auctioned(sundial) < auctioned(vase)) ::: The sundial is auctioned on an earlier date than the mirror and also on an earlier date than the vase\nAnd(Or(auctioned(table) < auctioned(harmonica), auctioned(table) < auctioned(vase)), Not(And(auctioned(table) < auctioned(harmonica), auctioned(table) < auctioned(vase)))) ::: The table is auctioned on an earlier date than the harmonica or on an earlier date than the vase, but not both\n\n# Options\nQuestion ::: Which one of the following could be true?\nis_sat(And(auctioned(table) == June_2nd, auctioned(lamp) == June_3rd)) ::: (A)\nis_sat(And(auctioned(sundial) == June_2nd, auctioned(vase) == June_3rd)) ::: (B)\nis_sat(And(auctioned(mirror) == June_3rd, auctioned(sundial) == June_4th)) ::: (C)\nis_sat(And(auctioned(vase) == June_4th, auctioned(sundial) == June_5th)) ::: (D)\nis_sat(And(auctioned(sundial) == June_4th, auctioned(table) == June_5th)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201606_2-G_3_14",
    "context": "During the weeklong grand opening of a new antique shop, the antique dealer will auction exactly one antique per day for six consecutive days—June 1st through June 6th. The antiques to be auctioned are: a harmonica, a lamp, a mirror, a sundial, a table, and a vase. The following conditions apply: The sundial is not auctioned on June 1st. If the harmonica is auctioned on an earlier date than the lamp, then the mirror is also auctioned on an earlier date than the lamp. The sundial is auctioned on an earlier date than the mirror and also on an earlier date than the vase. The table is auctioned on an earlier date than the harmonica or on an earlier date than the vase, but not both.",
    "question": "If the table is auctioned on a date that is later than both the date on which the mirror is auctioned and the date on which the vase is auctioned, then which one of the following could be true?",
    "answer": "D",
    "options": [
      "A) The harmonica is auctioned on an earlier date than the table.",
      "B) The table is auctioned on an earlier date than the lamp.",
      "C) The table is auctioned on an earlier date than the sundial.",
      "D) The mirror is auctioned on an earlier date than the vase.",
      "E) The sundial is auctioned on an earlier date than the lamp."
    ],
    "raw_logic_programs": [
      "# Declarations\nantiques = EnumSort([harmonica, lamp, mirror, sundial, table, vase])\ndates = EnumSort([June_1st, June_2nd, June_3rd, June_4th, June_5th, June_6th])\nauctioned = Function([antiques] -> [dates])\n\n# Constraints\nForAll([a:antiques], Exists([d:dates], auctioned(a) == d)) ::: exactly one antique per day for six consecutive days\nauctioned(sundial) != June_1st ::: The sundial is not auctioned on June_1st\nImplies(auctioned(harmonica) < auctioned(lamp), auctioned(mirror) < auctioned(lamp)) ::: If the harmonica is auctioned on an earlier date than the lamp, then the mirror is also auctioned on an earlier date than the lamp\nAnd(auctioned(sundial) < auctioned(mirror), auctioned(sundial) < auctioned(vase)) ::: The sundial is auctioned on an earlier date than the mirror and also on an earlier date than the vase\nAnd(Or(auctioned(table) < auctioned(harmonica), auctioned(table) < auctioned(vase)), Not(And(auctioned(table) < auctioned(harmonica), auctioned(table) < auctioned(vase)))) ::: The table is auctioned on an earlier date than the harmonica or on an earlier date than the vase, but not both\nAnd(auctioned(mirror) < auctioned(table), auctioned(vase) < auctioned(table)) ::: If the table is auctioned on a date that is later than both the date on which the mirror is auctioned and the date on which the vase is auctioned\n\n# Options\nQuestion ::: If the table is auctioned on a date that is later than both the date on which the mirror is auctioned and the date on which the vase is auctioned, then which one of the following could be true?\nis_sat(auctioned(harmonica) < auctioned(table)) ::: (A)\nis_sat(auctioned(table) < auctioned(lamp)) ::: (B)\nis_sat(auctioned(table) < auctioned(sundial)) ::: (C)\nis_sat(auctioned(mirror) < auctioned(vase)) ::: (D)\nis_sat(auctioned(sundial) < auctioned(lamp)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201606_2-G_3_15",
    "context": "During the weeklong grand opening of a new antique shop, the antique dealer will auction exactly one antique per day for six consecutive days—June 1st through June 6th. The antiques to be auctioned are: a harmonica, a lamp, a mirror, a sundial, a table, and a vase. The following conditions apply: The sundial is not auctioned on June 1st. If the harmonica is auctioned on an earlier date than the lamp, then the mirror is also auctioned on an earlier date than the lamp. The sundial is auctioned on an earlier date than the mirror and also on an earlier date than the vase. The table is auctioned on an earlier date than the harmonica or on an earlier date than the vase, but not both.",
    "question": "Which one of the following CANNOT be the antique auctioned on the day immediately preceding the day on which the vase is auctioned?",
    "answer": "A",
    "options": [
      "A) the harmonica",
      "B) the lamp",
      "C) the mirror",
      "D) the sundial",
      "E) the table"
    ],
    "raw_logic_programs": [
      "# Declarations\nantiques = EnumSort([harmonica, lamp, mirror, sundial, table, vase])\ndays = EnumSort([June_1st, June_2nd, June_3rd, June_4th, June_5th, June_6th])\nauctioned = Function([antiques] -> [days])\n\n# Constraints\nForAll([a:antiques], Exists([d:days], auctioned(a) == d)) ::: exactly one antique per day\nauctioned(sundial) != June_1st ::: The sundial is not auctioned on June_1st\nImplies(auctioned(harmonica) < auctioned(lamp), auctioned(mirror) < auctioned(lamp)) ::: If the harmonica is auctioned on an earlier date than the lamp, then the mirror is also auctioned on an earlier date than the lamp\nAnd(auctioned(sundial) < auctioned(mirror), auctioned(sundial) < auctioned(vase)) ::: The sundial is auctioned on an earlier date than the mirror and also on an earlier date than the vase\nAnd(Or(auctioned(table) < auctioned(harmonica), auctioned(table) < auctioned(vase)), Not(And(auctioned(table) < auctioned(harmonica), auctioned(table) < auctioned(vase)))) ::: The table is auctioned on an earlier date than the harmonica or on an earlier date than the vase, but not both\n\n# Options\nQuestion ::: Which one of the following CANNOT be the antique auctioned on the day immediately preceding the day on which the vase is auctioned?\nis_unsat(Exists([d:days], And(auctioned(harmonica) == d, d + 1 == auctioned(vase)))) ::: (A)\nis_unsat(Exists([d:days], And(auctioned(lamp) == d, d + 1 == auctioned(vase)))) ::: (B)\nis_unsat(Exists([d:days], And(auctioned(mirror) == d, d + 1 == auctioned(vase)))) ::: (C)\nis_unsat(Exists([d:days], And(auctioned(sundial) == d, d + 1 == auctioned(vase)))) ::: (D)\nis_unsat(Exists([d:days], And(auctioned(table) == d, d + 1 == auctioned(vase)))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201606_2-G_3_16",
    "context": "During the weeklong grand opening of a new antique shop, the antique dealer will auction exactly one antique per day for six consecutive days—June 1st through June 6th. The antiques to be auctioned are: a harmonica, a lamp, a mirror, a sundial, a table, and a vase. The following conditions apply: The sundial is not auctioned on June 1st. If the harmonica is auctioned on an earlier date than the lamp, then the mirror is also auctioned on an earlier date than the lamp. The sundial is auctioned on an earlier date than the mirror and also on an earlier date than the vase. The table is auctioned on an earlier date than the harmonica or on an earlier date than the vase, but not both.",
    "question": "Which one of the following could be true?",
    "answer": "E",
    "options": [
      "A) The mirror is auctioned on June 2nd.",
      "B) The lamp is auctioned on June 2nd.",
      "C) The vase is auctioned on. June 2nd.",
      "D) The lamp is auctioned on June 3rd.",
      "E) The mirror is auctioned on June 5th."
    ],
    "raw_logic_programs": [
      "# Declarations\nantiques = EnumSort([harmonica, lamp, mirror, sundial, table, vase])\ndays = EnumSort([June_1st, June_2nd, June_3rd, June_4th, June_5th, June_6th])\nauctioned = Function([antiques] -> [days])\n\n# Constraints\nForAll([a:antiques], Exists([d:days], auctioned(a) == d)) ::: exactly one antique per day for six consecutive days\nauctioned(sundial) != June_1st ::: The sundial is not auctioned on June_1st\nImplies(auctioned(harmonica) < auctioned(lamp), auctioned(mirror) < auctioned(lamp)) ::: If the harmonica is auctioned on an earlier date than the lamp, then the mirror is also auctioned on an earlier date than the lamp\nAnd(auctioned(sundial) < auctioned(mirror), auctioned(sundial) < auctioned(vase)) ::: The sundial is auctioned on an earlier date than the mirror and also on an earlier date than the vase\nAnd(Or(auctioned(table) < auctioned(harmonica), auctioned(table) < auctioned(vase)), Not(And(auctioned(table) < auctioned(harmonica), auctioned(table) < auctioned(vase)))) ::: The table is auctioned on an earlier date than the harmonica or on an earlier date than the vase, but not both\n\n# Options\nQuestion ::: Which one of the following could be true?\nis_sat(auctioned(mirror) == June_2nd) ::: (A)\nis_sat(auctioned(lamp) == June_2nd) ::: (B)\nis_sat(auctioned(vase) == June_2nd) ::: (C)\nis_sat(auctioned(lamp) == June_3rd) ::: (D)\nis_sat(auctioned(mirror) == June_5th) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201606_2-G_3_17",
    "context": "During the weeklong grand opening of a new antique shop, the antique dealer will auction exactly one antique per day for six consecutive days—June 1st through June 6th. The antiques to be auctioned are: a harmonica, a lamp, a mirror, a sundial, a table, and a vase. The following conditions apply: The sundial is not auctioned on June 1st. If the harmonica is auctioned on an earlier date than the lamp, then the mirror is also auctioned on an earlier date than the lamp. The sundial is auctioned on an earlier date than the mirror and also on an earlier date than the vase. The table is auctioned on an earlier date than the harmonica or on an earlier date than the vase, but not both.",
    "question": "Which one of the following could be true?",
    "answer": "B",
    "options": [
      "A) The sundial is auctioned on June 5th.",
      "B) The sundial is auctioned on June 4th.",
      "C) The lamp is auctioned on June 5th and the mirror is auctioned on June 6th.",
      "D) The table is auctioned on June 3rd and the lamp is auctioned on June 4th.",
      "E) The harmonica is auctioned on June 2nd and the vase is auctioned on June 3rd."
    ],
    "raw_logic_programs": [
      "# Declarations\ndays = EnumSort([June_1st, June_2nd, June_3rd, June_4th, June_5th, June_6th])\nantiques = EnumSort([harmonica, lamp, mirror, sundial, table, vase])\nauctioned = Function([days, antiques] -> [bool])\n\n# Constraints\nForAll([d:days], Count([a:antiques], auctioned(d, a)) == 1) ::: exactly one antique per day\nNot(auctioned(June_1st, sundial)) ::: The sundial is not auctioned on June_1st\nImplies(And(auctioned(d1, harmonica), auctioned(d2, lamp), d1 < d2), And(auctioned(d3, mirror), auctioned(d4, lamp), d3 < d4)) ::: If the harmonica is auctioned on an earlier date than the lamp, then the mirror is also auctioned on an earlier date than the lamp\nAnd(And(auctioned(d1, sundial), auctioned(d2, mirror), d1 < d2), And(auctioned(d3, sundial), auctioned(d4, vase), d3 < d4)) ::: The sundial is auctioned on an earlier date than the mirror and also on an earlier date than the vase\nAnd(Or(And(auctioned(d1, table), auctioned(d2, harmonica), d1 < d2), And(auctioned(d3, table), auctioned(d4, vase), d3 < d4)), Not(And(auctioned(d5, table), auctioned(d6, harmonica), d5 < d6, auctioned(d7, table), auctioned(d8, vase), d7 < d8))) ::: The table is auctioned on an earlier date than the harmonica or on an earlier date than the vase, but not both\n\n# Options\nQuestion ::: Which one of the following could be true?\nis_sat(auctioned(June_5th, sundial)) ::: (A)\nis_sat(auctioned(June_4th, sundial)) ::: (B)\nis_sat(And(auctioned(June_5th, lamp), auctioned(June_6th, mirror))) ::: (C)\nis_sat(And(auctioned(June_3rd, table), auctioned(June_4th, lamp))) ::: (D)\nis_sat(And(auctioned(June_2nd, harmonica), auctioned(June_3rd, vase))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201606_2-G_4_18",
    "context": "A chorus director is planning to audition exactly six singers: Kammer, Lugo, Trillo, Waite, Yoshida, and Zinn. Kammer's audition and Lugo's audition will be recorded; the other four will not be. The six auditions are to take place one after the other on a single day, in accordance with the following conditions: The fourth audition cannot be recorded. The fifth audition must be recorded. Waite's audition must take place earlier than the two recorded auditions. Kammer's audition must take place earlier than Trillo's audition. Zinn's audition must take place earlier than Yoshida's audition.",
    "question": "Which one of the following could be the order of the auditions, from first to last?",
    "answer": "D",
    "options": [
      "A) Kammer, Trillo, Zinn, Waite, Lugo, Yoshida",
      "B) Waite, Kammer, Yoshida, Zinn, Lugo, Trillo",
      "C) Waite, Lugo, Kammer, Trillo, Zinn, Yoshida",
      "D) Waite, Zinn, Kammer, Trillo, Lugo, Yoshida",
      "E) Zinn, Yoshida, Waite, Lugo, Kammer, Trillo"
    ],
    "raw_logic_programs": [
      "# Declarations\nsingers = EnumSort([Kammer, Lugo, Trillo, Waite, Yoshida, Zinn])\naudition_order = Function([singers] -> [int])\nForAll([s:singers], And(1 <= audition_order(s), audition_order(s) <= 6))\n\n# Constraints\nForAll([s:singers], Implies(Or(s == Kammer, s == Lugo), audition_order(s) <= 4)) ::: The fourth audition cannot be recorded\nForAll([s:singers], Implies(s == Lugo, audition_order(s) == 5)) ::: The fifth audition must be recorded\nForAll([s:singers], Implies(s == Waite, audition_order(s) < 5)) ::: Waite's audition must take place earlier than the two recorded auditions\naudition_order(Kammer) < audition_order(Trillo) ::: Kammer's audition must take place earlier than Trillo's audition\naudition_order(Zinn) < audition_order(Yoshida) ::: Zinn's audition must take place earlier than Yoshida's audition\n\n# Options\nQuestion ::: Which one of the following could be the order of the auditions, from first to last?\nis_sat(And(audition_order(Kammer) == 1, audition_order(Trillo) == 2, audition_order(Zinn) == 3, audition_order(Waite) == 4, audition_order(Lugo) == 5, audition_order(Yoshida) == 6)) ::: (A)\nis_sat(And(audition_order(Waite) == 1, audition_order(Kammer) == 2, audition_order(Yoshida) == 3, audition_order(Zinn) == 4, audition_order(Lugo) == 5, audition_order(Trillo) == 6)) ::: (B)\nis_sat(And(audition_order(Waite) == 1, audition_order(Lugo) == 2, audition_order(Kammer) == 3, audition_order(Trillo) == 4, audition_order(Zinn) == 5, audition_order(Yoshida) == 6)) ::: (C)\nis_sat(And(audition_order(Waite) == 1, audition_order(Zinn) == 2, audition_order(Kammer) == 3, audition_order(Trillo) == 4, audition_order(Lugo) == 5, audition_order(Yoshida) == 6)) ::: (D)\nis_sat(And(audition_order(Zinn) == 1, audition_order(Yoshida) == 2, audition_order(Waite) == 3, audition_order(Lugo) == 4, audition_order(Kammer) == 5, audition_order(Trillo) == 6)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201606_2-G_4_19",
    "context": "A chorus director is planning to audition exactly six singers: Kammer, Lugo, Trillo, Waite, Yoshida, and Zinn. Kammer's audition and Lugo's audition will be recorded; the other four will not be. The six auditions are to take place one after the other on a single day, in accordance with the following conditions: The fourth audition cannot be recorded. The fifth audition must be recorded. Waite's audition must take place earlier than the two recorded auditions. Kammer's audition must take place earlier than Trillo's audition. Zinn's audition must take place earlier than Yoshida's audition.",
    "question": "Which one of the following CANNOT be the second audition?",
    "answer": "C",
    "options": [
      "A) Kammer's audition",
      "B) Lugo's audition",
      "C) Trillo's audition",
      "D) Waite's audition",
      "E) Zinn's audition"
    ],
    "raw_logic_programs": [
      "# Declarations\nsingers = EnumSort([Kammer, Lugo, Trillo, Waite, Yoshida, Zinn])\naudition_order = Function([singers] -> [int])\nForAll([s:singers], And(1 <= audition_order(s), audition_order(s) <= 6))\n\n# Constraints\nAnd(audition_order(Kammer) < audition_order(Trillo), audition_order(Zinn) < audition_order(Yoshida)) ::: Kammer's audition must take place earlier than Trillo's audition. Zinn's audition must take place earlier than Yoshida's audition.\naudition_order(Waite) < Min([audition_order(Kammer), audition_order(Lugo)]) ::: Waite's audition must take place earlier than the two recorded auditions\naudition_order(Kammer) != 4 ::: The fourth audition cannot be recorded\naudition_order(Lugo) != 4 ::: The fourth audition cannot be recorded\naudition_order(Kammer) == 5 ::: The fifth audition must be recorded\naudition_order(Lugo) == 5 ::: The fifth audition must be recorded\n\n# Options\nQuestion ::: Which one of the following CANNOT be the second audition?\nis_unsat(audition_order(Kammer) == 2) ::: (A)\nis_unsat(audition_order(Lugo) == 2) ::: (B)\nis_unsat(audition_order(Trillo) == 2) ::: (C)\nis_unsat(audition_order(Waite) == 2) ::: (D)\nis_unsat(audition_order(Zinn) == 2) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201606_2-G_4_20",
    "context": "A chorus director is planning to audition exactly six singers: Kammer, Lugo, Trillo, Waite, Yoshida, and Zinn. Kammer's audition and Lugo's audition will be recorded; the other four will not be. The six auditions are to take place one after the other on a single day, in accordance with the following conditions: The fourth audition cannot be recorded. The fifth audition must be recorded. Waite's audition must take place earlier than the two recorded auditions. Kammer's audition must take place earlier than Trillo's audition. Zinn's audition must take place earlier than Yoshida's audition.",
    "question": "Which one of the following could be the sixth audition?",
    "answer": "C",
    "options": [
      "A) Kammer's audition",
      "B) Lugo's audition",
      "C) Trillo's audition",
      "D) Waite's audition",
      "E) Zinn's audition"
    ],
    "raw_logic_programs": [
      "# Declarations\nsingers = EnumSort([Kammer, Lugo, Trillo, Waite, Yoshida, Zinn])\naudition_order = Function([singers] -> [int])\nForAll([s:singers], And(1 <= audition_order(s), audition_order(s) <= 6))\nrecorded = Function([singers] -> [bool])\n\n# Constraints\nAnd(recorded(Kammer), recorded(Lugo)) ::: Kammer's audition and Lugo's audition will be recorded\nForAll([s:singers], Implies(Or(s == Kammer, s == Lugo), recorded(s))) ::: the other four will not be\naudition_order(Waite) < audition_order(Kammer) ::: Waite's audition must take place earlier than the two recorded auditions\naudition_order(Waite) < audition_order(Lugo) ::: Waite's audition must take place earlier than the two recorded auditions\naudition_order(Kammer) < audition_order(Trillo) ::: Kammer's audition must take place earlier than Trillo's audition\naudition_order(Zinn) < audition_order(Yoshida) ::: Zinn's audition must take place earlier than Yoshida's audition\nNot(recorded(audition_order(4))) ::: The fourth audition cannot be recorded\nrecorded(audition_order(5)) ::: The fifth audition must be recorded\n\n# Options\nQuestion ::: Which one of the following could be the sixth audition?\nis_valid(audition_order(Kammer) == 6) ::: (A)\nis_valid(audition_order(Lugo) == 6) ::: (B)\nis_valid(audition_order(Trillo) == 6) ::: (C)\nis_valid(audition_order(Waite) == 6) ::: (D)\nis_valid(audition_order(Zinn) == 6) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201606_2-G_4_21",
    "context": "A chorus director is planning to audition exactly six singers: Kammer, Lugo, Trillo, Waite, Yoshida, and Zinn. Kammer's audition and Lugo's audition will be recorded; the other four will not be. The six auditions are to take place one after the other on a single day, in accordance with the following conditions: The fourth audition cannot be recorded. The fifth audition must be recorded. Waite's audition must take place earlier than the two recorded auditions. Kammer's audition must take place earlier than Trillo's audition. Zinn's audition must take place earlier than Yoshida's audition.",
    "question": "If Kammer's audition is immediately before Yoshida's, which one of the following could be true?",
    "answer": "E",
    "options": [
      "A) Kammer's audition is second.",
      "B) Trillo's audition is fourth.",
      "C) Waite's audition is third.",
      "D) Yoshida's audition is sixth.",
      "E) Zinn's audition is second."
    ],
    "raw_logic_programs": [
      "# Declarations\nsingers = EnumSort([Kammer, Lugo, Trillo, Waite, Yoshida, Zinn])\naudition_order = Function([singers] -> [int])\nForAll([s:singers], And(1 <= audition_order(s), audition_order(s) <= 6))\nrecorded = Function([singers] -> [bool])\n\n# Constraints\nAnd(recorded(Kammer), recorded(Lugo)) ::: Kammer's audition and Lugo's audition will be recorded\nForAll([s:singers], Implies(Or(s == Kammer, s == Lugo), recorded(s))) ::: the other four will not be\nNot(recorded(audition_order(4))) ::: The fourth audition cannot be recorded\nrecorded(audition_order(5)) ::: The fifth audition must be recorded\naudition_order(Waite) < Min([audition_order(Kammer), audition_order(Lugo)]) ::: Waite's audition must take place earlier than the two recorded auditions\naudition_order(Kammer) < audition_order(Trillo) ::: Kammer's audition must take place earlier than Trillo's audition\naudition_order(Zinn) < audition_order(Yoshida) ::: Zinn's audition must take place earlier than Yoshida's audition\naudition_order(Kammer) + 1 == audition_order(Yoshida) ::: If Kammer's audition is immediately before Yoshida's\n\n# Options\nQuestion ::: If Kammer's audition is immediately before Yoshida's, which one of the following could be true?\nis_sat(audition_order(Kammer) == 2) ::: (A)\nis_sat(audition_order(Trillo) == 4) ::: (B)\nis_sat(audition_order(Waite) == 3) ::: (C)\nis_sat(audition_order(Yoshida) == 6) ::: (D)\nis_sat(audition_order(Zinn) == 2) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201606_2-G_4_22",
    "context": "A chorus director is planning to audition exactly six singers: Kammer, Lugo, Trillo, Waite, Yoshida, and Zinn. Kammer's audition and Lugo's audition will be recorded; the other four will not be. The six auditions are to take place one after the other on a single day, in accordance with the following conditions: The fourth audition cannot be recorded. The fifth audition must be recorded. Waite's audition must take place earlier than the two recorded auditions. Kammer's audition must take place earlier than Trillo's audition. Zinn's audition must take place earlier than Yoshida's audition.",
    "question": "Yoshida's audition could be",
    "answer": "B",
    "options": [
      "A) fifth",
      "B) fourth",
      "C) third",
      "D) second",
      "E) first"
    ],
    "raw_logic_programs": [
      "# Declarations\nsingers = EnumSort([Kammer, Lugo, Trillo, Waite, Yoshida, Zinn])\naudition_order = Function([singers] -> [int])\nForAll([s:singers], And(1 <= audition_order(s), audition_order(s) <= 6))\n\n# Constraints\nAnd(audition_order(Kammer) < audition_order(Trillo), audition_order(Zinn) < audition_order(Yoshida)) ::: Kammer's audition must take place earlier than Trillo's audition. Zinn's audition must take place earlier than Yoshida's audition.\nAnd(audition_order(Waite) < audition_order(Kammer), audition_order(Waite) < audition_order(Lugo)) ::: Waite's audition must take place earlier than the two recorded auditions.\nAnd(audition_order(Kammer) <= 4, audition_order(Lugo) <= 4) ::: The fourth audition cannot be recorded.\nAnd(audition_order(Kammer) >= 5, audition_order(Lugo) >= 5) ::: The fifth audition must be recorded.\n\n# Options\nQuestion ::: Yoshida's audition could be\nis_sat(audition_order(Yoshida) == 5) ::: (A)\nis_sat(audition_order(Yoshida) == 4) ::: (B)\nis_sat(audition_order(Yoshida) == 3) ::: (C)\nis_sat(audition_order(Yoshida) == 2) ::: (D)\nis_sat(audition_order(Yoshida) == 1) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201606_2-G_4_23",
    "context": "A chorus director is planning to audition exactly six singers: Kammer, Lugo, Trillo, Waite, Yoshida, and Zinn. Kammer's audition and Lugo's audition will be recorded; the other four will not be. The six auditions are to take place one after the other on a single day, in accordance with the following conditions: The fourth audition cannot be recorded. The fifth audition must be recorded. Waite's audition must take place earlier than the two recorded auditions. Kammer's audition must take place earlier than Trillo's audition. Zinn's audition must take place earlier than Yoshida's audition.",
    "question": "Which one of the following, if substituted for the condition that Waite's audition must take place earlier than the two recorded auditions, would have the same effect in determining the order of the auditions?",
    "answer": "A",
    "options": [
      "A) Zinn's audition is the only one that can take place earlier than Waite's.",
      "B) Waite's audition must take place either immediately before or immediately after Zinn's.",
      "C) Waite's audition must take place earlier than Lugo's.",
      "D) Waite's audition must be either first or second.",
      "E) The first audition cannot be recorded."
    ],
    "raw_logic_programs": [
      "# Declarations\nsingers = EnumSort([Kammer, Lugo, Trillo, Waite, Yoshida, Zinn])\naudition_order = Function([singers] -> [int])\nForAll([s:singers], And(1 <= audition_order(s), audition_order(s) <= 6))\n\n# Constraints\nDistinct([s:singers], audition_order(s)) ::: The six auditions are to take place one after the other on a single day\nAnd(audition_order(Kammer) < audition_order(Trillo), audition_order(Zinn) < audition_order(Yoshida)) ::: Kammer's audition must take place earlier than Trillo's audition. Zinn's audition must take place earlier than Yoshida's audition.\nAnd(audition_order(Kammer) <= 4, audition_order(Lugo) <= 4) ::: The fourth audition cannot be recorded.\nAnd(audition_order(Kammer) >= 5, audition_order(Lugo) >= 5) ::: The fifth audition must be recorded.\naudition_order(Waite) < audition_order(Kammer) ::: Waite's audition must take place earlier than the two recorded auditions\n\n# Options\nQuestion ::: Which one of the following, if substituted for the condition that Waite's audition must take place earlier than the two recorded auditions, would have the same effect in determining the order of the auditions?\nis_equivalent(And(audition_order(Zinn) < audition_order(Waite), ForAll([s:singers], Implies(s != Zinn, audition_order(s) > audition_order(Waite))))) , audition_order(Waite) < audition_order(Kammer)) ::: (A)\nis_equivalent(Or(audition_order(Waite) == audition_order(Zinn) - 1, audition_order(Waite) == audition_order(Zinn) + 1), audition_order(Waite) < audition_order(Kammer)) ::: (B)\nis_equivalent(audition_order(Waite) < audition_order(Lugo), audition_order(Waite) < audition_order(Kammer)) ::: (C)\nis_equivalent(Or(audition_order(Waite) == 1, audition_order(Waite) == 2), audition_order(Waite) < audition_order(Kammer)) ::: (D)\nis_equivalent(audition_order(Kammer) > 1, audition_order(Waite) < audition_order(Kammer)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201612_3-G_1_1",
    "context": "A teacher will assign each of five students—Juana, Kelly, Lateefah, Mei, and Olga—to exactly one of two research teams, the green team and the red team. One team will have two members, and the other will have three members. One member of each team will be designated as facilitator. The assignment must satisfy the following conditions: Juana is assigned to a different team than Olga is. Lateefah is assigned to the green team. Kelly is not a facilitator. Olga is a facilitator.",
    "question": "Which one of the following could be an accurate listing of the members and facilitators of the two research teams?",
    "answer": "C",
    "options": [
      "A) green team: Juana, Lateefah, Olga (facilitator) red team: Kelly, Mei (facilitator)",
      "B) green team: Kelly, Lateefah (facilitator), Olga red team: Juana, Mei (facilitator)",
      "C) green team: Kelly, Lateefah, Olga (facilitator) red team: Juana (facilitator), Mei",
      "D) green team: Kelly, Mei, Olga (facilitator) red team: Juana (facilitator), Lateefah",
      "E) green team: Lateefah, Olga (facilitator) red team: Juana, Kelly (facilitator), Mei"
    ],
    "raw_logic_programs": [
      "# Declarations\nstudents = EnumSort([Juana, Kelly, Lateefah, Mei, Olga])\nteams = EnumSort([green, red])\nis_facilitator = Function([students] -> [bool])\nassigned = Function([students] -> [teams])\n\n# Constraints\nForAll([s:students], Exists([t:teams], assigned(s) == t)) ::: each of five students—Juana, Kelly, Lateefah, Mei, and Olga—to exactly one of two research teams\nCount([s:students], assigned(s) == green) == 2 ::: One team will have two members\nCount([s:students], assigned(s) == red) == 3 ::: and the other will have three members\nCount([s:students], is_facilitator(s)) == 2 ::: One member of each team will be designated as facilitator\nassigned(Juana) != assigned(Olga) ::: Juana is assigned to a different team than Olga is\nassigned(Lateefah) == green ::: Lateefah is assigned to the green team\nNot(is_facilitator(Kelly)) ::: Kelly is not a facilitator\nis_facilitator(Olga) ::: Olga is a facilitator\n\n# Options\nQuestion ::: Which one of the following could be an accurate listing of the members and facilitators of the two research teams?\nis_accurate_list(And(And(assigned(Juana) == green, assigned(Lateefah) == green, assigned(Olga) == green), And(is_facilitator(Olga), And(assigned(Kelly) == red, assigned(Mei) == red, is_facilitator(Mei))))) ::: (A)\nis_accurate_list(And(And(assigned(Kelly) == green, assigned(Lateefah) == green, assigned(Olga) == green), And(is_facilitator(Lateefah), And(assigned(Juana) == red, assigned(Mei) == red, is_facilitator(Mei))))) ::: (B)\nis_accurate_list(And(And(assigned(Kelly) == green, assigned(Lateefah) == green, assigned(Olga) == green), And(is_facilitator(Olga), And(assigned(Juana) == red, assigned(Mei) == red, is_facilitator(Juana))))) ::: (C)\nis_accurate_list(And(And(assigned(Kelly) == green, assigned(Mei) == green, assigned(Olga) == green), And(is_facilitator(Olga), And(assigned(Juana) == red, assigned(Lateefah) == red, is_facilitator(Juana))))) ::: (D)\nis_accurate_list(And(And(assigned(Lateefah) == green, assigned(Olga) == green), And(is_facilitator(Olga), And(assigned(Juana) == red, assigned(Kelly) == red, assigned(Mei) == red, is_facilitator(Kelly))))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201612_3-G_1_2",
    "context": "A teacher will assign each of five students—Juana, Kelly, Lateefah, Mei, and Olga—to exactly one of two research teams, the green team and the red team. One team will have two members, and the other will have three members. One member of each team will be designated as facilitator. The assignment must satisfy the following conditions: Juana is assigned to a different team than Olga is. Lateefah is assigned to the green team. Kelly is not a facilitator. Olga is a facilitator.",
    "question": "Which one of the following must be true?",
    "answer": "D",
    "options": [
      "A) Juana is assigned to the red team.",
      "B) Lateefah is a facilitator.",
      "C) Olga is assigned to the green team.",
      "D) Juana and Mei are not both facilitators.",
      "E) Neither Juana nor Kelly is a facilitator."
    ],
    "raw_logic_programs": [
      "# Declarations\nstudents = EnumSort([Juana, Kelly, Lateefah, Mei, Olga])\nteams = EnumSort([green, red])\nassigned = Function([students] -> [teams])\nfacilitator = Function([students] -> [bool])\n\n# Constraints\nForAll([s:students], Exists([t:teams], assigned(s) == t)) ::: each of five students—Juana, Kelly, Lateefah, Mei, and Olga—to exactly one of two research teams\nCount([s:students], assigned(s) == green) == 2 ::: One team will have two members\nCount([s:students], assigned(s) == red) == 3 ::: and the other will have three members\nCount([s:students], facilitator(s)) == 2 ::: One member of each team will be designated as facilitator\nassigned(Juana) != assigned(Olga) ::: Juana is assigned to a different team than Olga is\nassigned(Lateefah) == green ::: Lateefah is assigned to the green team\nNot(facilitator(Kelly)) ::: Kelly is not a facilitator\nfacilitator(Olga) ::: Olga is a facilitator\n\n# Options\nQuestion ::: Which one of the following must be true?\nis_valid(assigned(Juana) == red) ::: (A)\nis_valid(facilitator(Lateefah)) ::: (B)\nis_valid(assigned(Olga) == green) ::: (C)\nis_valid(Not(And(facilitator(Juana), facilitator(Mei)))) ::: (D)\nis_valid(Not(Or(facilitator(Juana), facilitator(Kelly)))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201612_3-G_1_3",
    "context": "A teacher will assign each of five students—Juana, Kelly, Lateefah, Mei, and Olga—to exactly one of two research teams, the green team and the red team. One team will have two members, and the other will have three members. One member of each team will be designated as facilitator. The assignment must satisfy the following conditions: Juana is assigned to a different team than Olga is. Lateefah is assigned to the green team. Kelly is not a facilitator. Olga is a facilitator.",
    "question": "Which one of the following must be false?",
    "answer": "B",
    "options": [
      "A) Lateefah is a facilitator, and she is assigned to the same team as Kelly is.",
      "B) Mei is a facilitator, and she is assigned to the same team as Kelly is.",
      "C) Olga is a facilitator, and she is assigned to the same team as Mei is.",
      "D) Lateefah is a facilitator, and she is assigned to a different team than Juana is.",
      "E) Mei is a facilitator, and she is assigned to a different team than Olga is."
    ],
    "raw_logic_programs": [
      "# Declarations\nstudents = EnumSort([Juana, Kelly, Lateefah, Mei, Olga])\nteams = EnumSort([green, red])\nassigned = Function([students] -> [teams])\nfacilitator = Function([students] -> [bool])\n\n# Constraints\nForAll([s:students], Exists([t:teams], assigned(s) == t)) ::: each of five students—Juana, Kelly, Lateefah, Mei, and Olga—to exactly one of two research teams\nCount([s:students], assigned(s) == green) == 2 ::: One team will have two members\nCount([s:students], assigned(s) == red) == 3 ::: and the other will have three members\nassigned(Juana) != assigned(Olga) ::: Juana is assigned to a different team than Olga is\nassigned(Lateefah) == green ::: Lateefah is assigned to the green team\nNot(facilitator(Kelly)) ::: Kelly is not a facilitator\nfacilitator(Olga) ::: Olga is a facilitator\n\n# Options\nQuestion ::: Which one of the following must be false?\nis_unsat(And(facilitator(Lateefah), assigned(Lateefah) == assigned(Kelly))) ::: (A)\nis_unsat(And(facilitator(Mei), assigned(Mei) == assigned(Kelly))) ::: (B)\nis_unsat(And(facilitator(Olga), assigned(Olga) == assigned(Mei))) ::: (C)\nis_unsat(And(facilitator(Lateefah), assigned(Lateefah) != assigned(Juana))) ::: (D)\nis_unsat(And(facilitator(Mei), assigned(Mei) != assigned(Olga))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201612_3-G_1_4",
    "context": "A teacher will assign each of five students—Juana, Kelly, Lateefah, Mei, and Olga—to exactly one of two research teams, the green team and the red team. One team will have two members, and the other will have three members. One member of each team will be designated as facilitator. The assignment must satisfy the following conditions: Juana is assigned to a different team than Olga is. Lateefah is assigned to the green team. Kelly is not a facilitator. Olga is a facilitator.",
    "question": "If Lateefah is a facilitator, then which one of the following could be true?",
    "answer": "A",
    "options": [
      "A) Juana and Kelly are both assigned to the red team.",
      "B) Juana and Mei are both assigned to the red team.",
      "C) Lateefah and Olga are both assigned to the green team.",
      "D) Mei and Olga are both assigned to the green team.",
      "E) Mei and Olga are both assigned to the red team."
    ],
    "raw_logic_programs": [
      "# Declarations\nstudents = EnumSort([Juana, Kelly, Lateefah, Mei, Olga])\nteams = EnumSort([green, red])\nassigned = Function([students] -> [teams])\nfacilitator = Function([students] -> [bool])\n\n# Constraints\nForAll([s:students], Exists([t:teams], assigned(s) == t)) ::: each of five students—Juana, Kelly, Lateefah, Mei, and Olga—to exactly one of two research teams\nCount([s:students], assigned(s) == green) == 2 ::: One team will have two members\nCount([s:students], assigned(s) == red) == 3 ::: and the other will have three members\nForAll([t:teams], Exists([s:students], And(assigned(s) == t, facilitator(s)))) ::: One member of each team will be designated as facilitator\nassigned(Juana) != assigned(Olga) ::: Juana is assigned to a different team than Olga is\nassigned(Lateefah) == green ::: Lateefah is assigned to the green team\nNot(facilitator(Kelly)) ::: Kelly is not a facilitator\nfacilitator(Olga) ::: Olga is a facilitator\n\n# Options\nQuestion ::: If Lateefah is a facilitator, then which one of the following could be true?\nis_sat(And(facilitator(Lateefah), And(assigned(Juana) == red, assigned(Kelly) == red))) ::: (A)\nis_sat(And(facilitator(Lateefah), And(assigned(Juana) == red, assigned(Mei) == red))) ::: (B)\nis_sat(And(facilitator(Lateefah), And(assigned(Lateefah) == green, assigned(Olga) == green))) ::: (C)\nis_sat(And(facilitator(Lateefah), And(assigned(Mei) == green, assigned(Olga) == green))) ::: (D)\nis_sat(And(facilitator(Lateefah), And(assigned(Mei) == red, assigned(Olga) == red))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201612_3-G_1_5",
    "context": "A teacher will assign each of five students—Juana, Kelly, Lateefah, Mei, and Olga—to exactly one of two research teams, the green team and the red team. One team will have two members, and the other will have three members. One member of each team will be designated as facilitator. The assignment must satisfy the following conditions: Juana is assigned to a different team than Olga is. Lateefah is assigned to the green team. Kelly is not a facilitator. Olga is a facilitator.",
    "question": "If Mei is assigned to the green team, then which one of the following must be true?",
    "answer": "E",
    "options": [
      "A) Juana is assigned to the green team.",
      "B) Kelly is assigned to the red team.",
      "C) Olga is assigned to the green team.",
      "D) Lateefah is a facilitator.",
      "E) Mei is a facilitator."
    ],
    "raw_logic_programs": [
      "# Declarations\nstudents = EnumSort([Juana, Kelly, Lateefah, Mei, Olga])\nteams = EnumSort([green, red])\nassigned = Function([students] -> [teams])\nfacilitator = Function([students] -> [bool])\n\n# Constraints\nForAll([s:students], Exists([t:teams], assigned(s) == t)) ::: each of five students—Juana, Kelly, Lateefah, Mei, and Olga—to exactly one of two research teams\nAnd(Count([s:students], assigned(s) == green) == 2, Count([s:students], assigned(s) == red) == 3) ::: One team will have two members, and the other will have three members\nForAll([t:teams], Exists([s:students], And(assigned(s) == t, facilitator(s)))) ::: One member of each team will be designated as facilitator\nassigned(Juana) != assigned(Olga) ::: Juana is assigned to a different team than Olga is\nassigned(Lateefah) == green ::: Lateefah is assigned to the green team\nNot(facilitator(Kelly)) ::: Kelly is not a facilitator\nfacilitator(Olga) ::: Olga is a facilitator\nassigned(Mei) == green ::: If Mei is assigned to the green team\n\n# Options\nQuestion ::: If Mei is assigned to the green team, then which one of the following must be true?\nis_sat(assigned(Juana) == green) ::: (A)\nis_sat(assigned(Kelly) == red) ::: (B)\nis_sat(assigned(Olga) == green) ::: (C)\nis_sat(facilitator(Lateefah)) ::: (D)\nis_sat(facilitator(Mei)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201612_3-G_2_6",
    "context": "An author is planning to write a mystery novel consisting of seven chapters, chapter 1 through chapter 7. Each of seven different clues—R, S, T, U, W, X, and Z—is to be mentioned exactly once, one clue per chapter. The order in which the clues are mentioned is subject to the following constraints: T cannot be mentioned in chapter 1. T must be mentioned before W, and there must be exactly two chapters separating the mention of T from the mention of W. S and Z cannot be mentioned in adjacent chapters. W and X cannot be mentioned in adjacent chapters. U and X must be mentioned in adjacent chapters.",
    "question": "Which one of the following could be the order in which the clues are mentioned, from the first chapter through the seventh?",
    "answer": "C",
    "options": [
      "A) S, T, Z, X, U, W, R",
      "B) T, X, U, W, S, R, Z",
      "C) U, S, X, T, Z, R, W",
      "D) X, U, T, Z, R, W, S",
      "E) Z, R, T, U, X, W, S"
    ],
    "raw_logic_programs": [
      "# Declarations\nchapters = EnumSort([1, 2, 3, 4, 5, 6, 7])\nclues = EnumSort([R, S, T, U, W, X, Z])\nmentioned = Function([chapters, clues] -> [bool])\n\n# Constraints\nForAll([c:chapters], Count([cl:clues], mentioned(c, cl)) == 1) ::: Each of seven different clues—R, S, T, U, W, X, and Z—is to be mentioned exactly once, one clue per chapter\nNot(mentioned(1, T)) ::: T cannot be mentioned in chapter 1\nAnd(Exists([c1:chapters, c2:chapters], And(mentioned(c1, T), mentioned(c2, W), c2 > c1, c2 - c1 == 3)), Not(Exists([c1:chapters, c2:chapters], And(mentioned(c1, T), mentioned(c2, W), c2 > c1, c2 - c1 < 3)))) ::: T must be mentioned before W, and there must be exactly two chapters separating the mention of T from the mention of W\nForAll([c:chapters], Implies(mentioned(c, S), Not(mentioned(c + 1, Z)))) ::: S and Z cannot be mentioned in adjacent chapters\nForAll([c:chapters], Implies(mentioned(c, W), Not(mentioned(c + 1, X)))) ::: W and X cannot be mentioned in adjacent chapters\nForAll([c:chapters], Implies(mentioned(c, U), mentioned(c + 1, X))) ::: U and X must be mentioned in adjacent chapters\n\n# Options\nQuestion ::: Which one of the following could be the order in which the clues are mentioned, from the first chapter through the seventh?\nis_sat(And(mentioned(1, S), mentioned(2, T), mentioned(3, Z), mentioned(4, X), mentioned(5, U), mentioned(6, W), mentioned(7, R))) ::: (A)\nis_sat(And(mentioned(1, T), mentioned(2, X), mentioned(3, U), mentioned(4, W), mentioned(5, S), mentioned(6, R), mentioned(7, Z))) ::: (B)\nis_sat(And(mentioned(1, U), mentioned(2, S), mentioned(3, X), mentioned(4, T), mentioned(5, Z), mentioned(6, R), mentioned(7, W))) ::: (C)\nis_sat(And(mentioned(1, X), mentioned(2, U), mentioned(3, T), mentioned(4, Z), mentioned(5, R), mentioned(6, W), mentioned(7, S))) ::: (D)\nis_sat(And(mentioned(1, Z), mentioned(2, R), mentioned(3, T), mentioned(4, U), mentioned(5, X), mentioned(6, W), mentioned(7, S))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201612_3-G_2_7",
    "context": "An author is planning to write a mystery novel consisting of seven chapters, chapter 1 through chapter 7. Each of seven different clues—R, S, T, U, W, X, and Z—is to be mentioned exactly once, one clue per chapter. The order in which the clues are mentioned is subject to the following constraints: T cannot be mentioned in chapter 1. T must be mentioned before W, and there must be exactly two chapters separating the mention of T from the mention of W. S and Z cannot be mentioned in adjacent chapters. W and X cannot be mentioned in adjacent chapters. U and X must be mentioned in adjacent chapters.",
    "question": "If X is mentioned in chapter 1, which one of the following could be true?",
    "answer": "E",
    "options": [
      "A) R is mentioned in chapter 3.",
      "B) R is mentioned in chapter 7.",
      "C) S is mentioned in chapter 2.",
      "D) W is mentioned in chapter 5.",
      "E) Z is mentioned in chapter 3."
    ],
    "raw_logic_programs": [
      "# Declarations\nchapters = EnumSort([1, 2, 3, 4, 5, 6, 7])\nclues = EnumSort([R, S, T, U, W, X, Z])\nmentioned = Function([chapters, clues] -> [bool])\n\n# Constraints\nForAll([c:chapters], Count([cl:clues], mentioned(c, cl)) == 1) ::: Each of seven different clues—R, S, T, U, W, X, and Z—is to be mentioned exactly once, one clue per chapter\nNot(mentioned(1, T)) ::: T cannot be mentioned in chapter 1\nAnd(Exists([c1:chapters, c2:chapters], And(mentioned(c1, T), mentioned(c2, W), c2 > c1, c2 - c1 == 3)), ForAll([c1:chapters, c2:chapters], Implies(And(mentioned(c1, T), mentioned(c2, W), c2 > c1), c2 - c1 == 3))) ::: T must be mentioned before W, and there must be exactly two chapters separating the mention of T from the mention of W\nForAll([c:chapters], Implies(mentioned(c, S), Not(mentioned(c + 1, Z)))) ::: S and Z cannot be mentioned in adjacent chapters\nForAll([c:chapters], Implies(mentioned(c, W), Not(mentioned(c + 1, X)))) ::: W and X cannot be mentioned in adjacent chapters\nForAll([c:chapters], Implies(mentioned(c, U), mentioned(c + 1, X))) ::: U and X must be mentioned in adjacent chapters\nmentioned(1, X) ::: If X is mentioned in chapter 1\n\n# Options\nQuestion ::: If X is mentioned in chapter 1, which one of the following could be true?\nis_sat(mentioned(3, R)) ::: (A)\nis_sat(mentioned(7, R)) ::: (B)\nis_sat(mentioned(2, S)) ::: (C)\nis_sat(mentioned(5, W)) ::: (D)\nis_sat(mentioned(3, Z)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201612_3-G_2_8",
    "context": "An author is planning to write a mystery novel consisting of seven chapters, chapter 1 through chapter 7. Each of seven different clues—R, S, T, U, W, X, and Z—is to be mentioned exactly once, one clue per chapter. The order in which the clues are mentioned is subject to the following constraints: T cannot be mentioned in chapter 1. T must be mentioned before W, and there must be exactly two chapters separating the mention of T from the mention of W. S and Z cannot be mentioned in adjacent chapters. W and X cannot be mentioned in adjacent chapters. U and X must be mentioned in adjacent chapters.",
    "question": "If U is mentioned in chapter 3, which one of the following could be true?",
    "answer": "A",
    "options": [
      "A) R is mentioned in chapter 1.",
      "B) R is mentioned in chapter 5.",
      "C) S is mentioned in chapter 7.",
      "D) W is mentioned in chapter 6.",
      "E) X is mentioned in chapter 4."
    ],
    "raw_logic_programs": [
      "# Declarations\nchapters = EnumSort([1, 2, 3, 4, 5, 6, 7])\nclues = EnumSort([R, S, T, U, W, X, Z])\nmentioned = Function([chapters, clues] -> [bool])\n\n# Constraints\nForAll([c:chapters], Count([cl:clues], mentioned(c, cl)) == 1) ::: Each of seven different clues—R, S, T, U, W, X, and Z—is to be mentioned exactly once, one clue per chapter\nNot(mentioned(1, T)) ::: T cannot be mentioned in chapter 1\nExists([c1:chapters, c2:chapters], And(mentioned(c1, T), mentioned(c2, W), c2 - c1 == 3)) ::: T must be mentioned before W, and there must be exactly two chapters separating the mention of T from the mention of W\nForAll([c:chapters], Implies(mentioned(c, S), Not(mentioned(c + 1, Z)))) ::: S and Z cannot be mentioned in adjacent chapters\nForAll([c:chapters], Implies(mentioned(c, W), Not(mentioned(c + 1, X)))) ::: W and X cannot be mentioned in adjacent chapters\nExists([c:chapters], And(mentioned(c, U), mentioned(c + 1, X))) ::: U and X must be mentioned in adjacent chapters\nmentioned(3, U) ::: If U is mentioned in chapter 3\n\n# Options\nQuestion ::: If U is mentioned in chapter 3, which one of the following could be true?\nis_sat(mentioned(1, R)) ::: (A)\nis_sat(mentioned(5, R)) ::: (B)\nis_sat(mentioned(7, S)) ::: (C)\nis_sat(mentioned(6, W)) ::: (D)\nis_sat(mentioned(4, X)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201612_3-G_2_9",
    "context": "An author is planning to write a mystery novel consisting of seven chapters, chapter 1 through chapter 7. Each of seven different clues—R, S, T, U, W, X, and Z—is to be mentioned exactly once, one clue per chapter. The order in which the clues are mentioned is subject to the following constraints: T cannot be mentioned in chapter 1. T must be mentioned before W, and there must be exactly two chapters separating the mention of T from the mention of W. S and Z cannot be mentioned in adjacent chapters. W and X cannot be mentioned in adjacent chapters. U and X must be mentioned in adjacent chapters.",
    "question": "If Z is mentioned in chapter 7, which one of the following could be true?",
    "answer": "D",
    "options": [
      "A) R is mentioned in chapter 3.",
      "B) S is mentioned in chapter 3.",
      "C) T is mentioned in chapter 4.",
      "D) U is mentioned in chapter 1.",
      "E) X is mentioned in chapter 5."
    ],
    "raw_logic_programs": [
      "# Declarations\nchapters = EnumSort([1, 2, 3, 4, 5, 6, 7])\nclues = EnumSort([R, S, T, U, W, X, Z])\nmentioned = Function([chapters, clues] -> [bool])\n\n# Constraints\nForAll([c:chapters], Count([cl:clues], mentioned(c, cl)) == 1) ::: Each of seven different clues—R, S, T, U, W, X, and Z—is to be mentioned exactly once, one clue per chapter\nNot(mentioned(1, T)) ::: T cannot be mentioned in chapter 1\nExists([c1:chapters, c2:chapters], And(mentioned(c1, T), mentioned(c2, W), c2 - c1 == 3)) ::: T must be mentioned before W, and there must be exactly two chapters separating the mention of T from the mention of W\nForAll([c:chapters], Implies(mentioned(c, S), Not(mentioned(c + 1, Z)))) ::: S and Z cannot be mentioned in adjacent chapters\nForAll([c:chapters], Implies(mentioned(c, W), Not(mentioned(c + 1, X)))) ::: W and X cannot be mentioned in adjacent chapters\nExists([c:chapters], And(mentioned(c, U), mentioned(c + 1, X))) ::: U and X must be mentioned in adjacent chapters\nmentioned(7, Z) ::: If Z is mentioned in chapter 7\n\n# Options\nQuestion ::: If Z is mentioned in chapter 7, which one of the following could be true?\nis_sat(mentioned(3, R)) ::: (A)\nis_sat(mentioned(3, S)) ::: (B)\nis_sat(mentioned(4, T)) ::: (C)\nis_sat(mentioned(1, U)) ::: (D)\nis_sat(mentioned(5, X)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201612_3-G_2_10",
    "context": "An author is planning to write a mystery novel consisting of seven chapters, chapter 1 through chapter 7. Each of seven different clues—R, S, T, U, W, X, and Z—is to be mentioned exactly once, one clue per chapter. The order in which the clues are mentioned is subject to the following constraints: T cannot be mentioned in chapter 1. T must be mentioned before W, and there must be exactly two chapters separating the mention of T from the mention of W. S and Z cannot be mentioned in adjacent chapters. W and X cannot be mentioned in adjacent chapters. U and X must be mentioned in adjacent chapters.",
    "question": "Which one of the following could be true?",
    "answer": "A",
    "options": [
      "A) R is mentioned in chapter 7.",
      "B) T is mentioned in chapter 5.",
      "C) U is mentioned in chapter 7.",
      "D) W is mentioned in chapter 3.",
      "E) X is mentioned in chapter 6."
    ],
    "raw_logic_programs": [
      "# Declarations\nchapters = EnumSort([1, 2, 3, 4, 5, 6, 7])\nclues = EnumSort([R, S, T, U, W, X, Z])\nmentioned = Function([chapters, clues] -> [bool])\n\n# Constraints\nForAll([c:chapters], Count([cl:clues], mentioned(c, cl)) == 1) ::: Each of seven different clues—R, S, T, U, W, X, and Z—is to be mentioned exactly once, one clue per chapter\nNot(mentioned(1, T)) ::: T cannot be mentioned in chapter 1\nExists([c1:chapters, c2:chapters], And(mentioned(c1, T), mentioned(c2, W), c2 - c1 == 3)) ::: T must be mentioned before W, and there must be exactly two chapters separating the mention of T from the mention of W\nForAll([c:chapters], Implies(mentioned(c, S), Not(mentioned(c + 1, Z)))) ::: S and Z cannot be mentioned in adjacent chapters\nForAll([c:chapters], Implies(mentioned(c, W), Not(mentioned(c + 1, X)))) ::: W and X cannot be mentioned in adjacent chapters\nExists([c:chapters], And(mentioned(c, U), mentioned(c + 1, X))) ::: U and X must be mentioned in adjacent chapters\n\n# Options\nQuestion ::: Which one of the following could be true?\nis_sat(mentioned(7, R)) ::: (A)\nis_sat(mentioned(5, T)) ::: (B)\nis_sat(mentioned(7, U)) ::: (C)\nis_sat(mentioned(3, W)) ::: (D)\nis_sat(mentioned(6, X)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201612_3-G_2_11",
    "context": "An author is planning to write a mystery novel consisting of seven chapters, chapter 1 through chapter 7. Each of seven different clues—R, S, T, U, W, X, and Z—is to be mentioned exactly once, one clue per chapter. The order in which the clues are mentioned is subject to the following constraints: T cannot be mentioned in chapter 1. T must be mentioned before W, and there must be exactly two chapters separating the mention of T from the mention of W. S and Z cannot be mentioned in adjacent chapters. W and X cannot be mentioned in adjacent chapters. U and X must be mentioned in adjacent chapters.",
    "question": "Which one of the following, if substituted for the constraint that T cannot be mentioned in chapter 1, would have the same effect in determining the order in which the clues are mentioned?",
    "answer": "B",
    "options": [
      "A) U cannot be mentioned in chapter 2.",
      "B) W cannot be mentioned in chapter 4.",
      "C) X cannot be mentioned in chapter 6.",
      "D) U must be mentioned in an earlier chapter than T.",
      "E) X must be mentioned in an earlier chapter than W,"
    ],
    "raw_logic_programs": [
      "# Declarations\nchapters = EnumSort([1, 2, 3, 4, 5, 6, 7])\nclues = EnumSort([R, S, T, U, W, X, Z])\nmentioned = Function([chapters, clues] -> [bool])\n\n# Constraints\nForAll([c:chapters], Count([cl:clues], mentioned(c, cl)) == 1) ::: Each of seven different clues—R, S, T, U, W, X, and Z—is to be mentioned exactly once, one clue per chapter\nNot(mentioned(1, T)) ::: T cannot be mentioned in chapter 1\nAnd(Exists([c1:chapters, c2:chapters], And(mentioned(c1, T), mentioned(c2, W), c2 - c1 == 3)), Not(Exists([c1:chapters, c2:chapters], And(mentioned(c1, T), mentioned(c2, W), c2 - c1 < 3)))) ::: T must be mentioned before W, and there must be exactly two chapters separating the mention of T from the mention of W\nForAll([c:chapters], Implies(mentioned(c, S), Not(mentioned(c + 1, Z)))) ::: S and Z cannot be mentioned in adjacent chapters\nForAll([c:chapters], Implies(mentioned(c, W), Not(mentioned(c + 1, X)))) ::: W and X cannot be mentioned in adjacent chapters\nForAll([c:chapters], Implies(mentioned(c, U), mentioned(c + 1, X))) ::: U and X must be mentioned in adjacent chapters\n\n# Options\nQuestion ::: Which one of the following, if substituted for the constraint that T cannot be mentioned in chapter 1, would have the same effect in determining the order in which the clues are mentioned?\nis_equivalent(Not(mentioned(2, U))) ::: (A)\nis_equivalent(Not(mentioned(4, W))) ::: (B)\nis_equivalent(Not(mentioned(6, X))) ::: (C)\nis_equivalent(Exists([c1:chapters, c2:chapters], And(mentioned(c1, U), mentioned(c2, T), c1 < c2))) ::: (D)\nis_equivalent(Exists([c1:chapters, c2:chapters], And(mentioned(c1, X), mentioned(c2, W), c1 < c2))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201612_3-G_3_12",
    "context": "At an upcoming exhibition, four art students—Franz, Greene, Hidalgo, and Isaacs—will each display exactly two paintings—an oil and a watercolor. Exactly two paintings will be displayed on each of the walls of the exhibition room—walls 1, 2, 3, and 4—with one painting in the upper position and one in the lower position. The following conditions will apply: No wall has only watercolors displayed on it. No wall has the work of only one student displayed on it. No wall has both a painting by Franz and a painting by Isaacs displayed on it. Greene's watercolor is displayed in the upper position of the wall on which Franz's oil is displayed. Isaacs's oil is displayed in the lower position of wall 4.",
    "question": "Which one of the following could be an accurate list of the paintings displayed in the lower position on walls 1 through 4, listed in that order?",
    "answer": "C",
    "options": [
      "A) Franz's oil, Franz's watercolor, Greene's oil, Isaacs's oil",
      "B) Franz's oil, Hidalgo's watercolor, Isaacs's watercolor, Isaacs's oil",
      "C) Greene's oil, Franz's oil, Isaacs's oil, Hidalgo's oil",
      "D) Hidalgo's oil, Greene's oil, Greene's watercolor, Isaacs's oil",
      "E) Hidalgo's watercolor, Franz's oil, Greene's oil, Isaacs's oil"
    ],
    "raw_logic_programs": [
      "# Declarations\nstudents = EnumSort([Franz, Greene, Hidalgo, Isaacs])\npaintings = EnumSort([oil, watercolor])\nwalls = EnumSort([1, 2, 3, 4])\npositions = EnumSort([upper, lower])\ndisplayed = Function([students, paintings, walls, positions] -> [bool])\n\n# Constraints\nForAll([w:walls], Exists([s1:students, s2:students, p1:paintings, p2:paintings], And(s1 != s2, And(displayed(s1, p1, w, upper), displayed(s2, p2, w, lower))))) ::: No wall has only watercolors displayed on it\nForAll([w:walls], Exists([s1:students, s2:students, p1:paintings, p2:paintings], And(s1 != s2, And(displayed(s1, p1, w, upper), displayed(s2, p2, w, lower))))) ::: No wall has the work of only one student displayed on it\nForAll([w:walls], Not(And(displayed(Franz, oil, w, upper), displayed(Isaacs, oil, w, lower)))) ::: No wall has both a painting by Franz and a painting by Isaacs displayed on it\nForAll([w:walls], Implies(displayed(Franz, oil, w, upper), displayed(Greene, watercolor, w, lower))) ::: Greene's watercolor is displayed in the upper position of the wall on which Franz's oil is displayed\ndisplayed(Isaacs, oil, 4, lower) ::: Isaacs's oil is displayed in the lower position of wall 4\n\n# Options\nQuestion ::: Which one of the following could be an accurate list of the paintings displayed in the lower position on walls 1 through 4, listed in that order?\nis_accurate_list([displayed(Franz, oil, 1, lower), displayed(Franz, watercolor, 2, lower), displayed(Greene, oil, 3, lower), displayed(Isaacs, oil, 4, lower)]) ::: (A)\nis_accurate_list([displayed(Franz, oil, 1, lower), displayed(Hidalgo, watercolor, 2, lower), displayed(Isaacs, watercolor, 3, lower), displayed(Isaacs, oil, 4, lower)]) ::: (B)\nis_accurate_list([displayed(Greene, oil, 1, lower), displayed(Franz, oil, 2, lower), displayed(Isaacs, oil, 3, lower), displayed(Hidalgo, oil, 4, lower)]) ::: (C)\nis_accurate_list([displayed(Hidalgo, oil, 1, lower), displayed(Greene, oil, 2, lower), displayed(Greene, watercolor, 3, lower), displayed(Isaacs, oil, 4, lower)]) ::: (D)\nis_accurate_list([displayed(Hidalgo, watercolor, 1, lower), displayed(Franz, oil, 2, lower), displayed(Greene, oil, 3, lower), displayed(Isaacs, oil, 4, lower)]) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201612_3-G_3_13",
    "context": "At an upcoming exhibition, four art students—Franz, Greene, Hidalgo, and Isaacs—will each display exactly two paintings—an oil and a watercolor. Exactly two paintings will be displayed on each of the walls of the exhibition room—walls 1, 2, 3, and 4—with one painting in the upper position and one in the lower position. The following conditions will apply: No wall has only watercolors displayed on it. No wall has the work of only one student displayed on it. No wall has both a painting by Franz and a painting by Isaacs displayed on it. Greene's watercolor is displayed in the upper position of the wall on which Franz's oil is displayed. Isaacs's oil is displayed in the lower position of wall 4.",
    "question": "If Isaacs's watercolor is displayed on wall 2 and Franz's oil is displayed on wall 3, which one of the following must be displayed on wall 1?",
    "answer": "A",
    "options": [
      "A) Franz's watercolor",
      "B) Greene's oil",
      "C) Greene's watercolor",
      "D) Hidalgo's oil",
      "E) Hidalgo's watercolor"
    ],
    "raw_logic_programs": [
      "# Declarations\nstudents = EnumSort([Franz, Greene, Hidalgo, Isaacs])\npaintings = EnumSort([oil, watercolor])\nwalls = EnumSort([1, 2, 3, 4])\npositions = EnumSort([upper, lower])\ndisplayed = Function([students, paintings, walls, positions] -> [bool])\n\n# Constraints\nForAll([w:walls], Exists([s:students, p:paintings], displayed(s, p, w, upper))) ::: Exactly two paintings will be displayed on each of the walls\nForAll([w:walls], Exists([s:students, p:paintings], displayed(s, p, w, lower))) ::: Exactly two paintings will be displayed on each of the walls\nForAll([w:walls], Not(And(displayed(Franz, watercolor, w, upper), displayed(Franz, watercolor, w, lower)))) ::: No wall has only watercolors displayed on it\nForAll([w:walls], Not(And(displayed(Franz, oil, w, upper), displayed(Franz, oil, w, lower)))) ::: No wall has only watercolors displayed on it\nForAll([w:walls], Not(And(displayed(Greene, watercolor, w, upper), displayed(Greene, watercolor, w, lower)))) ::: No wall has only watercolors displayed on it\nForAll([w:walls], Not(And(displayed(Greene, oil, w, upper), displayed(Greene, oil, w, lower)))) ::: No wall has only watercolors displayed on it\nForAll([w:walls], Not(And(displayed(Hidalgo, watercolor, w, upper), displayed(Hidalgo, watercolor, w, lower)))) ::: No wall has only watercolors displayed on it\nForAll([w:walls], Not(And(displayed(Hidalgo, oil, w, upper), displayed(Hidalgo, oil, w, lower)))) ::: No wall has only watercolors displayed on it\nForAll([w:walls], Not(And(displayed(Isaacs, watercolor, w, upper), displayed(Isaacs, watercolor, w, lower)))) ::: No wall has only watercolors displayed on it\nForAll([w:walls], Not(And(displayed(Isaacs, oil, w, upper), displayed(Isaacs, oil, w, lower)))) ::: No wall has only watercolors displayed on it\nForAll([w:walls], Not(And(displayed(Franz, oil, w, upper), displayed(Franz, oil, w, lower), displayed(Isaacs, oil, w, upper), displayed(Isaacs, oil, w, lower)))) ::: No wall has the work of only one student displayed on it\nForAll([w:walls], Not(And(displayed(Franz, watercolor, w, upper), displayed(Franz, watercolor, w, lower), displayed(Isaacs, watercolor, w, upper), displayed(Isaacs, watercolor, w, lower)))) ::: No wall has the work of only one student displayed on it\nForAll([w:walls], Not(And(displayed(Franz, oil, w, upper), displayed(Franz, oil, w, lower), displayed(Greene, oil, w, upper), displayed(Greene, oil, w, lower)))) ::: No wall has the work of only one student displayed on it\nForAll([w:walls], Not(And(displayed(Franz, watercolor, w, upper), displayed(Franz, watercolor, w, lower), displayed(Greene, watercolor, w, upper), displayed(Greene, watercolor, w, lower)))) ::: No wall has the work of only one student displayed on it\nForAll([w:walls], Not(And(displayed(Franz, oil, w, upper), displayed(Franz, oil, w, lower), displayed(Hidalgo, oil, w, upper), displayed(Hidalgo, oil, w, lower)))) ::: No wall has the work of only one student displayed on it\nForAll([w:walls], Not(And(displayed(Franz, watercolor, w, upper), displayed(Franz, watercolor, w, lower), displayed(Hidalgo, watercolor, w, upper), displayed(Hidalgo, watercolor, w, lower)))) ::: No wall has the work of only one student displayed on it\nForAll([w:walls], Not(And(displayed(Franz, oil, w, upper), displayed(Franz, oil, w, lower), displayed(Isaacs, oil, w, upper), displayed(Isaacs, oil, w, lower)))) ::: No wall has the work of only one student displayed on it\nForAll([w:walls], Not(And(displayed(Franz, watercolor, w, upper), displayed(Franz, watercolor, w, lower), displayed(Isaacs, watercolor, w, upper), displayed(Isaacs, watercolor, w, lower)))) ::: No wall has the work of only one student displayed on it\nForAll([w:walls], Not(And"
    ]
  },
  {
    "id": "ar_lsat_201612_3-G_3_14",
    "context": "At an upcoming exhibition, four art students—Franz, Greene, Hidalgo, and Isaacs—will each display exactly two paintings—an oil and a watercolor. Exactly two paintings will be displayed on each of the walls of the exhibition room—walls 1, 2, 3, and 4—with one painting in the upper position and one in the lower position. The following conditions will apply: No wall has only watercolors displayed on it. No wall has the work of only one student displayed on it. No wall has both a painting by Franz and a painting by Isaacs displayed on it. Greene's watercolor is displayed in the upper position of the wall on which Franz's oil is displayed. Isaacs's oil is displayed in the lower position of wall 4.",
    "question": "If Hidalgo's oil is displayed on wall 2, which one of the following could also be displayed on wall 2?",
    "answer": "E",
    "options": [
      "A) Franz's oil",
      "B) Greene's watercolor",
      "C) Greene's oil",
      "D) Hidalgo's watercolor",
      "E) Isaacs's watercolor"
    ],
    "raw_logic_programs": [
      "# Declarations\nstudents = EnumSort([Franz, Greene, Hidalgo, Isaacs])\npaintings = EnumSort([oil, watercolor])\nwalls = EnumSort([1, 2, 3, 4])\npositions = EnumSort([upper, lower])\ndisplayed = Function([students, paintings, walls, positions] -> [bool])\n\n# Constraints\nForAll([w:walls], Exists([s1:students, s2:students, p1:paintings, p2:paintings], And(s1 != s2, And(displayed(s1, p1, w, upper), displayed(s2, p2, w, lower))))) ::: No wall has only watercolors displayed on it\nForAll([w:walls], Exists([s1:students, s2:students, p1:paintings, p2:paintings], And(s1 != s2, And(displayed(s1, p1, w, upper), displayed(s2, p2, w, lower))))) ::: No wall has the work of only one student displayed on it\nForAll([w:walls], Not(And(displayed(Franz, oil, w, upper), displayed(Isaacs, oil, w, lower)))) ::: No wall has both a painting by Franz and a painting by Isaacs displayed on it\nForAll([w:walls], Implies(displayed(Franz, oil, w, upper), displayed(Greene, watercolor, w, lower))) ::: Greene's watercolor is displayed in the upper position of the wall on which Franz's oil is displayed\ndisplayed(Isaacs, oil, 4, lower) ::: Isaacs's oil is displayed in the lower position of wall 4\ndisplayed(Hidalgo, oil, 2, upper) ::: If Hidalgo's oil is displayed on wall 2\n\n# Options\nQuestion ::: Which one of the following could also be displayed on wall 2?\nis_sat(displayed(Franz, oil, 2, lower)) ::: (A)\nis_sat(displayed(Greene, watercolor, 2, lower)) ::: (B)\nis_sat(displayed(Greene, oil, 2, lower)) ::: (C)\nis_sat(displayed(Hidalgo, watercolor, 2, lower)) ::: (D)\nis_sat(displayed(Isaacs, watercolor, 2, lower)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201612_3-G_3_15",
    "context": "At an upcoming exhibition, four art students—Franz, Greene, Hidalgo, and Isaacs—will each display exactly two paintings—an oil and a watercolor. Exactly two paintings will be displayed on each of the walls of the exhibition room—walls 1, 2, 3, and 4—with one painting in the upper position and one in the lower position. The following conditions will apply: No wall has only watercolors displayed on it. No wall has the work of only one student displayed on it. No wall has both a painting by Franz and a painting by Isaacs displayed on it. Greene's watercolor is displayed in the upper position of the wall on which Franz's oil is displayed. Isaacs's oil is displayed in the lower position of wall 4.",
    "question": "If Greene's oil is displayed on the same wall as Franz's watercolor, which one of the following must be true?",
    "answer": "D",
    "options": [
      "A) Greene's oil is displayed in an upper position.",
      "B) Hidalgo's watercolor is displayed on the same wall as Isaacs's watercolor.",
      "C) Hidalgo's oil is displayed in an upper position.",
      "D) Hidalgo's oil is displayed on the same wall as Isaacs's watercolor.",
      "E) Isaacs's watercolor is displayed in a lower position."
    ],
    "raw_logic_programs": [
      "# Declarations\nstudents = EnumSort([Franz, Greene, Hidalgo, Isaacs])\npaintings = EnumSort([oil, watercolor])\nwalls = EnumSort([1, 2, 3, 4])\npositions = EnumSort([upper, lower])\ndisplayed = Function([students, paintings, walls, positions] -> [bool])\n\n# Constraints\nForAll([w:walls], Exists([s1:students, s2:students, p1:paintings, p2:paintings], And(s1 != s2, And(displayed(s1, p1, w, upper), displayed(s2, p2, w, lower))))) ::: No wall has only watercolors displayed on it\nForAll([w:walls], Exists([s1:students, s2:students, p1:paintings, p2:paintings], And(s1 != s2, And(displayed(s1, p1, w, upper), displayed(s2, p2, w, lower))))) ::: No wall has the work of only one student displayed on it\nForAll([w:walls], Not(And(displayed(Franz, oil, w, upper), displayed(Isaacs, oil, w, lower)))) ::: No wall has both a painting by Franz and a painting by Isaacs displayed on it\nForAll([w:walls], Implies(displayed(Franz, oil, w, upper), displayed(Greene, watercolor, w, upper))) ::: Greene's watercolor is displayed in the upper position of the wall on which Franz's oil is displayed\ndisplayed(Isaacs, oil, 4, lower) ::: Isaacs's oil is displayed in the lower position of wall 4\n\n# Options\nQuestion ::: If Greene's oil is displayed on the same wall as Franz's watercolor, which one of the following must be true?\nis_valid(Exists([w:walls], And(displayed(Greene, oil, w, upper), displayed(Franz, watercolor, w, lower)))) ::: (A)\nis_valid(Exists([w:walls], And(displayed(Hidalgo, watercolor, w, upper), displayed(Isaacs, watercolor, w, lower)))) ::: (B)\nis_valid(Exists([w:walls], And(displayed(Hidalgo, oil, w, upper), displayed(Franz, watercolor, w, lower)))) ::: (C)\nis_valid(Exists([w:walls], And(displayed(Hidalgo, oil, w, upper), displayed(Isaacs, watercolor, w, lower)))) ::: (D)\nis_valid(Exists([w:walls], And(displayed(Isaacs, watercolor, w, lower), displayed(Franz, watercolor, w, lower)))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201612_3-G_3_16",
    "context": "At an upcoming exhibition, four art students—Franz, Greene, Hidalgo, and Isaacs—will each display exactly two paintings—an oil and a watercolor. Exactly two paintings will be displayed on each of the walls of the exhibition room—walls 1, 2, 3, and 4—with one painting in the upper position and one in the lower position. The following conditions will apply: No wall has only watercolors displayed on it. No wall has the work of only one student displayed on it. No wall has both a painting by Franz and a painting by Isaacs displayed on it. Greene's watercolor is displayed in the upper position of the wall on which Franz's oil is displayed. Isaacs's oil is displayed in the lower position of wall 4.",
    "question": "If Franz's oil is displayed on wall 1, which one of the following could be true?",
    "answer": "B",
    "options": [
      "A) Franz's watercolor is displayed on wall 4.",
      "B) Greene's oil is displayed on wall 2.",
      "C) Greene's watercolor is displayed on wall 2.",
      "D) Hidalgo's watercolor is displayed on wall 3.",
      "E) Isaacs's oil is displayed on wall 1."
    ],
    "raw_logic_programs": [
      "# Declarations\nstudents = EnumSort([Franz, Greene, Hidalgo, Isaacs])\npaintings = EnumSort([oil, watercolor])\nwalls = EnumSort([1, 2, 3, 4])\npositions = EnumSort([upper, lower])\ndisplayed = Function([students, paintings, walls, positions] -> [bool])\n\n# Constraints\nForAll([w:walls], Exists([s1:students, s2:students, p1:paintings, p2:paintings], And(s1 != s2, And(displayed(s1, p1, w, upper), displayed(s2, p2, w, lower))))) ::: No wall has only watercolors displayed on it\nForAll([w:walls], Exists([s1:students, s2:students, p1:paintings, p2:paintings], And(s1 != s2, And(displayed(s1, p1, w, upper), displayed(s2, p2, w, lower))))) ::: No wall has the work of only one student displayed on it\nForAll([w:walls], Not(And(displayed(Franz, oil, w, upper), displayed(Isaacs, oil, w, lower)))) ::: No wall has both a painting by Franz and a painting by Isaacs displayed on it\nForAll([w:walls], Implies(displayed(Franz, oil, w, upper), displayed(Greene, watercolor, w, upper))) ::: Greene's watercolor is displayed in the upper position of the wall on which Franz's oil is displayed\ndisplayed(Isaacs, oil, 4, lower) ::: Isaacs's oil is displayed in the lower position of wall 4\ndisplayed(Franz, oil, 1, upper) ::: Franz's oil is displayed on wall 1\n\n# Options\nQuestion ::: If Franz's oil is displayed on wall 1, which one of the following could be true?\nis_sat(displayed(Franz, watercolor, 4, upper)) ::: (A)\nis_sat(displayed(Greene, oil, 2, upper)) ::: (B)\nis_sat(displayed(Greene, watercolor, 2, upper)) ::: (C)\nis_sat(displayed(Hidalgo, watercolor, 3, upper)) ::: (D)\nis_sat(displayed(Isaacs, oil, 1, upper)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201612_3-G_3_17",
    "context": "At an upcoming exhibition, four art students—Franz, Greene, Hidalgo, and Isaacs—will each display exactly two paintings—an oil and a watercolor. Exactly two paintings will be displayed on each of the walls of the exhibition room—walls 1, 2, 3, and 4—with one painting in the upper position and one in the lower position. The following conditions will apply: No wall has only watercolors displayed on it. No wall has the work of only one student displayed on it. No wall has both a painting by Franz and a painting by Isaacs displayed on it. Greene's watercolor is displayed in the upper position of the wall on which Franz's oil is displayed. Isaacs's oil is displayed in the lower position of wall 4.",
    "question": "Which one of the following could be true?",
    "answer": "D",
    "options": [
      "A) Both of Franz's paintings and both of Greene's paintings are displayed in lower positions.",
      "B) Both of Franz's paintings and both of Greene's paintings are displayed in upper positions.",
      "C) Both of Franz's paintings and both of Hidalgo's paintings are displayed in upper positions.",
      "D) Both of Greene's paintings and both of Hidalgo's paintings are displayed in lower positions.",
      "E) Both of Greene's paintings and both of Hidalgo's paintings are displayed in upper positions."
    ],
    "raw_logic_programs": [
      "# Declarations\nstudents = EnumSort([Franz, Greene, Hidalgo, Isaacs])\npaintings = EnumSort([oil, watercolor])\nwalls = EnumSort([1, 2, 3, 4])\npositions = EnumSort([upper, lower])\ndisplayed = Function([students, paintings, walls, positions] -> [bool])\n\n# Constraints\nForAll([w:walls], Exists([s:students, p:paintings], displayed(s, p, w, upper))) ::: Exactly two paintings will be displayed on each of the walls\nForAll([w:walls], Exists([s:students, p:paintings], displayed(s, p, w, lower))) ::: Exactly two paintings will be displayed on each of the walls\nForAll([w:walls], Not(ForAll([s:students], Implies(displayed(s, watercolor, w, upper), displayed(s, watercolor, w, lower))))) ::: No wall has only watercolors displayed on it\nForAll([w:walls], Not(Exists([s:students], ForAll([s2:students], Implies(s2 != s, Not(displayed(s2, oil, w, upper))))))) ::: No wall has the work of only one student displayed on it\nForAll([w:walls], Not(Exists([s:students], ForAll([s2:students], Implies(s2 != s, Not(displayed(s2, watercolor, w, lower))))))) ::: No wall has the work of only one student displayed on it\nForAll([w:walls], Not(And(displayed(Franz, oil, w, upper), displayed(Isaacs, oil, w, lower)))) ::: No wall has both a painting by Franz and a painting by Isaacs displayed on it\nForAll([w:walls], Not(And(displayed(Franz, oil, w, lower), displayed(Isaacs, oil, w, upper)))) ::: No wall has both a painting by Franz and a painting by Isaacs displayed on it\nForAll([w:walls], Implies(displayed(Franz, oil, w, upper), displayed(Greene, watercolor, w, upper))) ::: Greene's watercolor is displayed in the upper position of the wall on which Franz's oil is displayed\nForAll([w:walls], Implies(displayed(Franz, oil, w, lower), displayed(Greene, watercolor, w, lower))) ::: Greene's watercolor is displayed in the upper position of the wall on which Franz's oil is displayed\ndisplayed(Isaacs, oil, 4, lower) ::: Isaacs's oil is displayed in the lower position of wall 4\n\n# Options\nQuestion ::: Which one of the following could be true?\nis_sat(And(ForAll([w:walls], Implies(displayed(Franz, oil, w, lower), displayed(Franz, watercolor, w, lower))), ForAll([w:walls], Implies(displayed(Greene, oil, w, lower), displayed(Greene, watercolor, w, lower))))) ::: (A)\nis_sat(And(ForAll([w:walls], Implies(displayed(Franz, oil, w, upper), displayed(Franz, watercolor, w, upper))), ForAll([w:walls], Implies(displayed(Greene, oil, w, upper), displayed(Greene, watercolor, w, upper))))) ::: (B)\nis_sat(And(ForAll([w:walls], Implies(displayed(Franz, oil, w, upper), displayed(Franz, watercolor, w, upper))), ForAll([w:walls], Implies(displayed(Hidalgo, oil, w, upper), displayed(Hidalgo, watercolor, w, upper))))) ::: (C)\nis_sat(And(ForAll([w:walls], Implies(displayed(Greene, oil, w, lower), displayed(Greene, watercolor, w, lower))), ForAll([w:walls], Implies(displayed(Hidalgo, oil, w, lower), displayed(Hidalgo, watercolor, w, lower))))) ::: (D)\nis_sat(And(ForAll([w:walls], Implies(displayed(Greene, oil, w, upper), displayed(Greene, watercolor, w, upper))), ForAll([w:walls], Implies(displayed(Hidalgo, oil, w, upper), displayed(Hidalgo, watercolor, w, upper))))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201612_3-G_3_18",
    "context": "At an upcoming exhibition, four art students—Franz, Greene, Hidalgo, and Isaacs—will each display exactly two paintings—an oil and a watercolor. Exactly two paintings will be displayed on each of the walls of the exhibition room—walls 1, 2, 3, and 4—with one painting in the upper position and one in the lower position. The following conditions will apply: No wall has only watercolors displayed on it. No wall has the work of only one student displayed on it. No wall has both a painting by Franz and a painting by Isaacs displayed on it. Greene's watercolor is displayed in the upper position of the wall on which Franz's oil is displayed. Isaacs's oil is displayed in the lower position of wall 4.",
    "question": "Which one of the following CANNOT be true?",
    "answer": "D",
    "options": [
      "A) Franz's watercolor is displayed on the same wall as Greene's oil.",
      "B) Franz's watercolor is displayed on the same wall as Hidalgo's oil.",
      "C) Greene's oil is displayed in an upper position.",
      "D) Hidalgo's watercolor is displayed in a lower position.",
      "E) Isaacs's watercolor is displayed on the same wall as Hidalgo's oil."
    ],
    "raw_logic_programs": [
      "# Declarations\nstudents = EnumSort([Franz, Greene, Hidalgo, Isaacs])\npaintings = EnumSort([oil, watercolor])\nwalls = EnumSort([1, 2, 3, 4])\npositions = EnumSort([upper, lower])\ndisplayed = Function([students, paintings, walls, positions] -> [bool])\n\n# Constraints\nForAll([w:walls], Exists([s1:students, s2:students, p1:paintings, p2:paintings], And(s1 != s2, And(displayed(s1, p1, w, upper), displayed(s2, p2, w, lower))))) ::: Exactly two paintings will be displayed on each of the walls\nForAll([w:walls], Exists([s:students, p:paintings], displayed(s, p, w, upper))) ::: No wall has only watercolors displayed on it\nForAll([w:walls], Exists([s1:students, s2:students, p1:paintings, p2:paintings], And(s1 != s2, And(displayed(s1, p1, w, upper), displayed(s2, p2, w, lower))))) ::: No wall has the work of only one student displayed on it\nForAll([w:walls], Not(And(displayed(Franz, oil, w, upper), displayed(Isaacs, oil, w, lower)))) ::: No wall has both a painting by Franz and a painting by Isaacs displayed on it\nForAll([w:walls], Implies(displayed(Franz, oil, w, upper), displayed(Greene, watercolor, w, upper))) ::: Greene's watercolor is displayed in the upper position of the wall on which Franz's oil is displayed\ndisplayed(Isaacs, oil, 4, lower) ::: Isaacs's oil is displayed in the lower position of wall 4\n\n# Options\nQuestion ::: Which one of the following CANNOT be true?\nis_unsat(Exists([w:walls], And(displayed(Franz, watercolor, w, upper), displayed(Greene, oil, w, lower)))) ::: (A)\nis_unsat(Exists([w:walls], And(displayed(Franz, watercolor, w, upper), displayed(Hidalgo, oil, w, lower)))) ::: (B)\nis_unsat(Exists([w:walls], And(displayed(Greene, oil, w, upper), displayed(Franz, watercolor, w, lower)))) ::: (C)\nis_unsat(Exists([w:walls], And(displayed(Hidalgo, watercolor, w, lower), displayed(Franz, watercolor, w, upper)))) ::: (D)\nis_unsat(Exists([w:walls], And(displayed(Isaacs, watercolor, w, upper), displayed(Hidalgo, oil, w, lower)))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201612_3-G_4_19",
    "context": "Three real estate companies—RealProp, Southco, and Trustcorp—are considering trading buildings with one another. Each building they own is categorized as either class 1, class 2, or class 3, depending on its approximate value: RealProp owns the Garza Tower (class 1), the Yates House (class 3), and the Zimmer House (class 3). Southco owns the Flores Tower (class 1) and the Lynch Building (class 2). Trustcorp owns the King Building, the Meyer Building, and the Ortiz Building, all of which are class 2. Each trade must be of exactly one of the following three kinds: Trading one building for one other building of the same class Trading one class 1 building for two class 2 buildings Trading one class 2 building for two class 3 buildings",
    "question": "Which one of the following could be the buildings owned by the three companies after only one trade is made?",
    "answer": "C",
    "options": [
      "A) RealProp: the Flores Tower and the Garza Tower Southco: the Lynch Building, the Yates House, and the Zimmer House Trustcorp: the King Building, the Meyer Building, and the Ortiz Building",
      "B) RealProp: the Garza Tower, the King Building, and the Ortiz Building Southco: the Flores Tower and the Lynch Building Trustcorp: the Meyer Building, the Yates House, and the Zimmer House",
      "C) RealProp: the Garza Tower and the Lynch Building Southco: the Flores Tower, the Yates House, and the Zimmer House Trustcorp: the King Building, the Meyer Building, and the Ortiz Building",
      "D) RealProp: the Garza Tower, the Meyer Building, and the Yates House Southco: the Flores Tower and the Lynch Building Trustcorp: the King Building, the Ortiz Building, and the Zimmer House",
      "E) RealProp: the Garza Tower, the Yates House, and the Zimmer House Southco: the Lynch Building and the Ortiz Building Trustcorp: the Flores Tower, the King Building, and the Meyer Building"
    ],
    "raw_logic_programs": [
      "# Declarations\ncompanies = EnumSort([RealProp, Southco, Trustcorp])\nbuildings = EnumSort([Garza_Tower, Yates_House, Zimmer_House, Flores_Tower, Lynch_Building, King_Building, Meyer_Building, Ortiz_Building])\nclasses = EnumSort([class1, class2, class3])\nowns = Function([companies, buildings] -> [bool])\nbuilding_class = Function([buildings] -> [classes])\n\n# Constraints\nowns(RealProp, Garza_Tower) ::: RealProp owns the Garza Tower\nowns(RealProp, Yates_House) ::: RealProp owns the Yates House\nowns(RealProp, Zimmer_House) ::: RealProp owns the Zimmer House\nowns(Southco, Flores_Tower) ::: Southco owns the Flores Tower\nowns(Southco, Lynch_Building) ::: Southco owns the Lynch Building\nowns(Trustcorp, King_Building) ::: Trustcorp owns the King Building\nowns(Trustcorp, Meyer_Building) ::: Trustcorp owns the Meyer Building\nowns(Trustcorp, Ortiz_Building) ::: Trustcorp owns the Ortiz Building\nbuilding_class(Garza_Tower) == class1 ::: the Garza Tower (class 1)\nbuilding_class(Yates_House) == class3 ::: the Yates House (class 3)\nbuilding_class(Zimmer_House) == class3 ::: the Zimmer House (class 3)\nbuilding_class(Flores_Tower) == class1 ::: the Flores Tower (class 1)\nbuilding_class(Lynch_Building) == class2 ::: the Lynch Building (class 2)\nbuilding_class(King_Building) == class2 ::: the King Building, the Meyer Building, and the Ortiz Building are all class 2\nbuilding_class(Meyer_Building) == class2\nbuilding_class(Ortiz_Building) == class2\n\n# Options\nQuestion ::: Which one of the following could be the buildings owned by the three companies after only one trade is made?\nis_sat(And(And(And(owns(RealProp, Flores_Tower), owns(RealProp, Garza_Tower)), And(owns(Southco, Lynch_Building), And(owns(Southco, Yates_House), owns(Southco, Zimmer_House)))), And(And(owns(Trustcorp, King_Building), owns(Trustcorp, Meyer_Building)), owns(Trustcorp, Ortiz_Building)))) ::: (A)\nis_sat(And(And(And(owns(RealProp, Garza_Tower), owns(RealProp, King_Building)), owns(RealProp, Ortiz_Building)), And(And(owns(Southco, Flores_Tower), owns(Southco, Lynch_Building)), And(owns(Trustcorp, Meyer_Building), And(owns(Trustcorp, Yates_House), owns(Trustcorp, Zimmer_House)))))) ::: (B)\nis_sat(And(And(And(owns(RealProp, Garza_Tower), owns(RealProp, Lynch_Building)), And(owns(Southco, Flores_Tower), And(owns(Southco, Yates_House), owns(Southco, Zimmer_House)))), And(And(owns(Trustcorp, King_Building), owns(Trustcorp, Meyer_Building)), owns(Trustcorp, Ortiz_Building)))) ::: (C)\nis_sat(And(And(And(owns(RealProp, Garza_Tower), owns(RealProp, Meyer_Building)), owns(RealProp, Yates_House)), And(And(owns(Southco, Flores_Tower), owns(Southco, Lynch_Building)), And(owns(Trustcorp, King_Building), And(owns(Trustcorp, Ortiz_Building), owns(Trustcorp, Zimmer_House)))))) ::: (D)\nis_sat(And(And(And(owns(RealProp, Garza_Tower), owns(RealProp, Yates_House)), owns(RealProp, Zimmer_House)), And(And(owns(Southco, Lynch_Building), owns(Southco, Ortiz_Building)), And(owns(Trustcorp, Flores_Tower), And(owns(Trustcorp, King_Building), owns(Trustcorp, Meyer_Building)))))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201612_3-G_4_20",
    "context": "Three real estate companies—RealProp, Southco, and Trustcorp—are considering trading buildings with one another. Each building they own is categorized as either class 1, class 2, or class 3, depending on its approximate value: RealProp owns the Garza Tower (class 1), the Yates House (class 3), and the Zimmer House (class 3). Southco owns the Flores Tower (class 1) and the Lynch Building (class 2). Trustcorp owns the King Building, the Meyer Building, and the Ortiz Building, all of which are class 2. Each trade must be of exactly one of the following three kinds: Trading one building for one other building of the same class Trading one class 1 building for two class 2 buildings Trading one class 2 building for two class 3 buildings",
    "question": "Which one of the following CANNOT be true, no matter how many trades are made?",
    "answer": "A",
    "options": [
      "A) The buildings owned by RealProp are the Flores Tower and the Garza Tower.",
      "B) The buildings owned by Southco are the Flores Tower and the Meyer Building.",
      "C) The buildings owned by Southco are the Garza Tower and the Lynch Building.",
      "D) The buildings owned by Trustcorp are the Flores Tower and the Ortiz Building.",
      "E) The buildings owned by Trustcorp are the Garza Tower and the Meyer Building."
    ],
    "raw_logic_programs": [
      "# Declarations\ncompanies = EnumSort([RealProp, Southco, Trustcorp])\nbuildings = EnumSort([Garza_Tower, Yates_House, Zimmer_House, Flores_Tower, Lynch_Building, King_Building, Meyer_Building, Ortiz_Building])\nclasses = EnumSort([1, 2, 3])\nowns = Function([companies, buildings] -> [bool])\nbuilding_class = Function([buildings] -> [classes])\n\n# Constraints\nAnd(owns(RealProp, Garza_Tower), building_class(Garza_Tower) == 1) ::: RealProp owns the Garza Tower (class 1)\nAnd(owns(RealProp, Yates_House), building_class(Yates_House) == 3) ::: RealProp owns the Yates House (class 3)\nAnd(owns(RealProp, Zimmer_House), building_class(Zimmer_House) == 3) ::: RealProp owns the Zimmer House (class 3)\nAnd(owns(Southco, Flores_Tower), building_class(Flores_Tower) == 1) ::: Southco owns the Flores Tower (class 1)\nAnd(owns(Southco, Lynch_Building), building_class(Lynch_Building) == 2) ::: Southco owns the Lynch Building (class 2)\nAnd(owns(Trustcorp, King_Building), building_class(King_Building) == 2) ::: Trustcorp owns the King Building, the Meyer Building, and the Ortiz Building, all of which are class 2\nAnd(owns(Trustcorp, Meyer_Building), building_class(Meyer_Building) == 2)\nAnd(owns(Trustcorp, Ortiz_Building), building_class(Ortiz_Building) == 2)\nForAll([c1:companies, c2:companies, b1:buildings, b2:buildings], Implies(And(owns(c1, b1), owns(c2, b2), b1 != b2), building_class(b1) != building_class(b2))) ::: Each trade must be of exactly one of the following three kinds: Trading one building for one other building of the same class Trading one class 1 building for two class 2 buildings Trading one class 2 building for two class 3 buildings\n\n# Options\nQuestion ::: Which one of the following CANNOT be true, no matter how many trades are made?\nis_unsat(And(owns(RealProp, Flores_Tower), owns(RealProp, Garza_Tower))) ::: (A)\nis_unsat(And(owns(Southco, Flores_Tower), owns(Southco, Meyer_Building))) ::: (B)\nis_unsat(And(owns(Southco, Garza_Tower), owns(Southco, Lynch_Building))) ::: (C)\nis_unsat(And(owns(Trustcorp, Flores_Tower), owns(Trustcorp, Ortiz_Building))) ::: (D)\nis_unsat(And(owns(Trustcorp, Garza_Tower), owns(Trustcorp, Meyer_Building))) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201612_3-G_4_21",
    "context": "Three real estate companies—RealProp, Southco, and Trustcorp—are considering trading buildings with one another. Each building they own is categorized as either class 1, class 2, or class 3, depending on its approximate value: RealProp owns the Garza Tower (class 1), the Yates House (class 3), and the Zimmer House (class 3). Southco owns the Flores Tower (class 1) and the Lynch Building (class 2). Trustcorp owns the King Building, the Meyer Building, and the Ortiz Building, all of which are class 2. Each trade must be of exactly one of the following three kinds: Trading one building for one other building of the same class Trading one class 1 building for two class 2 buildings Trading one class 2 building for two class 3 buildings",
    "question": "If RealProp owns only class 2 buildings after some number of trades, which one of the following must be true?",
    "answer": "A",
    "options": [
      "A) Trustcorp owns a class 1 building.",
      "B) Trustcorp owns the Meyer Building.",
      "C) Southco owns a class 2 Building.",
      "D) Southco owns both of the class 3 buildings.",
      "E) Southco owns the Flores Tower."
    ],
    "raw_logic_programs": [
      "# Declarations\ncompanies = EnumSort([RealProp, Southco, Trustcorp])\nbuildings = EnumSort([Garza_Tower, Yates_House, Zimmer_House, Flores_Tower, Lynch_Building, King_Building, Meyer_Building, Ortiz_Building])\nclasses = EnumSort([1, 2, 3])\nowns = Function([companies, buildings] -> [bool])\nclass_of = Function([buildings] -> [classes])\n\n# Constraints\nAnd(owns(RealProp, Garza_Tower), class_of(Garza_Tower) == 1) ::: RealProp owns the Garza Tower (class 1)\nAnd(owns(RealProp, Yates_House), class_of(Yates_House) == 3) ::: RealProp owns the Yates House (class 3)\nAnd(owns(RealProp, Zimmer_House), class_of(Zimmer_House) == 3) ::: RealProp owns the Zimmer House (class 3)\nAnd(owns(Southco, Flores_Tower), class_of(Flores_Tower) == 1) ::: Southco owns the Flores Tower (class 1)\nAnd(owns(Southco, Lynch_Building), class_of(Lynch_Building) == 2) ::: Southco owns the Lynch Building (class 2)\nAnd(owns(Trustcorp, King_Building), class_of(King_Building) == 2) ::: Trustcorp owns the King Building, the Meyer Building, and the Ortiz Building, all of which are class 2\nAnd(owns(Trustcorp, Meyer_Building), class_of(Meyer_Building) == 2)\nAnd(owns(Trustcorp, Ortiz_Building), class_of(Ortiz_Building) == 2)\n\n# Options\nQuestion ::: If RealProp owns only class 2 buildings after some number of trades, which one of the following must be true?\nis_valid(Exists([b:buildings], And(owns(Trustcorp, b), class_of(b) == 1))) ::: (A)\nis_valid(owns(Trustcorp, Meyer_Building)) ::: (B)\nis_valid(Exists([b:buildings], And(owns(Southco, b), class_of(b) == 2))) ::: (C)\nis_valid(And(owns(Southco, Yates_House), owns(Southco, Zimmer_House))) ::: (D)\nis_valid(owns(Southco, Flores_Tower)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201612_3-G_4_22",
    "context": "Three real estate companies—RealProp, Southco, and Trustcorp—are considering trading buildings with one another. Each building they own is categorized as either class 1, class 2, or class 3, depending on its approximate value: RealProp owns the Garza Tower (class 1), the Yates House (class 3), and the Zimmer House (class 3). Southco owns the Flores Tower (class 1) and the Lynch Building (class 2). Trustcorp owns the King Building, the Meyer Building, and the Ortiz Building, all of which are class 2. Each trade must be of exactly one of the following three kinds: Trading one building for one other building of the same class Trading one class 1 building for two class 2 buildings Trading one class 2 building for two class 3 buildings",
    "question": "If Trustcorp owns no class 2 buildings after some number of trades, which one of the following must be true?",
    "answer": "E",
    "options": [
      "A) RealProp owns a class 1 building.",
      "B) Southco owns only class 2 buildings.",
      "C) Southco has made at least one trade with Trustcorp.",
      "D) Trustcorp owns the Garza Tower.",
      "E) Trustcorp owns the Zimmer House."
    ],
    "raw_logic_programs": [
      "# Declarations\ncompanies = EnumSort([RealProp, Southco, Trustcorp])\nbuildings = EnumSort([Garza_Tower, Yates_House, Zimmer_House, Flores_Tower, Lynch_Building, King_Building, Meyer_Building, Ortiz_Building])\nclasses = EnumSort([1, 2, 3])\nowns = Function([companies, buildings] -> [bool])\nclass_of = Function([buildings] -> [classes])\n\n# Constraints\nAnd(owns(RealProp, Garza_Tower), class_of(Garza_Tower) == 1) ::: RealProp owns the Garza Tower (class 1)\nAnd(owns(RealProp, Yates_House), class_of(Yates_House) == 3) ::: RealProp owns the Yates House (class 3)\nAnd(owns(RealProp, Zimmer_House), class_of(Zimmer_House) == 3) ::: RealProp owns the Zimmer House (class 3)\nAnd(owns(Southco, Flores_Tower), class_of(Flores_Tower) == 1) ::: Southco owns the Flores Tower (class 1)\nAnd(owns(Southco, Lynch_Building), class_of(Lynch_Building) == 2) ::: Southco owns the Lynch Building (class 2)\nAnd(owns(Trustcorp, King_Building), class_of(King_Building) == 2) ::: Trustcorp owns the King Building, the Meyer Building, and the Ortiz Building, all of which are class 2\nAnd(owns(Trustcorp, Meyer_Building), class_of(Meyer_Building) == 2)\nAnd(owns(Trustcorp, Ortiz_Building), class_of(Ortiz_Building) == 2)\n\n# Options\nQuestion ::: If Trustcorp owns no class 2 buildings after some number of trades, which one of the following must be true?\nis_valid(Exists([b:buildings], And(owns(RealProp, b), class_of(b) == 1))) ::: (A)\nis_valid(ForAll([b:buildings], Implies(owns(Southco, b), class_of(b) == 2))) ::: (B)\nis_valid(Exists([b1:buildings, b2:buildings], And(owns(Southco, b1), owns(Trustcorp, b2), class_of(b1) == class_of(b2)))) ::: (C)\nis_valid(owns(Trustcorp, Garza_Tower)) ::: (D)\nis_valid(owns(Trustcorp, Zimmer_House)) ::: (E)\n"
    ]
  },
  {
    "id": "ar_lsat_201612_3-G_4_23",
    "context": "Three real estate companies—RealProp, Southco, and Trustcorp—are considering trading buildings with one another. Each building they own is categorized as either class 1, class 2, or class 3, depending on its approximate value: RealProp owns the Garza Tower (class 1), the Yates House (class 3), and the Zimmer House (class 3). Southco owns the Flores Tower (class 1) and the Lynch Building (class 2). Trustcorp owns the King Building, the Meyer Building, and the Ortiz Building, all of which are class 2. Each trade must be of exactly one of the following three kinds: Trading one building for one other building of the same class Trading one class 1 building for two class 2 buildings Trading one class 2 building for two class 3 buildings",
    "question": "Which one of the following CANNOT be true, no matter how many trades are made?",
    "answer": "D",
    "options": [
      "A) The buildings owned by RealProp are the Lynch Building, the Meyer Building, and the Ortiz Building.",
      "B) The buildings owned by Southco are the Garza Tower and the Meyer Building.",
      "C) The buildings owned by Southco are the King Building, the Meyer Building, and the Ortiz Building.",
      "D) The buildings owned by Trustcorp are the Flores Tower and the Yates House.",
      "E) The buildings owned by Trustcorp are the Garza Tower and the Lynch Building."
    ],
    "raw_logic_programs": [
      "# Declarations\ncompanies = EnumSort([RealProp, Southco, Trustcorp])\nbuildings = EnumSort([Garza_Tower, Yates_House, Zimmer_House, Flores_Tower, Lynch_Building, King_Building, Meyer_Building, Ortiz_Building])\nclasses = EnumSort([1, 2, 3])\nowns = Function([companies, buildings] -> [bool])\nbuilding_class = Function([buildings] -> [classes])\n\n# Constraints\nAnd(owns(RealProp, Garza_Tower), building_class(Garza_Tower) == 1) ::: RealProp owns the Garza Tower (class 1)\nAnd(owns(RealProp, Yates_House), building_class(Yates_House) == 3) ::: RealProp owns the Yates House (class 3)\nAnd(owns(RealProp, Zimmer_House), building_class(Zimmer_House) == 3) ::: RealProp owns the Zimmer House (class 3)\nAnd(owns(Southco, Flores_Tower), building_class(Flores_Tower) == 1) ::: Southco owns the Flores Tower (class 1)\nAnd(owns(Southco, Lynch_Building), building_class(Lynch_Building) == 2) ::: Southco owns the Lynch Building (class 2)\nAnd(owns(Trustcorp, King_Building), building_class(King_Building) == 2) ::: Trustcorp owns the King Building, the Meyer Building, and the Ortiz Building, all of which are class 2\nAnd(owns(Trustcorp, Meyer_Building), building_class(Meyer_Building) == 2)\nAnd(owns(Trustcorp, Ortiz_Building), building_class(Ortiz_Building) == 2)\nForAll([c1:companies, c2:companies, b1:buildings, b2:buildings], Implies(And(owns(c1, b1), owns(c2, b2), b1 != b2), building_class(b1) != building_class(b2))) ::: Each trade must be of exactly one of the following three kinds: Trading one building for one other building of the same class Trading one class 1 building for two class 2 buildings Trading one class 2 building for two class 3 buildings\n\n# Options\nQuestion ::: Which one of the following CANNOT be true, no matter how many trades are made?\nis_unsat(And(owns(RealProp, Lynch_Building), owns(RealProp, Meyer_Building), owns(RealProp, Ortiz_Building))) ::: (A)\nis_unsat(And(owns(Southco, Garza_Tower), owns(Southco, Meyer_Building))) ::: (B)\nis_unsat(And(owns(Southco, King_Building), owns(Southco, Meyer_Building), owns(Southco, Ortiz_Building))) ::: (C)\nis_unsat(And(owns(Trustcorp, Flores_Tower), owns(Trustcorp, Yates_House))) ::: (D)\nis_unsat(And(owns(Trustcorp, Garza_Tower), owns(Trustcorp, Lynch_Building))) ::: (E)\n"
    ]
  }
]